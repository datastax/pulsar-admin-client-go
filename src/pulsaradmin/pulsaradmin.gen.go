// Package pulsaradmin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package pulsaradmin

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AuthPoliciesNamespaceAuthentication.
const (
	AuthPoliciesNamespaceAuthenticationConsume   AuthPoliciesNamespaceAuthentication = "consume"
	AuthPoliciesNamespaceAuthenticationFunctions AuthPoliciesNamespaceAuthentication = "functions"
	AuthPoliciesNamespaceAuthenticationPackages  AuthPoliciesNamespaceAuthentication = "packages"
	AuthPoliciesNamespaceAuthenticationProduce   AuthPoliciesNamespaceAuthentication = "produce"
	AuthPoliciesNamespaceAuthenticationSinks     AuthPoliciesNamespaceAuthentication = "sinks"
	AuthPoliciesNamespaceAuthenticationSources   AuthPoliciesNamespaceAuthentication = "sources"
)

// Defines values for AuthPoliciesTopicAuthentication.
const (
	AuthPoliciesTopicAuthenticationConsume   AuthPoliciesTopicAuthentication = "consume"
	AuthPoliciesTopicAuthenticationFunctions AuthPoliciesTopicAuthentication = "functions"
	AuthPoliciesTopicAuthenticationPackages  AuthPoliciesTopicAuthentication = "packages"
	AuthPoliciesTopicAuthenticationProduce   AuthPoliciesTopicAuthentication = "produce"
	AuthPoliciesTopicAuthenticationSinks     AuthPoliciesTopicAuthentication = "sinks"
	AuthPoliciesTopicAuthenticationSources   AuthPoliciesTopicAuthentication = "sources"
)

// Defines values for AutoFailoverPolicyDataPolicyType.
const (
	MinAvailable AutoFailoverPolicyDataPolicyType = "min_available"
)

// Defines values for BacklogQuotaPolicy.
const (
	BacklogQuotaPolicyConsumerBacklogEviction BacklogQuotaPolicy = "consumer_backlog_eviction"
	BacklogQuotaPolicyProducerException       BacklogQuotaPolicy = "producer_exception"
	BacklogQuotaPolicyProducerRequestHold     BacklogQuotaPolicy = "producer_request_hold"
)

// Defines values for BacklogQuotaImplPolicy.
const (
	BacklogQuotaImplPolicyConsumerBacklogEviction BacklogQuotaImplPolicy = "consumer_backlog_eviction"
	BacklogQuotaImplPolicyProducerException       BacklogQuotaImplPolicy = "producer_exception"
	BacklogQuotaImplPolicyProducerRequestHold     BacklogQuotaImplPolicy = "producer_request_hold"
)

// Defines values for ClusterDataProxyProtocol.
const (
	SNI ClusterDataProxyProtocol = "SNI"
)

// Defines values for GetSchemaResponseType.
const (
	AUTO           GetSchemaResponseType = "AUTO"
	AUTOCONSUME    GetSchemaResponseType = "AUTO_CONSUME"
	AUTOPUBLISH    GetSchemaResponseType = "AUTO_PUBLISH"
	AVRO           GetSchemaResponseType = "AVRO"
	BOOLEAN        GetSchemaResponseType = "BOOLEAN"
	BYTES          GetSchemaResponseType = "BYTES"
	DATE           GetSchemaResponseType = "DATE"
	DOUBLE         GetSchemaResponseType = "DOUBLE"
	FLOAT          GetSchemaResponseType = "FLOAT"
	INSTANT        GetSchemaResponseType = "INSTANT"
	INT16          GetSchemaResponseType = "INT16"
	INT32          GetSchemaResponseType = "INT32"
	INT64          GetSchemaResponseType = "INT64"
	INT8           GetSchemaResponseType = "INT8"
	JSON           GetSchemaResponseType = "JSON"
	KEYVALUE       GetSchemaResponseType = "KEY_VALUE"
	LOCALDATE      GetSchemaResponseType = "LOCAL_DATE"
	LOCALDATETIME  GetSchemaResponseType = "LOCAL_DATE_TIME"
	LOCALTIME      GetSchemaResponseType = "LOCAL_TIME"
	NONE           GetSchemaResponseType = "NONE"
	PROTOBUF       GetSchemaResponseType = "PROTOBUF"
	PROTOBUFNATIVE GetSchemaResponseType = "PROTOBUF_NATIVE"
	STRING         GetSchemaResponseType = "STRING"
	TIME           GetSchemaResponseType = "TIME"
	TIMESTAMP      GetSchemaResponseType = "TIMESTAMP"
)

// Defines values for InactiveTopicPoliciesInactiveTopicDeleteMode.
const (
	DeleteWhenNoSubscriptions       InactiveTopicPoliciesInactiveTopicDeleteMode = "delete_when_no_subscriptions"
	DeleteWhenSubscriptionsCaughtUp InactiveTopicPoliciesInactiveTopicDeleteMode = "delete_when_subscriptions_caught_up"
)

// Defines values for LongRunningProcessStatusStatus.
const (
	ERROR   LongRunningProcessStatusStatus = "ERROR"
	NOTRUN  LongRunningProcessStatusStatus = "NOT_RUN"
	RUNNING LongRunningProcessStatusStatus = "RUNNING"
	SUCCESS LongRunningProcessStatusStatus = "SUCCESS"
)

// Defines values for NamespaceOwnershipStatusBrokerAssignment.
const (
	NamespaceOwnershipStatusBrokerAssignmentPrimary   NamespaceOwnershipStatusBrokerAssignment = "primary"
	NamespaceOwnershipStatusBrokerAssignmentSecondary NamespaceOwnershipStatusBrokerAssignment = "secondary"
	NamespaceOwnershipStatusBrokerAssignmentShared    NamespaceOwnershipStatusBrokerAssignment = "shared"
)

// Defines values for NonPersistentPublisherStatsAccessMode.
const (
	NonPersistentPublisherStatsAccessModeExclusive            NonPersistentPublisherStatsAccessMode = "Exclusive"
	NonPersistentPublisherStatsAccessModeExclusiveWithFencing NonPersistentPublisherStatsAccessMode = "ExclusiveWithFencing"
	NonPersistentPublisherStatsAccessModeShared               NonPersistentPublisherStatsAccessMode = "Shared"
	NonPersistentPublisherStatsAccessModeWaitForExclusive     NonPersistentPublisherStatsAccessMode = "WaitForExclusive"
)

// Defines values for OffloadPoliciesManagedLedgerOffloadedReadPriority.
const (
	OffloadPoliciesManagedLedgerOffloadedReadPriorityBOOKKEEPERFIRST    OffloadPoliciesManagedLedgerOffloadedReadPriority = "BOOKKEEPER_FIRST"
	OffloadPoliciesManagedLedgerOffloadedReadPriorityTIEREDSTORAGEFIRST OffloadPoliciesManagedLedgerOffloadedReadPriority = "TIERED_STORAGE_FIRST"
)

// Defines values for OffloadPoliciesImplManagedLedgerOffloadedReadPriority.
const (
	OffloadPoliciesImplManagedLedgerOffloadedReadPriorityBOOKKEEPERFIRST    OffloadPoliciesImplManagedLedgerOffloadedReadPriority = "BOOKKEEPER_FIRST"
	OffloadPoliciesImplManagedLedgerOffloadedReadPriorityTIEREDSTORAGEFIRST OffloadPoliciesImplManagedLedgerOffloadedReadPriority = "TIERED_STORAGE_FIRST"
)

// Defines values for PoliciesSchemaAutoUpdateCompatibilityStrategy.
const (
	AlwaysCompatible   PoliciesSchemaAutoUpdateCompatibilityStrategy = "AlwaysCompatible"
	AutoUpdateDisabled PoliciesSchemaAutoUpdateCompatibilityStrategy = "AutoUpdateDisabled"
	Backward           PoliciesSchemaAutoUpdateCompatibilityStrategy = "Backward"
	BackwardTransitive PoliciesSchemaAutoUpdateCompatibilityStrategy = "BackwardTransitive"
	Forward            PoliciesSchemaAutoUpdateCompatibilityStrategy = "Forward"
	ForwardTransitive  PoliciesSchemaAutoUpdateCompatibilityStrategy = "ForwardTransitive"
	Full               PoliciesSchemaAutoUpdateCompatibilityStrategy = "Full"
	FullTransitive     PoliciesSchemaAutoUpdateCompatibilityStrategy = "FullTransitive"
)

// Defines values for PoliciesSchemaCompatibilityStrategy.
const (
	ALWAYSCOMPATIBLE   PoliciesSchemaCompatibilityStrategy = "ALWAYS_COMPATIBLE"
	ALWAYSINCOMPATIBLE PoliciesSchemaCompatibilityStrategy = "ALWAYS_INCOMPATIBLE"
	BACKWARD           PoliciesSchemaCompatibilityStrategy = "BACKWARD"
	BACKWARDTRANSITIVE PoliciesSchemaCompatibilityStrategy = "BACKWARD_TRANSITIVE"
	FORWARD            PoliciesSchemaCompatibilityStrategy = "FORWARD"
	FORWARDTRANSITIVE  PoliciesSchemaCompatibilityStrategy = "FORWARD_TRANSITIVE"
	FULL               PoliciesSchemaCompatibilityStrategy = "FULL"
	FULLTRANSITIVE     PoliciesSchemaCompatibilityStrategy = "FULL_TRANSITIVE"
	UNDEFINED          PoliciesSchemaCompatibilityStrategy = "UNDEFINED"
)

// Defines values for PoliciesSubscriptionAuthMode.
const (
	None   PoliciesSubscriptionAuthMode = "None"
	Prefix PoliciesSubscriptionAuthMode = "Prefix"
)

// Defines values for PublisherStatsAccessMode.
const (
	Exclusive            PublisherStatsAccessMode = "Exclusive"
	ExclusiveWithFencing PublisherStatsAccessMode = "ExclusiveWithFencing"
	Shared               PublisherStatsAccessMode = "Shared"
	WaitForExclusive     PublisherStatsAccessMode = "WaitForExclusive"
)

// Defines values for BrokersBaseHealthCheckParamsTopicVersion.
const (
	V1 BrokersBaseHealthCheckParamsTopicVersion = "V1"
	V2 BrokersBaseHealthCheckParamsTopicVersion = "V2"
)

// Defines values for NamespacesRemoveBacklogQuotaParamsBacklogQuotaType.
const (
	NamespacesRemoveBacklogQuotaParamsBacklogQuotaTypeDestinationStorage NamespacesRemoveBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	NamespacesRemoveBacklogQuotaParamsBacklogQuotaTypeMessageAge         NamespacesRemoveBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for NamespacesSetBacklogQuotaParamsBacklogQuotaType.
const (
	NamespacesSetBacklogQuotaParamsBacklogQuotaTypeDestinationStorage NamespacesSetBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	NamespacesSetBacklogQuotaParamsBacklogQuotaTypeMessageAge         NamespacesSetBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for NamespacesGetTopicsParamsMode.
const (
	ALL           NamespacesGetTopicsParamsMode = "ALL"
	NONPERSISTENT NamespacesGetTopicsParamsMode = "NON_PERSISTENT"
	PERSISTENT    NamespacesGetTopicsParamsMode = "PERSISTENT"
)

// Defines values for NonPersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType.
const (
	NonPersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaTypeDestinationStorage NonPersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	NonPersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaTypeMessageAge         NonPersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for NonPersistentTopicsSetBacklogQuotaParamsBacklogQuotaType.
const (
	NonPersistentTopicsSetBacklogQuotaParamsBacklogQuotaTypeDestinationStorage NonPersistentTopicsSetBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	NonPersistentTopicsSetBacklogQuotaParamsBacklogQuotaTypeMessageAge         NonPersistentTopicsSetBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for NonPersistentTopicsExamineMessageParamsInitialPosition.
const (
	NonPersistentTopicsExamineMessageParamsInitialPositionEarliest NonPersistentTopicsExamineMessageParamsInitialPosition = "earliest"
	NonPersistentTopicsExamineMessageParamsInitialPositionLatest   NonPersistentTopicsExamineMessageParamsInitialPosition = "latest"
)

// Defines values for NonPersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType.
const (
	NonPersistentTopicsRemoveReplicationClustersParamsBacklogQuotaTypeDestinationStorage NonPersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType = "destination_storage"
	NonPersistentTopicsRemoveReplicationClustersParamsBacklogQuotaTypeMessageAge         NonPersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType = "message_age"
)

// Defines values for PersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType.
const (
	PersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaTypeDestinationStorage PersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	PersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaTypeMessageAge         PersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for PersistentTopicsSetBacklogQuotaParamsBacklogQuotaType.
const (
	PersistentTopicsSetBacklogQuotaParamsBacklogQuotaTypeDestinationStorage PersistentTopicsSetBacklogQuotaParamsBacklogQuotaType = "destination_storage"
	PersistentTopicsSetBacklogQuotaParamsBacklogQuotaTypeMessageAge         PersistentTopicsSetBacklogQuotaParamsBacklogQuotaType = "message_age"
)

// Defines values for PersistentTopicsExamineMessageParamsInitialPosition.
const (
	PersistentTopicsExamineMessageParamsInitialPositionEarliest PersistentTopicsExamineMessageParamsInitialPosition = "earliest"
	PersistentTopicsExamineMessageParamsInitialPositionLatest   PersistentTopicsExamineMessageParamsInitialPosition = "latest"
)

// Defines values for PersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType.
const (
	PersistentTopicsRemoveReplicationClustersParamsBacklogQuotaTypeDestinationStorage PersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType = "destination_storage"
	PersistentTopicsRemoveReplicationClustersParamsBacklogQuotaTypeMessageAge         PersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType = "message_age"
)

// AllocatorStats defines model for AllocatorStats.
type AllocatorStats struct {
	DirectArenas         *[]PoolArenaStats `json:"directArenas,omitempty"`
	HeapArenas           *[]PoolArenaStats `json:"heapArenas,omitempty"`
	NormalCacheSize      *int32            `json:"normalCacheSize,omitempty"`
	NumDirectArenas      *int32            `json:"numDirectArenas,omitempty"`
	NumHeapArenas        *int32            `json:"numHeapArenas,omitempty"`
	NumThreadLocalCaches *int32            `json:"numThreadLocalCaches,omitempty"`
	SmallCacheSize       *int32            `json:"smallCacheSize,omitempty"`
}

// AuthPolicies defines model for AuthPolicies.
type AuthPolicies struct {
	NamespaceAuthentication    *map[string][]AuthPoliciesNamespaceAuthentication        `json:"namespaceAuthentication,omitempty"`
	SubscriptionAuthentication *map[string][]string                                     `json:"subscriptionAuthentication,omitempty"`
	TopicAuthentication        *map[string]map[string][]AuthPoliciesTopicAuthentication `json:"topicAuthentication,omitempty"`
}

// AuthPoliciesNamespaceAuthentication defines model for AuthPolicies.NamespaceAuthentication.
type AuthPoliciesNamespaceAuthentication string

// AuthPoliciesTopicAuthentication defines model for AuthPolicies.TopicAuthentication.
type AuthPoliciesTopicAuthentication string

// AuthenticationDataSource defines model for AuthenticationDataSource.
type AuthenticationDataSource struct {
	CommandData     *string        `json:"commandData,omitempty"`
	HttpAuthType    *string        `json:"httpAuthType,omitempty"`
	PeerAddress     *SocketAddress `json:"peerAddress,omitempty"`
	Subscription    *string        `json:"subscription,omitempty"`
	TlsCertificates *[]Certificate `json:"tlsCertificates,omitempty"`
}

// AuthenticationParameters defines model for AuthenticationParameters.
type AuthenticationParameters struct {
	ClientAuthenticationDataSource *AuthenticationDataSource `json:"clientAuthenticationDataSource,omitempty"`
	ClientRole                     *string                   `json:"clientRole,omitempty"`
	OriginalPrincipal              *string                   `json:"originalPrincipal,omitempty"`
}

// AutoFailoverPolicyData defines model for AutoFailoverPolicyData.
type AutoFailoverPolicyData struct {
	Parameters *map[string]string                `json:"parameters,omitempty"`
	PolicyType *AutoFailoverPolicyDataPolicyType `json:"policyType,omitempty"`
}

// AutoFailoverPolicyDataPolicyType defines model for AutoFailoverPolicyData.PolicyType.
type AutoFailoverPolicyDataPolicyType string

// AutoSubscriptionCreationOverride defines model for AutoSubscriptionCreationOverride.
type AutoSubscriptionCreationOverride struct {
	AllowAutoSubscriptionCreation *bool `json:"allowAutoSubscriptionCreation,omitempty"`
}

// AutoSubscriptionCreationOverrideImpl defines model for AutoSubscriptionCreationOverrideImpl.
type AutoSubscriptionCreationOverrideImpl struct {
	AllowAutoSubscriptionCreation *bool `json:"allowAutoSubscriptionCreation,omitempty"`
}

// AutoTopicCreationOverride defines model for AutoTopicCreationOverride.
type AutoTopicCreationOverride struct {
	AllowAutoTopicCreation *bool   `json:"allowAutoTopicCreation,omitempty"`
	DefaultNumPartitions   *int32  `json:"defaultNumPartitions,omitempty"`
	TopicType              *string `json:"topicType,omitempty"`
}

// BacklogQuota defines model for BacklogQuota.
type BacklogQuota struct {
	Limit     *int64              `json:"limit,omitempty"`
	LimitSize *int64              `json:"limitSize,omitempty"`
	LimitTime *int32              `json:"limitTime,omitempty"`
	Policy    *BacklogQuotaPolicy `json:"policy,omitempty"`
}

// BacklogQuotaPolicy defines model for BacklogQuota.Policy.
type BacklogQuotaPolicy string

// BacklogQuotaImpl defines model for BacklogQuotaImpl.
type BacklogQuotaImpl struct {
	Limit     *int64                  `json:"limit,omitempty"`
	LimitSize *int64                  `json:"limitSize,omitempty"`
	LimitTime *int32                  `json:"limitTime,omitempty"`
	Policy    *BacklogQuotaImplPolicy `json:"policy,omitempty"`
}

// BacklogQuotaImplPolicy defines model for BacklogQuotaImpl.Policy.
type BacklogQuotaImplPolicy string

// BookieAffinityGroupData defines model for BookieAffinityGroupData.
type BookieAffinityGroupData struct {
	BookkeeperAffinityGroupPrimary   *string `json:"bookkeeperAffinityGroupPrimary,omitempty"`
	BookkeeperAffinityGroupSecondary *string `json:"bookkeeperAffinityGroupSecondary,omitempty"`
}

// BookieInfo defines model for BookieInfo.
type BookieInfo struct {
	Hostname *string `json:"hostname,omitempty"`
	Rack     *string `json:"rack,omitempty"`
}

// BookiesClusterInfo defines model for BookiesClusterInfo.
type BookiesClusterInfo struct {
	Bookies *[]RawBookieInfo `json:"bookies,omitempty"`
}

// BrokerInfo defines model for BrokerInfo.
type BrokerInfo struct {
	ServiceUrl *string `json:"serviceUrl,omitempty"`
}

// BrokerNamespaceIsolationData The namespace isolation data for a given broker
type BrokerNamespaceIsolationData struct {
	// BrokerName The broker name
	BrokerName *string `json:"brokerName,omitempty"`

	// NamespaceRegex The namespace-isolation policies attached to this broker
	NamespaceRegex *[]string `json:"namespaceRegex,omitempty"`

	// PolicyName Policy name
	PolicyName *string `json:"policyName,omitempty"`
	Primary    *bool   `json:"primary,omitempty"`
}

// BundlesData defines model for BundlesData.
type BundlesData struct {
	Boundaries *[]string `json:"boundaries,omitempty"`
	NumBundles *int32    `json:"numBundles,omitempty"`
}

// Certificate defines model for Certificate.
type Certificate struct {
	Encoded   *[][]byte  `json:"encoded,omitempty"`
	PublicKey *PublicKey `json:"publicKey,omitempty"`
	Type      *string    `json:"type,omitempty"`
}

// ClusterData The configuration data for a cluster
type ClusterData struct {
	// AuthenticationParameters Authentication parameters when client would like to connect to cluster.
	AuthenticationParameters *string `json:"authenticationParameters,omitempty"`

	// AuthenticationPlugin Authentication plugin when client would like to connect to cluster.
	AuthenticationPlugin *string `json:"authenticationPlugin,omitempty"`

	// BrokerClientCertificateFilePath TLS certificate file for internal client, used by the internal client to authenticate with Pulsar brokers
	BrokerClientCertificateFilePath *string `json:"brokerClientCertificateFilePath,omitempty"`

	// BrokerClientKeyFilePath TLS private key file for internal client, used by the internal client to authenticate with Pulsar brokers
	BrokerClientKeyFilePath *string `json:"brokerClientKeyFilePath,omitempty"`

	// BrokerClientTlsEnabled Enable TLS when talking with other brokers in the same cluster (admin operation) or different clusters (replication)
	BrokerClientTlsEnabled *bool `json:"brokerClientTlsEnabled,omitempty"`

	// BrokerClientTlsEnabledWithKeyStore Whether internal client use KeyStore type to authenticate with other Pulsar brokers
	BrokerClientTlsEnabledWithKeyStore *bool `json:"brokerClientTlsEnabledWithKeyStore,omitempty"`

	// BrokerClientTlsKeyStore TLS KeyStore path for internal client,  used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsKeyStore *string `json:"brokerClientTlsKeyStore,omitempty"`

	// BrokerClientTlsKeyStorePassword TLS KeyStore password for internal client,  used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsKeyStorePassword *string `json:"brokerClientTlsKeyStorePassword,omitempty"`

	// BrokerClientTlsKeyStoreType TLS KeyStore type configuration for internal client: JKS, PKCS12, used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsKeyStoreType *string `json:"brokerClientTlsKeyStoreType,omitempty"`

	// BrokerClientTlsTrustStore TLS TrustStore path for internal client used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStore *string `json:"brokerClientTlsTrustStore,omitempty"`

	// BrokerClientTlsTrustStorePassword TLS TrustStore password for internal client used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStorePassword *string `json:"brokerClientTlsTrustStorePassword,omitempty"`

	// BrokerClientTlsTrustStoreType TLS TrustStore type configuration for internal client: JKS, PKCS12 used by the internal client to authenticate with Pulsar brokers
	BrokerClientTlsTrustStoreType *string `json:"brokerClientTlsTrustStoreType,omitempty"`

	// BrokerClientTrustCertsFilePath Path for the trusted TLS certificate file for outgoing connection to a server (broker)
	BrokerClientTrustCertsFilePath *string `json:"brokerClientTrustCertsFilePath,omitempty"`

	// BrokerServiceUrl The broker service url (for produce and consume operations)
	BrokerServiceUrl *string `json:"brokerServiceUrl,omitempty"`

	// BrokerServiceUrlTls The secured broker service url (for produce and consume operations)
	BrokerServiceUrlTls *string `json:"brokerServiceUrlTls,omitempty"`

	// ListenerName listenerName when client would like to connect to cluster
	ListenerName *string `json:"listenerName,omitempty"`

	// Migrated flag to check if cluster is migrated to different cluster
	Migrated           *bool       `json:"migrated,omitempty"`
	MigratedClusterUrl *ClusterUrl `json:"migratedClusterUrl,omitempty"`

	// PeerClusterNames A set of peer cluster names
	PeerClusterNames *[]string `json:"peerClusterNames,omitempty"`

	// ProxyProtocol protocol to decide type of proxy routing eg: SNI-routing
	ProxyProtocol *ClusterDataProxyProtocol `json:"proxyProtocol,omitempty"`

	// ProxyServiceUrl Proxy-service url when client would like to connect to broker via proxy.
	ProxyServiceUrl *string `json:"proxyServiceUrl,omitempty"`

	// ServiceUrl The HTTP rest service URL (for admin operations)
	ServiceUrl *string `json:"serviceUrl,omitempty"`

	// ServiceUrlTls The HTTPS rest service URL (for admin operations)
	ServiceUrlTls *string `json:"serviceUrlTls,omitempty"`

	// TlsAllowInsecureConnection Allow TLS connections to servers whose certificate cannot be be verified to have been signed by a trusted certificate authority.
	TlsAllowInsecureConnection *bool `json:"tlsAllowInsecureConnection,omitempty"`
}

// ClusterDataProxyProtocol protocol to decide type of proxy routing eg: SNI-routing
type ClusterDataProxyProtocol string

// ClusterUrl defines model for ClusterUrl.
type ClusterUrl struct {
	BrokerServiceUrl    *string `json:"brokerServiceUrl,omitempty"`
	BrokerServiceUrlTls *string `json:"brokerServiceUrlTls,omitempty"`
	Empty               *bool   `json:"empty,omitempty"`
}

// CompactionStats defines model for CompactionStats.
type CompactionStats struct {
	LastCompactionDurationTimeInMills *int64 `json:"lastCompactionDurationTimeInMills,omitempty"`
	LastCompactionFailedTimestamp     *int64 `json:"lastCompactionFailedTimestamp,omitempty"`
	LastCompactionRemovedEventCount   *int64 `json:"lastCompactionRemovedEventCount,omitempty"`
	LastCompactionSucceedTimestamp    *int64 `json:"lastCompactionSucceedTimestamp,omitempty"`
}

// CompactionStatsImpl defines model for CompactionStatsImpl.
type CompactionStatsImpl struct {
	LastCompactionDurationTimeInMills *int64 `json:"lastCompactionDurationTimeInMills,omitempty"`
	LastCompactionFailedTimestamp     *int64 `json:"lastCompactionFailedTimestamp,omitempty"`
	LastCompactionRemovedEventCount   *int64 `json:"lastCompactionRemovedEventCount,omitempty"`
	LastCompactionSucceedTimestamp    *int64 `json:"lastCompactionSucceedTimestamp,omitempty"`
}

// CompletableFuture defines model for CompletableFuture.
type CompletableFuture struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFutureClusterData defines model for CompletableFutureClusterData.
type CompletableFutureClusterData struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFutureListSchemaAndMetadata defines model for CompletableFutureListSchemaAndMetadata.
type CompletableFutureListSchemaAndMetadata struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFutureLong defines model for CompletableFutureLong.
type CompletableFutureLong struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFuturePairBooleanSchemaCompatibilityStrategy defines model for CompletableFuturePairBooleanSchemaCompatibilityStrategy.
type CompletableFuturePairBooleanSchemaCompatibilityStrategy struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFuturePartitionedTopicMetadata defines model for CompletableFuturePartitionedTopicMetadata.
type CompletableFuturePartitionedTopicMetadata struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFutureResourceQuota defines model for CompletableFutureResourceQuota.
type CompletableFutureResourceQuota struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFutureSchemaAndMetadata defines model for CompletableFutureSchemaAndMetadata.
type CompletableFutureSchemaAndMetadata struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFutureSchemaVersion defines model for CompletableFutureSchemaVersion.
type CompletableFutureSchemaVersion struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// CompletableFutureVoid defines model for CompletableFutureVoid.
type CompletableFutureVoid struct {
	Cancelled              *bool  `json:"cancelled,omitempty"`
	CompletedExceptionally *bool  `json:"completedExceptionally,omitempty"`
	Done                   *bool  `json:"done,omitempty"`
	NumberOfDependents     *int32 `json:"numberOfDependents,omitempty"`
}

// ConnectorDefinition defines model for ConnectorDefinition.
type ConnectorDefinition struct {
	Description       *string `json:"description,omitempty"`
	Name              *string `json:"name,omitempty"`
	SinkClass         *string `json:"sinkClass,omitempty"`
	SinkConfigClass   *string `json:"sinkConfigClass,omitempty"`
	SourceClass       *string `json:"sourceClass,omitempty"`
	SourceConfigClass *string `json:"sourceConfigClass,omitempty"`
}

// ConsumerStats defines model for ConsumerStats.
type ConsumerStats struct {
	Address                      *string            `json:"address,omitempty"`
	AvailablePermits             *int32             `json:"availablePermits,omitempty"`
	AvgMessagesPerEntry          *int32             `json:"avgMessagesPerEntry,omitempty"`
	BlockedConsumerOnUnackedMsgs *bool              `json:"blockedConsumerOnUnackedMsgs,omitempty"`
	BytesOutCounter              *int64             `json:"bytesOutCounter,omitempty"`
	ChunkedMessageRate           *float64           `json:"chunkedMessageRate,omitempty"`
	ClientVersion                *string            `json:"clientVersion,omitempty"`
	ConnectedSince               *string            `json:"connectedSince,omitempty"`
	ConsumerName                 *string            `json:"consumerName,omitempty"`
	KeyHashRanges                *[]string          `json:"keyHashRanges,omitempty"`
	LastAckedTimestamp           *int64             `json:"lastAckedTimestamp,omitempty"`
	LastConsumedFlowTimestamp    *int64             `json:"lastConsumedFlowTimestamp,omitempty"`
	LastConsumedTimestamp        *int64             `json:"lastConsumedTimestamp,omitempty"`
	MessageAckRate               *float64           `json:"messageAckRate,omitempty"`
	Metadata                     *map[string]string `json:"metadata,omitempty"`
	MsgOutCounter                *int64             `json:"msgOutCounter,omitempty"`
	MsgRateOut                   *float64           `json:"msgRateOut,omitempty"`
	MsgRateRedeliver             *float64           `json:"msgRateRedeliver,omitempty"`
	MsgThroughputOut             *float64           `json:"msgThroughputOut,omitempty"`
	ReadPositionWhenJoining      *string            `json:"readPositionWhenJoining,omitempty"`
	UnackedMessages              *int32             `json:"unackedMessages,omitempty"`
}

// CursorDetails defines model for CursorDetails.
type CursorDetails struct {
	CursorBacklog  *int64 `json:"cursorBacklog,omitempty"`
	CursorLedgerId *int64 `json:"cursorLedgerId,omitempty"`
}

// CursorInfo defines model for CursorInfo.
type CursorInfo struct {
	CreationDate              *string             `json:"creationDate,omitempty"`
	CursorsLedgerId           *int64              `json:"cursorsLedgerId,omitempty"`
	IndividualDeletedMessages *[]MessageRangeInfo `json:"individualDeletedMessages,omitempty"`
	MarkDelete                *PositionInfo       `json:"markDelete,omitempty"`
	ModificationDate          *string             `json:"modificationDate,omitempty"`
	Properties                *map[string]int64   `json:"properties,omitempty"`
	Version                   *int64              `json:"version,omitempty"`
}

// CursorStats defines model for CursorStats.
type CursorStats struct {
	Active                                   *bool             `json:"active,omitempty"`
	CursorLedger                             *int64            `json:"cursorLedger,omitempty"`
	CursorLedgerLastEntry                    *int64            `json:"cursorLedgerLastEntry,omitempty"`
	IndividuallyDeletedMessages              *string           `json:"individuallyDeletedMessages,omitempty"`
	LastLedgerSwitchTimestamp                *string           `json:"lastLedgerSwitchTimestamp,omitempty"`
	MarkDeletePosition                       *string           `json:"markDeletePosition,omitempty"`
	MessagesConsumedCounter                  *int64            `json:"messagesConsumedCounter,omitempty"`
	NumberOfEntriesSinceFirstNotAckedMessage *int64            `json:"numberOfEntriesSinceFirstNotAckedMessage,omitempty"`
	PendingReadOps                           *int32            `json:"pendingReadOps,omitempty"`
	Properties                               *map[string]int64 `json:"properties,omitempty"`
	ReadPosition                             *string           `json:"readPosition,omitempty"`
	State                                    *string           `json:"state,omitempty"`
	SubscriptionHavePendingRead              *bool             `json:"subscriptionHavePendingRead,omitempty"`
	SubscriptionHavePendingReplayRead        *bool             `json:"subscriptionHavePendingReplayRead,omitempty"`
	TotalNonContiguousDeletedMessagesRange   *int32            `json:"totalNonContiguousDeletedMessagesRange,omitempty"`
	WaitingReadOp                            *bool             `json:"waitingReadOp,omitempty"`
}

// DelayedDeliveryPolicies defines model for DelayedDeliveryPolicies.
type DelayedDeliveryPolicies struct {
	Active   *bool  `json:"active,omitempty"`
	TickTime *int64 `json:"tickTime,omitempty"`
}

// DeleteSchemaResponse defines model for DeleteSchemaResponse.
type DeleteSchemaResponse struct {
	Version *int64 `json:"version,omitempty"`
}

// DispatchRate defines model for DispatchRate.
type DispatchRate struct {
	DispatchThrottlingRateInByte *int64 `json:"dispatchThrottlingRateInByte,omitempty"`
	DispatchThrottlingRateInMsg  *int32 `json:"dispatchThrottlingRateInMsg,omitempty"`
	RatePeriodInSecond           *int32 `json:"ratePeriodInSecond,omitempty"`
	RelativeToPublishRate        *bool  `json:"relativeToPublishRate,omitempty"`
}

// DispatchRateImpl defines model for DispatchRateImpl.
type DispatchRateImpl struct {
	DispatchThrottlingRateInByte *int64 `json:"dispatchThrottlingRateInByte,omitempty"`
	DispatchThrottlingRateInMsg  *int32 `json:"dispatchThrottlingRateInMsg,omitempty"`
	RatePeriodInSecond           *int32 `json:"ratePeriodInSecond,omitempty"`
	RelativeToPublishRate        *bool  `json:"relativeToPublishRate,omitempty"`
}

// EntryFilters defines model for EntryFilters.
type EntryFilters struct {
	EntryFilterNames *string `json:"entryFilterNames,omitempty"`
}

// FailureDomain The data of a failure domain configuration in a cluster
type FailureDomain struct {
	// Brokers The collection of brokers in the same failure domain
	Brokers *[]string `json:"brokers,omitempty"`
}

// FunctionInstanceStatsData defines model for FunctionInstanceStatsData.
type FunctionInstanceStatsData struct {
	AvgProcessLatency          *float64                       `json:"avgProcessLatency,omitempty"`
	LastInvocation             *int64                         `json:"lastInvocation,omitempty"`
	OneMin                     *FunctionInstanceStatsDataBase `json:"oneMin,omitempty"`
	ProcessedSuccessfullyTotal *int64                         `json:"processedSuccessfullyTotal,omitempty"`
	ReceivedTotal              *int64                         `json:"receivedTotal,omitempty"`
	SystemExceptionsTotal      *int64                         `json:"systemExceptionsTotal,omitempty"`
	UserExceptionsTotal        *int64                         `json:"userExceptionsTotal,omitempty"`
	UserMetrics                *map[string]float64            `json:"userMetrics,omitempty"`
}

// FunctionInstanceStatsDataBase defines model for FunctionInstanceStatsDataBase.
type FunctionInstanceStatsDataBase struct {
	AvgProcessLatency          *float64 `json:"avgProcessLatency,omitempty"`
	ProcessedSuccessfullyTotal *int64   `json:"processedSuccessfullyTotal,omitempty"`
	ReceivedTotal              *int64   `json:"receivedTotal,omitempty"`
	SystemExceptionsTotal      *int64   `json:"systemExceptionsTotal,omitempty"`
	UserExceptionsTotal        *int64   `json:"userExceptionsTotal,omitempty"`
}

// Functions defines model for Functions.
type Functions struct {
	ListOfConnectors *[]ConnectorDefinition `json:"listOfConnectors,omitempty"`
}

// FunctionsV2 defines model for FunctionsV2.
type FunctionsV2 struct {
	ListOfConnectors *[]ConnectorDefinition `json:"listOfConnectors,omitempty"`
}

// FunctionsV2WorkerService defines model for FunctionsV2WorkerService.
type FunctionsV2WorkerService struct {
	ListOfConnectors *[]ConnectorDefinition `json:"listOfConnectors,omitempty"`
}

// FunctionsWorkerService defines model for FunctionsWorkerService.
type FunctionsWorkerService struct {
	ListOfConnectors *[]ConnectorDefinition `json:"listOfConnectors,omitempty"`
}

// GetAllVersionsSchemaResponse defines model for GetAllVersionsSchemaResponse.
type GetAllVersionsSchemaResponse struct {
	GetSchemaResponses *[]GetSchemaResponse `json:"getSchemaResponses,omitempty"`
}

// GetSchemaResponse defines model for GetSchemaResponse.
type GetSchemaResponse struct {
	Data       *string                `json:"data,omitempty"`
	Properties *map[string]string     `json:"properties,omitempty"`
	Timestamp  *int64                 `json:"timestamp,omitempty"`
	Type       *GetSchemaResponseType `json:"type,omitempty"`
	Version    *int64                 `json:"version,omitempty"`
}

// GetSchemaResponseType defines model for GetSchemaResponse.Type.
type GetSchemaResponseType string

// InactiveTopicPolicies defines model for InactiveTopicPolicies.
type InactiveTopicPolicies struct {
	DeleteWhileInactive        *bool                                         `json:"deleteWhileInactive,omitempty"`
	InactiveTopicDeleteMode    *InactiveTopicPoliciesInactiveTopicDeleteMode `json:"inactiveTopicDeleteMode,omitempty"`
	MaxInactiveDurationSeconds *int32                                        `json:"maxInactiveDurationSeconds,omitempty"`
}

// InactiveTopicPoliciesInactiveTopicDeleteMode defines model for InactiveTopicPolicies.InactiveTopicDeleteMode.
type InactiveTopicPoliciesInactiveTopicDeleteMode string

// InternalConfigurationData defines model for InternalConfigurationData.
type InternalConfigurationData struct {
	BookkeeperMetadataServiceUri  *string `json:"bookkeeperMetadataServiceUri,omitempty"`
	ConfigurationMetadataStoreUrl *string `json:"configurationMetadataStoreUrl,omitempty"`
	ConfigurationStoreServers     *string `json:"configurationStoreServers,omitempty"`
	LedgersRootPath               *string `json:"ledgersRootPath,omitempty"`
	MetadataStoreUrl              *string `json:"metadataStoreUrl,omitempty"`
	StateStorageServiceUrl        *string `json:"stateStorageServiceUrl,omitempty"`
	ZookeeperServers              *string `json:"zookeeperServers,omitempty"`
}

// IsCompatibilityResponse defines model for IsCompatibilityResponse.
type IsCompatibilityResponse struct {
	Compatibility               *bool   `json:"compatibility,omitempty"`
	SchemaCompatibilityStrategy *string `json:"schemaCompatibilityStrategy,omitempty"`
}

// KubernetesContainerFactory defines model for KubernetesContainerFactory.
type KubernetesContainerFactory struct {
	ChangeConfigMap                      *string                            `json:"changeConfigMap,omitempty"`
	ChangeConfigMapNamespace             *string                            `json:"changeConfigMapNamespace,omitempty"`
	ConfigAdminCLI                       *string                            `json:"configAdminCLI,omitempty"`
	CpuOverCommitRatio                   *float64                           `json:"cpuOverCommitRatio,omitempty"`
	CustomLabels                         *map[string]string                 `json:"customLabels,omitempty"`
	ExpectedMetricsCollectionInterval    *int32                             `json:"expectedMetricsCollectionInterval,omitempty"`
	ExtraFunctionDependenciesDir         *string                            `json:"extraFunctionDependenciesDir,omitempty"`
	FunctionDockerImages                 *map[string]string                 `json:"functionDockerImages,omitempty"`
	FunctionInstanceClassPath            *string                            `json:"functionInstanceClassPath,omitempty"`
	GracePeriodSeconds                   *int32                             `json:"gracePeriodSeconds,omitempty"`
	GrpcPort                             *int32                             `json:"grpcPort,omitempty"`
	ImagePullPolicy                      *string                            `json:"imagePullPolicy,omitempty"`
	InstallUserCodeDependencies          *bool                              `json:"installUserCodeDependencies,omitempty"`
	JobName                              *string                            `json:"jobName,omitempty"`
	JobNamespace                         *string                            `json:"jobNamespace,omitempty"`
	K8Uri                                *string                            `json:"k8Uri,omitempty"`
	KubernetesFunctionAuthProviderConfig *map[string]map[string]interface{} `json:"kubernetesFunctionAuthProviderConfig,omitempty"`
	MemoryOverCommitRatio                *float64                           `json:"memoryOverCommitRatio,omitempty"`
	MetricsPort                          *int32                             `json:"metricsPort,omitempty"`
	NarExtractionDirectory               *string                            `json:"narExtractionDirectory,omitempty"`
	PercentMemoryPadding                 *int32                             `json:"percentMemoryPadding,omitempty"`
	PulsarAdminUrl                       *string                            `json:"pulsarAdminUrl,omitempty"`
	PulsarDockerImageName                *string                            `json:"pulsarDockerImageName,omitempty"`
	PulsarRootDir                        *string                            `json:"pulsarRootDir,omitempty"`
	PulsarServiceUrl                     *string                            `json:"pulsarServiceUrl,omitempty"`
	PythonDependencyRepository           *string                            `json:"pythonDependencyRepository,omitempty"`
	PythonExtraDependencyRepository      *string                            `json:"pythonExtraDependencyRepository,omitempty"`
	SubmittingInsidePod                  *bool                              `json:"submittingInsidePod,omitempty"`
}

// LedgerDetails defines model for LedgerDetails.
type LedgerDetails struct {
	Entries   *int64 `json:"entries,omitempty"`
	LedgerId  *int64 `json:"ledgerId,omitempty"`
	Size      *int64 `json:"size,omitempty"`
	Timestamp *int64 `json:"timestamp,omitempty"`
}

// LedgerInfo defines model for LedgerInfo.
type LedgerInfo struct {
	Entries         *int64  `json:"entries,omitempty"`
	LedgerId        *int64  `json:"ledgerId,omitempty"`
	Metadata        *string `json:"metadata,omitempty"`
	Offloaded       *bool   `json:"offloaded,omitempty"`
	Size            *int64  `json:"size,omitempty"`
	UnderReplicated *bool   `json:"underReplicated,omitempty"`
}

// LoadReport defines model for LoadReport.
type LoadReport struct {
	AllocatedBandwidthIn       *float64                         `json:"allocatedBandwidthIn,omitempty"`
	AllocatedBandwidthOut      *float64                         `json:"allocatedBandwidthOut,omitempty"`
	AllocatedCPU               *float64                         `json:"allocatedCPU,omitempty"`
	AllocatedMemory            *float64                         `json:"allocatedMemory,omitempty"`
	AllocatedMsgRateIn         *float64                         `json:"allocatedMsgRateIn,omitempty"`
	AllocatedMsgRateOut        *float64                         `json:"allocatedMsgRateOut,omitempty"`
	BandwidthIn                *ResourceUsage                   `json:"bandwidthIn,omitempty"`
	BandwidthOut               *ResourceUsage                   `json:"bandwidthOut,omitempty"`
	BrokerVersionString        *string                          `json:"brokerVersionString,omitempty"`
	BundleGains                *[]string                        `json:"bundleGains,omitempty"`
	BundleLosses               *[]string                        `json:"bundleLosses,omitempty"`
	BundleStats                *map[string]NamespaceBundleStats `json:"bundleStats,omitempty"`
	Cpu                        *ResourceUsage                   `json:"cpu,omitempty"`
	DirectMemory               *ResourceUsage                   `json:"directMemory,omitempty"`
	LastUpdate                 *int64                           `json:"lastUpdate,omitempty"`
	LoadManagerClassName       *string                          `json:"loadManagerClassName,omitempty"`
	LoadReportType             *string                          `json:"loadReportType,omitempty"`
	Memory                     *ResourceUsage                   `json:"memory,omitempty"`
	MsgRateIn                  *float64                         `json:"msgRateIn,omitempty"`
	MsgRateOut                 *float64                         `json:"msgRateOut,omitempty"`
	MsgThroughputIn            *float64                         `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut           *float64                         `json:"msgThroughputOut,omitempty"`
	Name                       *string                          `json:"name,omitempty"`
	NonPersistentTopicsEnabled *bool                            `json:"nonPersistentTopicsEnabled,omitempty"`
	NumBundles                 *int32                           `json:"numBundles,omitempty"`
	NumConsumers               *int32                           `json:"numConsumers,omitempty"`
	NumProducers               *int32                           `json:"numProducers,omitempty"`
	NumTopics                  *int32                           `json:"numTopics,omitempty"`
	OverLoaded                 *bool                            `json:"overLoaded,omitempty"`
	PersistentTopicsEnabled    *bool                            `json:"persistentTopicsEnabled,omitempty"`
	PreAllocatedBandwidthIn    *float64                         `json:"preAllocatedBandwidthIn,omitempty"`
	PreAllocatedBandwidthOut   *float64                         `json:"preAllocatedBandwidthOut,omitempty"`
	PreAllocatedCPU            *float64                         `json:"preAllocatedCPU,omitempty"`
	PreAllocatedMemory         *float64                         `json:"preAllocatedMemory,omitempty"`
	PreAllocatedMsgRateIn      *float64                         `json:"preAllocatedMsgRateIn,omitempty"`
	PreAllocatedMsgRateOut     *float64                         `json:"preAllocatedMsgRateOut,omitempty"`
	Protocols                  *map[string]string               `json:"protocols,omitempty"`
	PulsarServiceUrl           *string                          `json:"pulsarServiceUrl,omitempty"`
	PulsarServiceUrlTls        *string                          `json:"pulsarServiceUrlTls,omitempty"`
	StartTimestamp             *int64                           `json:"startTimestamp,omitempty"`
	SystemResourceUsage        *SystemResourceUsage             `json:"systemResourceUsage,omitempty"`
	Timestamp                  *int64                           `json:"timestamp,omitempty"`
	UnderLoaded                *bool                            `json:"underLoaded,omitempty"`
	WebServiceUrl              *string                          `json:"webServiceUrl,omitempty"`
	WebServiceUrlTls           *string                          `json:"webServiceUrlTls,omitempty"`
}

// LongRunningProcessStatus defines model for LongRunningProcessStatus.
type LongRunningProcessStatus struct {
	LastError *string                         `json:"lastError,omitempty"`
	Status    *LongRunningProcessStatusStatus `json:"status,omitempty"`
}

// LongRunningProcessStatusStatus defines model for LongRunningProcessStatus.Status.
type LongRunningProcessStatusStatus string

// LongSchemaVersion defines model for LongSchemaVersion.
type LongSchemaVersion struct {
	Version *int64 `json:"version,omitempty"`
}

// ManagedLedgerInfo defines model for ManagedLedgerInfo.
type ManagedLedgerInfo struct {
	CreationDate       *string                `json:"creationDate,omitempty"`
	Cursors            *map[string]CursorInfo `json:"cursors,omitempty"`
	Ledgers            *[]LedgerInfo          `json:"ledgers,omitempty"`
	ModificationDate   *string                `json:"modificationDate,omitempty"`
	Properties         *map[string]string     `json:"properties,omitempty"`
	TerminatedPosition *PositionInfo          `json:"terminatedPosition,omitempty"`
	Version            *int64                 `json:"version,omitempty"`
}

// MemoryLimit defines model for MemoryLimit.
type MemoryLimit struct {
	AbsoluteValue            *int64   `json:"absoluteValue,omitempty"`
	PercentOfMaxDirectMemory *float64 `json:"percentOfMaxDirectMemory,omitempty"`
}

// MessageRangeInfo defines model for MessageRangeInfo.
type MessageRangeInfo struct {
	From *PositionInfo `json:"from,omitempty"`
	To   *PositionInfo `json:"to,omitempty"`
}

// Metrics defines model for Metrics.
type Metrics struct {
	Dimensions *map[string]string                 `json:"dimensions,omitempty"`
	Metrics    *map[string]map[string]interface{} `json:"metrics,omitempty"`
}

// NamespaceBundleStats defines model for NamespaceBundleStats.
type NamespaceBundleStats struct {
	CacheSize        *int64   `json:"cacheSize,omitempty"`
	ConsumerCount    *int32   `json:"consumerCount,omitempty"`
	MsgRateIn        *float64 `json:"msgRateIn,omitempty"`
	MsgRateOut       *float64 `json:"msgRateOut,omitempty"`
	MsgThroughputIn  *float64 `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut *float64 `json:"msgThroughputOut,omitempty"`
	ProducerCount    *int32   `json:"producerCount,omitempty"`
	Topics           *int64   `json:"topics,omitempty"`
}

// NamespaceIsolationData The data of namespace isolation configuration
type NamespaceIsolationData struct {
	AutoFailoverPolicy *AutoFailoverPolicyData `json:"auto_failover_policy,omitempty"`

	// Namespaces The list of namespaces to apply this namespace isolation data
	Namespaces *[]string `json:"namespaces,omitempty"`

	// Primary The list of primary brokers for serving the list of namespaces in this isolation policy
	Primary *[]string `json:"primary,omitempty"`

	// Secondary The list of secondary brokers for serving the list of namespaces in this isolation policy
	Secondary *[]string `json:"secondary,omitempty"`
}

// NamespaceOwnershipStatus defines model for NamespaceOwnershipStatus.
type NamespaceOwnershipStatus struct {
	BrokerAssignment *NamespaceOwnershipStatusBrokerAssignment `json:"broker_assignment,omitempty"`
	IsActive         *bool                                     `json:"is_active,omitempty"`
	IsControlled     *bool                                     `json:"is_controlled,omitempty"`
}

// NamespaceOwnershipStatusBrokerAssignment defines model for NamespaceOwnershipStatus.BrokerAssignment.
type NamespaceOwnershipStatusBrokerAssignment string

// NonPersistentPartitionedTopicStatsImpl defines model for NonPersistentPartitionedTopicStatsImpl.
type NonPersistentPartitionedTopicStatsImpl struct {
	AbortedTxnCount                                  *int64                                     `json:"abortedTxnCount,omitempty"`
	AverageMsgSize                                   *float64                                   `json:"averageMsgSize,omitempty"`
	BacklogSize                                      *int64                                     `json:"backlogSize,omitempty"`
	BytesInCounter                                   *int64                                     `json:"bytesInCounter,omitempty"`
	BytesOutCounter                                  *int64                                     `json:"bytesOutCounter,omitempty"`
	CommittedTxnCount                                *int64                                     `json:"committedTxnCount,omitempty"`
	Compaction                                       *CompactionStatsImpl                       `json:"compaction,omitempty"`
	DeduplicationStatus                              *string                                    `json:"deduplicationStatus,omitempty"`
	DelayedMessageIndexSizeInBytes                   *int64                                     `json:"delayedMessageIndexSizeInBytes,omitempty"`
	EarliestMsgPublishTimeInBacklogs                 *int64                                     `json:"earliestMsgPublishTimeInBacklogs,omitempty"`
	LastOffloadFailureTimeStamp                      *int64                                     `json:"lastOffloadFailureTimeStamp,omitempty"`
	LastOffloadLedgerId                              *int64                                     `json:"lastOffloadLedgerId,omitempty"`
	LastOffloadSuccessTimeStamp                      *int64                                     `json:"lastOffloadSuccessTimeStamp,omitempty"`
	Metadata                                         *PartitionedTopicMetadata                  `json:"metadata,omitempty"`
	MsgChunkPublished                                *bool                                      `json:"msgChunkPublished,omitempty"`
	MsgDropRate                                      *float64                                   `json:"msgDropRate,omitempty"`
	MsgInCounter                                     *int64                                     `json:"msgInCounter,omitempty"`
	MsgOutCounter                                    *int64                                     `json:"msgOutCounter,omitempty"`
	MsgRateIn                                        *float64                                   `json:"msgRateIn,omitempty"`
	MsgRateOut                                       *float64                                   `json:"msgRateOut,omitempty"`
	MsgThroughputIn                                  *float64                                   `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut                                 *float64                                   `json:"msgThroughputOut,omitempty"`
	NonContiguousDeletedMessagesRanges               *int32                                     `json:"nonContiguousDeletedMessagesRanges,omitempty"`
	NonContiguousDeletedMessagesRangesSerializedSize *int32                                     `json:"nonContiguousDeletedMessagesRangesSerializedSize,omitempty"`
	OffloadedStorageSize                             *int64                                     `json:"offloadedStorageSize,omitempty"`
	OngoingTxnCount                                  *int64                                     `json:"ongoingTxnCount,omitempty"`
	OwnerBroker                                      *string                                    `json:"ownerBroker,omitempty"`
	Partitions                                       *map[string]NonPersistentTopicStatsImpl    `json:"partitions,omitempty"`
	PublishRateLimitedTimes                          *int64                                     `json:"publishRateLimitedTimes,omitempty"`
	Publishers                                       *[]NonPersistentPublisherStats             `json:"publishers,omitempty"`
	Replication                                      *map[string]NonPersistentReplicatorStats   `json:"replication,omitempty"`
	StorageSize                                      *int64                                     `json:"storageSize,omitempty"`
	Subscriptions                                    *map[string]NonPersistentSubscriptionStats `json:"subscriptions,omitempty"`
	TopicEpoch                                       *int64                                     `json:"topicEpoch,omitempty"`
	WaitingPublishers                                *int32                                     `json:"waitingPublishers,omitempty"`
}

// NonPersistentPublisherStats defines model for NonPersistentPublisherStats.
type NonPersistentPublisherStats struct {
	AccessMode              *NonPersistentPublisherStatsAccessMode `json:"accessMode,omitempty"`
	Address                 *string                                `json:"address,omitempty"`
	AverageMsgSize          *float64                               `json:"averageMsgSize,omitempty"`
	ChunkedMessageRate      *float64                               `json:"chunkedMessageRate,omitempty"`
	ClientVersion           *string                                `json:"clientVersion,omitempty"`
	ConnectedSince          *string                                `json:"connectedSince,omitempty"`
	Metadata                *map[string]string                     `json:"metadata,omitempty"`
	MsgDropRate             *float64                               `json:"msgDropRate,omitempty"`
	MsgRateIn               *float64                               `json:"msgRateIn,omitempty"`
	MsgThroughputIn         *float64                               `json:"msgThroughputIn,omitempty"`
	ProducerId              *int64                                 `json:"producerId,omitempty"`
	ProducerName            *string                                `json:"producerName,omitempty"`
	SupportsPartialProducer *bool                                  `json:"supportsPartialProducer,omitempty"`
}

// NonPersistentPublisherStatsAccessMode defines model for NonPersistentPublisherStats.AccessMode.
type NonPersistentPublisherStatsAccessMode string

// NonPersistentReplicatorStats defines model for NonPersistentReplicatorStats.
type NonPersistentReplicatorStats struct {
	Connected                 *bool    `json:"connected,omitempty"`
	InboundConnectedSince     *string  `json:"inboundConnectedSince,omitempty"`
	InboundConnection         *string  `json:"inboundConnection,omitempty"`
	MsgDropRate               *float64 `json:"msgDropRate,omitempty"`
	MsgRateExpired            *float64 `json:"msgRateExpired,omitempty"`
	MsgRateIn                 *float64 `json:"msgRateIn,omitempty"`
	MsgRateOut                *float64 `json:"msgRateOut,omitempty"`
	MsgThroughputIn           *float64 `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut          *float64 `json:"msgThroughputOut,omitempty"`
	OutboundConnectedSince    *string  `json:"outboundConnectedSince,omitempty"`
	OutboundConnection        *string  `json:"outboundConnection,omitempty"`
	ReplicationBacklog        *int64   `json:"replicationBacklog,omitempty"`
	ReplicationDelayInSeconds *int64   `json:"replicationDelayInSeconds,omitempty"`
}

// NonPersistentSubscriptionStats defines model for NonPersistentSubscriptionStats.
type NonPersistentSubscriptionStats struct {
	ActiveConsumerName                               *string            `json:"activeConsumerName,omitempty"`
	AllowOutOfOrderDelivery                          *bool              `json:"allowOutOfOrderDelivery,omitempty"`
	BacklogSize                                      *int64             `json:"backlogSize,omitempty"`
	BlockedSubscriptionOnUnackedMsgs                 *bool              `json:"blockedSubscriptionOnUnackedMsgs,omitempty"`
	BytesOutCounter                                  *int64             `json:"bytesOutCounter,omitempty"`
	ChunkedMessageRate                               *int32             `json:"chunkedMessageRate,omitempty"`
	Consumers                                        *[]ConsumerStats   `json:"consumers,omitempty"`
	ConsumersAfterMarkDeletePosition                 *map[string]string `json:"consumersAfterMarkDeletePosition,omitempty"`
	DelayedMessageIndexSizeInBytes                   *int64             `json:"delayedMessageIndexSizeInBytes,omitempty"`
	Durable                                          *bool              `json:"durable,omitempty"`
	EarliestMsgPublishTimeInBacklog                  *int64             `json:"earliestMsgPublishTimeInBacklog,omitempty"`
	FilterAcceptedMsgCount                           *int64             `json:"filterAcceptedMsgCount,omitempty"`
	FilterProcessedMsgCount                          *int64             `json:"filterProcessedMsgCount,omitempty"`
	FilterRejectedMsgCount                           *int64             `json:"filterRejectedMsgCount,omitempty"`
	FilterRescheduledMsgCount                        *int64             `json:"filterRescheduledMsgCount,omitempty"`
	KeySharedMode                                    *string            `json:"keySharedMode,omitempty"`
	LastAckedTimestamp                               *int64             `json:"lastAckedTimestamp,omitempty"`
	LastConsumedFlowTimestamp                        *int64             `json:"lastConsumedFlowTimestamp,omitempty"`
	LastConsumedTimestamp                            *int64             `json:"lastConsumedTimestamp,omitempty"`
	LastExpireTimestamp                              *int64             `json:"lastExpireTimestamp,omitempty"`
	LastMarkDeleteAdvancedTimestamp                  *int64             `json:"lastMarkDeleteAdvancedTimestamp,omitempty"`
	MessageAckRate                                   *float64           `json:"messageAckRate,omitempty"`
	MsgBacklog                                       *int64             `json:"msgBacklog,omitempty"`
	MsgBacklogNoDelayed                              *int64             `json:"msgBacklogNoDelayed,omitempty"`
	MsgDelayed                                       *int64             `json:"msgDelayed,omitempty"`
	MsgDropRate                                      *float64           `json:"msgDropRate,omitempty"`
	MsgOutCounter                                    *int64             `json:"msgOutCounter,omitempty"`
	MsgRateExpired                                   *float64           `json:"msgRateExpired,omitempty"`
	MsgRateOut                                       *float64           `json:"msgRateOut,omitempty"`
	MsgRateRedeliver                                 *float64           `json:"msgRateRedeliver,omitempty"`
	MsgThroughputOut                                 *float64           `json:"msgThroughputOut,omitempty"`
	NonContiguousDeletedMessagesRanges               *int32             `json:"nonContiguousDeletedMessagesRanges,omitempty"`
	NonContiguousDeletedMessagesRangesSerializedSize *int32             `json:"nonContiguousDeletedMessagesRangesSerializedSize,omitempty"`
	Replicated                                       *bool              `json:"replicated,omitempty"`
	SubscriptionProperties                           *map[string]string `json:"subscriptionProperties,omitempty"`
	TotalMsgExpired                                  *int64             `json:"totalMsgExpired,omitempty"`
	Type                                             *string            `json:"type,omitempty"`
	UnackedMessages                                  *int64             `json:"unackedMessages,omitempty"`
}

// NonPersistentTopicStatsImpl defines model for NonPersistentTopicStatsImpl.
type NonPersistentTopicStatsImpl struct {
	AbortedTxnCount                                  *int64                                     `json:"abortedTxnCount,omitempty"`
	AverageMsgSize                                   *float64                                   `json:"averageMsgSize,omitempty"`
	BacklogSize                                      *int64                                     `json:"backlogSize,omitempty"`
	BytesInCounter                                   *int64                                     `json:"bytesInCounter,omitempty"`
	BytesOutCounter                                  *int64                                     `json:"bytesOutCounter,omitempty"`
	CommittedTxnCount                                *int64                                     `json:"committedTxnCount,omitempty"`
	Compaction                                       *CompactionStatsImpl                       `json:"compaction,omitempty"`
	DeduplicationStatus                              *string                                    `json:"deduplicationStatus,omitempty"`
	DelayedMessageIndexSizeInBytes                   *int64                                     `json:"delayedMessageIndexSizeInBytes,omitempty"`
	EarliestMsgPublishTimeInBacklogs                 *int64                                     `json:"earliestMsgPublishTimeInBacklogs,omitempty"`
	LastOffloadFailureTimeStamp                      *int64                                     `json:"lastOffloadFailureTimeStamp,omitempty"`
	LastOffloadLedgerId                              *int64                                     `json:"lastOffloadLedgerId,omitempty"`
	LastOffloadSuccessTimeStamp                      *int64                                     `json:"lastOffloadSuccessTimeStamp,omitempty"`
	MsgChunkPublished                                *bool                                      `json:"msgChunkPublished,omitempty"`
	MsgDropRate                                      *float64                                   `json:"msgDropRate,omitempty"`
	MsgInCounter                                     *int64                                     `json:"msgInCounter,omitempty"`
	MsgOutCounter                                    *int64                                     `json:"msgOutCounter,omitempty"`
	MsgRateIn                                        *float64                                   `json:"msgRateIn,omitempty"`
	MsgRateOut                                       *float64                                   `json:"msgRateOut,omitempty"`
	MsgThroughputIn                                  *float64                                   `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut                                 *float64                                   `json:"msgThroughputOut,omitempty"`
	NonContiguousDeletedMessagesRanges               *int32                                     `json:"nonContiguousDeletedMessagesRanges,omitempty"`
	NonContiguousDeletedMessagesRangesSerializedSize *int32                                     `json:"nonContiguousDeletedMessagesRangesSerializedSize,omitempty"`
	OffloadedStorageSize                             *int64                                     `json:"offloadedStorageSize,omitempty"`
	OngoingTxnCount                                  *int64                                     `json:"ongoingTxnCount,omitempty"`
	OwnerBroker                                      *string                                    `json:"ownerBroker,omitempty"`
	PublishRateLimitedTimes                          *int64                                     `json:"publishRateLimitedTimes,omitempty"`
	Publishers                                       *[]NonPersistentPublisherStats             `json:"publishers,omitempty"`
	Replication                                      *map[string]NonPersistentReplicatorStats   `json:"replication,omitempty"`
	StorageSize                                      *int64                                     `json:"storageSize,omitempty"`
	Subscriptions                                    *map[string]NonPersistentSubscriptionStats `json:"subscriptions,omitempty"`
	TopicEpoch                                       *int64                                     `json:"topicEpoch,omitempty"`
	WaitingPublishers                                *int32                                     `json:"waitingPublishers,omitempty"`
}

// OffloadPolicies defines model for OffloadPolicies.
type OffloadPolicies struct {
	FileSystemProfilePath                        *string                                            `json:"fileSystemProfilePath,omitempty"`
	FileSystemURI                                *string                                            `json:"fileSystemURI,omitempty"`
	GcsManagedLedgerOffloadBucket                *string                                            `json:"gcsManagedLedgerOffloadBucket,omitempty"`
	GcsManagedLedgerOffloadMaxBlockSizeInBytes   *int32                                             `json:"gcsManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadReadBufferSizeInBytes *int32                                             `json:"gcsManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadRegion                *string                                            `json:"gcsManagedLedgerOffloadRegion,omitempty"`
	GcsManagedLedgerOffloadServiceAccountKeyFile *string                                            `json:"gcsManagedLedgerOffloadServiceAccountKeyFile,omitempty"`
	ManagedLedgerOffloadBucket                   *string                                            `json:"managedLedgerOffloadBucket,omitempty"`
	ManagedLedgerOffloadDeletionLagInMillis      *int64                                             `json:"managedLedgerOffloadDeletionLagInMillis,omitempty"`
	ManagedLedgerOffloadDriver                   *string                                            `json:"managedLedgerOffloadDriver,omitempty"`
	ManagedLedgerOffloadMaxBlockSizeInBytes      *int32                                             `json:"managedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	ManagedLedgerOffloadMaxThreads               *int32                                             `json:"managedLedgerOffloadMaxThreads,omitempty"`
	ManagedLedgerOffloadPrefetchRounds           *int32                                             `json:"managedLedgerOffloadPrefetchRounds,omitempty"`
	ManagedLedgerOffloadReadBufferSizeInBytes    *int32                                             `json:"managedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	ManagedLedgerOffloadRegion                   *string                                            `json:"managedLedgerOffloadRegion,omitempty"`
	ManagedLedgerOffloadServiceEndpoint          *string                                            `json:"managedLedgerOffloadServiceEndpoint,omitempty"`
	ManagedLedgerOffloadThresholdInBytes         *int64                                             `json:"managedLedgerOffloadThresholdInBytes,omitempty"`
	ManagedLedgerOffloadThresholdInSeconds       *int64                                             `json:"managedLedgerOffloadThresholdInSeconds,omitempty"`
	ManagedLedgerOffloadedReadPriority           *OffloadPoliciesManagedLedgerOffloadedReadPriority `json:"managedLedgerOffloadedReadPriority,omitempty"`
	OffloadersDirectory                          *string                                            `json:"offloadersDirectory,omitempty"`
	S3ManagedLedgerOffloadBucket                 *string                                            `json:"s3ManagedLedgerOffloadBucket,omitempty"`
	S3ManagedLedgerOffloadCredentialId           *string                                            `json:"s3ManagedLedgerOffloadCredentialId,omitempty"`
	S3ManagedLedgerOffloadCredentialSecret       *string                                            `json:"s3ManagedLedgerOffloadCredentialSecret,omitempty"`
	S3ManagedLedgerOffloadMaxBlockSizeInBytes    *int32                                             `json:"s3ManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadReadBufferSizeInBytes  *int32                                             `json:"s3ManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadRegion                 *string                                            `json:"s3ManagedLedgerOffloadRegion,omitempty"`
	S3ManagedLedgerOffloadRole                   *string                                            `json:"s3ManagedLedgerOffloadRole,omitempty"`
	S3ManagedLedgerOffloadRoleSessionName        *string                                            `json:"s3ManagedLedgerOffloadRoleSessionName,omitempty"`
	S3ManagedLedgerOffloadServiceEndpoint        *string                                            `json:"s3ManagedLedgerOffloadServiceEndpoint,omitempty"`
}

// OffloadPoliciesManagedLedgerOffloadedReadPriority defines model for OffloadPolicies.ManagedLedgerOffloadedReadPriority.
type OffloadPoliciesManagedLedgerOffloadedReadPriority string

// OffloadPoliciesImpl defines model for OffloadPoliciesImpl.
type OffloadPoliciesImpl struct {
	FileSystemDriver                             *bool                                                  `json:"fileSystemDriver,omitempty"`
	FileSystemProfilePath                        *string                                                `json:"fileSystemProfilePath,omitempty"`
	FileSystemURI                                *string                                                `json:"fileSystemURI,omitempty"`
	GcsDriver                                    *bool                                                  `json:"gcsDriver,omitempty"`
	GcsManagedLedgerOffloadBucket                *string                                                `json:"gcsManagedLedgerOffloadBucket,omitempty"`
	GcsManagedLedgerOffloadMaxBlockSizeInBytes   *int32                                                 `json:"gcsManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadReadBufferSizeInBytes *int32                                                 `json:"gcsManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	GcsManagedLedgerOffloadRegion                *string                                                `json:"gcsManagedLedgerOffloadRegion,omitempty"`
	GcsManagedLedgerOffloadServiceAccountKeyFile *string                                                `json:"gcsManagedLedgerOffloadServiceAccountKeyFile,omitempty"`
	ManagedLedgerOffloadBucket                   *string                                                `json:"managedLedgerOffloadBucket,omitempty"`
	ManagedLedgerOffloadDeletionLagInMillis      *int64                                                 `json:"managedLedgerOffloadDeletionLagInMillis,omitempty"`
	ManagedLedgerOffloadDriver                   *string                                                `json:"managedLedgerOffloadDriver,omitempty"`
	ManagedLedgerOffloadMaxBlockSizeInBytes      *int32                                                 `json:"managedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	ManagedLedgerOffloadMaxThreads               *int32                                                 `json:"managedLedgerOffloadMaxThreads,omitempty"`
	ManagedLedgerOffloadPrefetchRounds           *int32                                                 `json:"managedLedgerOffloadPrefetchRounds,omitempty"`
	ManagedLedgerOffloadReadBufferSizeInBytes    *int32                                                 `json:"managedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	ManagedLedgerOffloadRegion                   *string                                                `json:"managedLedgerOffloadRegion,omitempty"`
	ManagedLedgerOffloadServiceEndpoint          *string                                                `json:"managedLedgerOffloadServiceEndpoint,omitempty"`
	ManagedLedgerOffloadThresholdInBytes         *int64                                                 `json:"managedLedgerOffloadThresholdInBytes,omitempty"`
	ManagedLedgerOffloadThresholdInSeconds       *int64                                                 `json:"managedLedgerOffloadThresholdInSeconds,omitempty"`
	ManagedLedgerOffloadedReadPriority           *OffloadPoliciesImplManagedLedgerOffloadedReadPriority `json:"managedLedgerOffloadedReadPriority,omitempty"`
	OffloadersDirectory                          *string                                                `json:"offloadersDirectory,omitempty"`
	S3Driver                                     *bool                                                  `json:"s3Driver,omitempty"`
	S3ManagedLedgerOffloadBucket                 *string                                                `json:"s3ManagedLedgerOffloadBucket,omitempty"`
	S3ManagedLedgerOffloadCredentialId           *string                                                `json:"s3ManagedLedgerOffloadCredentialId,omitempty"`
	S3ManagedLedgerOffloadCredentialSecret       *string                                                `json:"s3ManagedLedgerOffloadCredentialSecret,omitempty"`
	S3ManagedLedgerOffloadMaxBlockSizeInBytes    *int32                                                 `json:"s3ManagedLedgerOffloadMaxBlockSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadReadBufferSizeInBytes  *int32                                                 `json:"s3ManagedLedgerOffloadReadBufferSizeInBytes,omitempty"`
	S3ManagedLedgerOffloadRegion                 *string                                                `json:"s3ManagedLedgerOffloadRegion,omitempty"`
	S3ManagedLedgerOffloadRole                   *string                                                `json:"s3ManagedLedgerOffloadRole,omitempty"`
	S3ManagedLedgerOffloadRoleSessionName        *string                                                `json:"s3ManagedLedgerOffloadRoleSessionName,omitempty"`
	S3ManagedLedgerOffloadServiceEndpoint        *string                                                `json:"s3ManagedLedgerOffloadServiceEndpoint,omitempty"`
}

// OffloadPoliciesImplManagedLedgerOffloadedReadPriority defines model for OffloadPoliciesImpl.ManagedLedgerOffloadedReadPriority.
type OffloadPoliciesImplManagedLedgerOffloadedReadPriority string

// OutputStream defines model for OutputStream.
type OutputStream = map[string]interface{}

// PartitionedManagedLedgerInfo defines model for PartitionedManagedLedgerInfo.
type PartitionedManagedLedgerInfo struct {
	CreationDate       *string                       `json:"creationDate,omitempty"`
	Cursors            *map[string]CursorInfo        `json:"cursors,omitempty"`
	Ledgers            *[]LedgerInfo                 `json:"ledgers,omitempty"`
	ModificationDate   *string                       `json:"modificationDate,omitempty"`
	Partitions         *map[string]ManagedLedgerInfo `json:"partitions,omitempty"`
	Properties         *map[string]string            `json:"properties,omitempty"`
	TerminatedPosition *PositionInfo                 `json:"terminatedPosition,omitempty"`
	Version            *int64                        `json:"version,omitempty"`
}

// PartitionedTopicInternalStats defines model for PartitionedTopicInternalStats.
type PartitionedTopicInternalStats struct {
	Metadata   *PartitionedTopicMetadata                `json:"metadata,omitempty"`
	Partitions *map[string]PersistentTopicInternalStats `json:"partitions,omitempty"`
}

// PartitionedTopicMetadata defines model for PartitionedTopicMetadata.
type PartitionedTopicMetadata struct {
	Deleted    *bool              `json:"deleted,omitempty"`
	Partitions *int32             `json:"partitions,omitempty"`
	Properties *map[string]string `json:"properties,omitempty"`
}

// PartitionedTopicStatsImpl defines model for PartitionedTopicStatsImpl.
type PartitionedTopicStatsImpl struct {
	AbortedTxnCount                                  *int64                        `json:"abortedTxnCount,omitempty"`
	AverageMsgSize                                   *float64                      `json:"averageMsgSize,omitempty"`
	BacklogSize                                      *int64                        `json:"backlogSize,omitempty"`
	BytesInCounter                                   *int64                        `json:"bytesInCounter,omitempty"`
	BytesOutCounter                                  *int64                        `json:"bytesOutCounter,omitempty"`
	CommittedTxnCount                                *int64                        `json:"committedTxnCount,omitempty"`
	Compaction                                       *CompactionStatsImpl          `json:"compaction,omitempty"`
	DeduplicationStatus                              *string                       `json:"deduplicationStatus,omitempty"`
	DelayedMessageIndexSizeInBytes                   *int64                        `json:"delayedMessageIndexSizeInBytes,omitempty"`
	EarliestMsgPublishTimeInBacklogs                 *int64                        `json:"earliestMsgPublishTimeInBacklogs,omitempty"`
	LastOffloadFailureTimeStamp                      *int64                        `json:"lastOffloadFailureTimeStamp,omitempty"`
	LastOffloadLedgerId                              *int64                        `json:"lastOffloadLedgerId,omitempty"`
	LastOffloadSuccessTimeStamp                      *int64                        `json:"lastOffloadSuccessTimeStamp,omitempty"`
	Metadata                                         *PartitionedTopicMetadata     `json:"metadata,omitempty"`
	MsgChunkPublished                                *bool                         `json:"msgChunkPublished,omitempty"`
	MsgInCounter                                     *int64                        `json:"msgInCounter,omitempty"`
	MsgOutCounter                                    *int64                        `json:"msgOutCounter,omitempty"`
	MsgRateIn                                        *float64                      `json:"msgRateIn,omitempty"`
	MsgRateOut                                       *float64                      `json:"msgRateOut,omitempty"`
	MsgThroughputIn                                  *float64                      `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut                                 *float64                      `json:"msgThroughputOut,omitempty"`
	NonContiguousDeletedMessagesRanges               *int32                        `json:"nonContiguousDeletedMessagesRanges,omitempty"`
	NonContiguousDeletedMessagesRangesSerializedSize *int32                        `json:"nonContiguousDeletedMessagesRangesSerializedSize,omitempty"`
	OffloadedStorageSize                             *int64                        `json:"offloadedStorageSize,omitempty"`
	OngoingTxnCount                                  *int64                        `json:"ongoingTxnCount,omitempty"`
	OwnerBroker                                      *string                       `json:"ownerBroker,omitempty"`
	Partitions                                       *map[string]TopicStats        `json:"partitions,omitempty"`
	PublishRateLimitedTimes                          *int64                        `json:"publishRateLimitedTimes,omitempty"`
	Publishers                                       *[]PublisherStats             `json:"publishers,omitempty"`
	Replication                                      *map[string]ReplicatorStats   `json:"replication,omitempty"`
	StorageSize                                      *int64                        `json:"storageSize,omitempty"`
	Subscriptions                                    *map[string]SubscriptionStats `json:"subscriptions,omitempty"`
	TopicEpoch                                       *int64                        `json:"topicEpoch,omitempty"`
	WaitingPublishers                                *int32                        `json:"waitingPublishers,omitempty"`
}

// PendingBookieOpsStats defines model for PendingBookieOpsStats.
type PendingBookieOpsStats struct {
	CursorLedgerCloseOp  *int64 `json:"cursorLedgerCloseOp,omitempty"`
	CursorLedgerCreateOp *int64 `json:"cursorLedgerCreateOp,omitempty"`
	CursorLedgerDeleteOp *int64 `json:"cursorLedgerDeleteOp,omitempty"`
	CursorLedgerOpenOp   *int64 `json:"cursorLedgerOpenOp,omitempty"`
	DataLedgerCloseOp    *int64 `json:"dataLedgerCloseOp,omitempty"`
	DataLedgerCreateOp   *int64 `json:"dataLedgerCreateOp,omitempty"`
	DataLedgerDeleteOp   *int64 `json:"dataLedgerDeleteOp,omitempty"`
	DataLedgerOpenOp     *int64 `json:"dataLedgerOpenOp,omitempty"`
}

// PersistencePolicies defines model for PersistencePolicies.
type PersistencePolicies struct {
	BookkeeperAckQuorum            *int32   `json:"bookkeeperAckQuorum,omitempty"`
	BookkeeperEnsemble             *int32   `json:"bookkeeperEnsemble,omitempty"`
	BookkeeperWriteQuorum          *int32   `json:"bookkeeperWriteQuorum,omitempty"`
	ManagedLedgerMaxMarkDeleteRate *float64 `json:"managedLedgerMaxMarkDeleteRate,omitempty"`
}

// PersistentOfflineTopicStats defines model for PersistentOfflineTopicStats.
type PersistentOfflineTopicStats struct {
	BrokerName        *string                   `json:"brokerName,omitempty"`
	CursorDetails     *map[string]CursorDetails `json:"cursorDetails,omitempty"`
	DataLedgerDetails *[]LedgerDetails          `json:"dataLedgerDetails,omitempty"`
	MessageBacklog    *int64                    `json:"messageBacklog,omitempty"`
	StatGeneratedAt   *time.Time                `json:"statGeneratedAt,omitempty"`
	StorageSize       *int64                    `json:"storageSize,omitempty"`
	TopicName         *string                   `json:"topicName,omitempty"`
	TotalMessages     *int64                    `json:"totalMessages,omitempty"`
}

// PersistentTopicInternalStats defines model for PersistentTopicInternalStats.
type PersistentTopicInternalStats struct {
	CompactedLedger                    *LedgerInfo             `json:"compactedLedger,omitempty"`
	CurrentLedgerEntries               *int64                  `json:"currentLedgerEntries,omitempty"`
	CurrentLedgerSize                  *int64                  `json:"currentLedgerSize,omitempty"`
	Cursors                            *map[string]CursorStats `json:"cursors,omitempty"`
	EntriesAddedCounter                *int64                  `json:"entriesAddedCounter,omitempty"`
	LastConfirmedEntry                 *string                 `json:"lastConfirmedEntry,omitempty"`
	LastLedgerCreatedTimestamp         *string                 `json:"lastLedgerCreatedTimestamp,omitempty"`
	LastLedgerCreationFailureTimestamp *string                 `json:"lastLedgerCreationFailureTimestamp,omitempty"`
	Ledgers                            *[]LedgerInfo           `json:"ledgers,omitempty"`
	NumberOfEntries                    *int64                  `json:"numberOfEntries,omitempty"`
	PendingAddEntriesCount             *int32                  `json:"pendingAddEntriesCount,omitempty"`
	SchemaLedgers                      *[]LedgerInfo           `json:"schemaLedgers,omitempty"`
	State                              *string                 `json:"state,omitempty"`
	TotalSize                          *int64                  `json:"totalSize,omitempty"`
	WaitingCursorsCount                *int32                  `json:"waitingCursorsCount,omitempty"`
}

// PersistentTopicStats defines model for PersistentTopicStats.
type PersistentTopicStats struct {
	AverageMsgSize                                   *float64                      `json:"averageMsgSize,omitempty"`
	BacklogSize                                      *int64                        `json:"backlogSize,omitempty"`
	BytesInCounter                                   *int64                        `json:"bytesInCounter,omitempty"`
	BytesOutCounter                                  *int64                        `json:"bytesOutCounter,omitempty"`
	Compaction                                       *CompactionStats              `json:"compaction,omitempty"`
	DeduplicationStatus                              *string                       `json:"deduplicationStatus,omitempty"`
	DelayedMessageIndexSizeInBytes                   *int64                        `json:"delayedMessageIndexSizeInBytes,omitempty"`
	EarliestMsgPublishTimeInBacklogs                 *int64                        `json:"earliestMsgPublishTimeInBacklogs,omitempty"`
	MsgChunkPublished                                *bool                         `json:"msgChunkPublished,omitempty"`
	MsgInCounter                                     *int64                        `json:"msgInCounter,omitempty"`
	MsgOutCounter                                    *int64                        `json:"msgOutCounter,omitempty"`
	MsgRateIn                                        *float64                      `json:"msgRateIn,omitempty"`
	MsgRateOut                                       *float64                      `json:"msgRateOut,omitempty"`
	MsgThroughputIn                                  *float64                      `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut                                 *float64                      `json:"msgThroughputOut,omitempty"`
	NonContiguousDeletedMessagesRanges               *int32                        `json:"nonContiguousDeletedMessagesRanges,omitempty"`
	NonContiguousDeletedMessagesRangesSerializedSize *int32                        `json:"nonContiguousDeletedMessagesRangesSerializedSize,omitempty"`
	OffloadedStorageSize                             *int64                        `json:"offloadedStorageSize,omitempty"`
	OwnerBroker                                      *string                       `json:"ownerBroker,omitempty"`
	Publishers                                       *[]PublisherStats             `json:"publishers,omitempty"`
	Replication                                      *map[string]ReplicatorStats   `json:"replication,omitempty"`
	StorageSize                                      *int64                        `json:"storageSize,omitempty"`
	Subscriptions                                    *map[string]SubscriptionStats `json:"subscriptions,omitempty"`
	TopicEpoch                                       *int64                        `json:"topicEpoch,omitempty"`
	WaitingPublishers                                *int32                        `json:"waitingPublishers,omitempty"`
}

// Policies defines model for Policies.
type Policies struct {
	AuthPolicies                          *AuthPolicies                                  `json:"auth_policies,omitempty"`
	AutoSubscriptionCreationOverride      *AutoSubscriptionCreationOverride              `json:"autoSubscriptionCreationOverride,omitempty"`
	AutoTopicCreationOverride             *AutoTopicCreationOverride                     `json:"autoTopicCreationOverride,omitempty"`
	BacklogQuotaMap                       *map[string]BacklogQuota                       `json:"backlog_quota_map,omitempty"`
	Bundles                               *BundlesData                                   `json:"bundles,omitempty"`
	ClusterDispatchRate                   *map[string]DispatchRateImpl                   `json:"clusterDispatchRate,omitempty"`
	ClusterSubscribeRate                  *map[string]SubscribeRate                      `json:"clusterSubscribeRate,omitempty"`
	CompactionThreshold                   *int64                                         `json:"compaction_threshold,omitempty"`
	DeduplicationEnabled                  *bool                                          `json:"deduplicationEnabled,omitempty"`
	DeduplicationSnapshotIntervalSeconds  *int32                                         `json:"deduplicationSnapshotIntervalSeconds,omitempty"`
	DelayedDeliveryPolicies               *DelayedDeliveryPolicies                       `json:"delayed_delivery_policies,omitempty"`
	Deleted                               *bool                                          `json:"deleted,omitempty"`
	EncryptionRequired                    *bool                                          `json:"encryption_required,omitempty"`
	EntryFilters                          *EntryFilters                                  `json:"entryFilters,omitempty"`
	InactiveTopicPolicies                 *InactiveTopicPolicies                         `json:"inactive_topic_policies,omitempty"`
	IsAllowAutoUpdateSchema               *bool                                          `json:"is_allow_auto_update_schema,omitempty"`
	LatencyStatsSampleRate                *map[string]int32                              `json:"latency_stats_sample_rate,omitempty"`
	MaxConsumersPerSubscription           *int32                                         `json:"max_consumers_per_subscription,omitempty"`
	MaxConsumersPerTopic                  *int32                                         `json:"max_consumers_per_topic,omitempty"`
	MaxProducersPerTopic                  *int32                                         `json:"max_producers_per_topic,omitempty"`
	MaxSubscriptionsPerTopic              *int32                                         `json:"max_subscriptions_per_topic,omitempty"`
	MaxTopicsPerNamespace                 *int32                                         `json:"max_topics_per_namespace,omitempty"`
	MaxUnackedMessagesPerConsumer         *int32                                         `json:"max_unacked_messages_per_consumer,omitempty"`
	MaxUnackedMessagesPerSubscription     *int32                                         `json:"max_unacked_messages_per_subscription,omitempty"`
	MessageTtlInSeconds                   *int32                                         `json:"message_ttl_in_seconds,omitempty"`
	OffloadDeletionLagMs                  *int64                                         `json:"offload_deletion_lag_ms,omitempty"`
	OffloadPolicies                       *OffloadPolicies                               `json:"offload_policies,omitempty"`
	OffloadThreshold                      *int64                                         `json:"offload_threshold,omitempty"`
	OffloadThresholdInSeconds             *int64                                         `json:"offload_threshold_in_seconds,omitempty"`
	Persistence                           *PersistencePolicies                           `json:"persistence,omitempty"`
	Properties                            *map[string]string                             `json:"properties,omitempty"`
	PublishMaxMessageRate                 *map[string]PublishRate                        `json:"publishMaxMessageRate,omitempty"`
	ReplicationClusters                   *[]string                                      `json:"replication_clusters,omitempty"`
	ReplicatorDispatchRate                *map[string]DispatchRateImpl                   `json:"replicatorDispatchRate,omitempty"`
	ResourceGroupName                     *string                                        `json:"resource_group_name,omitempty"`
	RetentionPolicies                     *RetentionPolicies                             `json:"retention_policies,omitempty"`
	SchemaAutoUpdateCompatibilityStrategy *PoliciesSchemaAutoUpdateCompatibilityStrategy `json:"schema_auto_update_compatibility_strategy,omitempty"`
	SchemaCompatibilityStrategy           *PoliciesSchemaCompatibilityStrategy           `json:"schema_compatibility_strategy,omitempty"`
	SchemaValidationEnforced              *bool                                          `json:"schema_validation_enforced,omitempty"`
	SubscriptionDispatchRate              *map[string]DispatchRateImpl                   `json:"subscriptionDispatchRate,omitempty"`
	SubscriptionAuthMode                  *PoliciesSubscriptionAuthMode                  `json:"subscription_auth_mode,omitempty"`
	SubscriptionExpirationTimeMinutes     *int32                                         `json:"subscription_expiration_time_minutes,omitempty"`
	SubscriptionTypesEnabled              *[]string                                      `json:"subscription_types_enabled,omitempty"`
	TopicDispatchRate                     *map[string]DispatchRateImpl                   `json:"topicDispatchRate,omitempty"`
}

// PoliciesSchemaAutoUpdateCompatibilityStrategy defines model for Policies.SchemaAutoUpdateCompatibilityStrategy.
type PoliciesSchemaAutoUpdateCompatibilityStrategy string

// PoliciesSchemaCompatibilityStrategy defines model for Policies.SchemaCompatibilityStrategy.
type PoliciesSchemaCompatibilityStrategy string

// PoliciesSubscriptionAuthMode defines model for Policies.SubscriptionAuthMode.
type PoliciesSubscriptionAuthMode string

// PoolArenaStats defines model for PoolArenaStats.
type PoolArenaStats struct {
	ChunkLists                 *[]PoolChunkListStats `json:"chunkLists,omitempty"`
	NumActiveAllocations       *int64                `json:"numActiveAllocations,omitempty"`
	NumActiveHugeAllocations   *int64                `json:"numActiveHugeAllocations,omitempty"`
	NumActiveNormalAllocations *int64                `json:"numActiveNormalAllocations,omitempty"`
	NumActiveSmallAllocations  *int64                `json:"numActiveSmallAllocations,omitempty"`
	NumAllocations             *int64                `json:"numAllocations,omitempty"`
	NumChunkLists              *int32                `json:"numChunkLists,omitempty"`
	NumDeallocations           *int64                `json:"numDeallocations,omitempty"`
	NumHugeAllocations         *int64                `json:"numHugeAllocations,omitempty"`
	NumHugeDeallocations       *int64                `json:"numHugeDeallocations,omitempty"`
	NumNormalAllocations       *int64                `json:"numNormalAllocations,omitempty"`
	NumNormalDeallocations     *int64                `json:"numNormalDeallocations,omitempty"`
	NumSmallAllocations        *int64                `json:"numSmallAllocations,omitempty"`
	NumSmallDeallocations      *int64                `json:"numSmallDeallocations,omitempty"`
	NumSmallSubpages           *int32                `json:"numSmallSubpages,omitempty"`
	SmallSubpages              *[]PoolSubpageStats   `json:"smallSubpages,omitempty"`
}

// PoolChunkListStats defines model for PoolChunkListStats.
type PoolChunkListStats struct {
	Chunks   *[]PoolChunkStats `json:"chunks,omitempty"`
	MaxUsage *int32            `json:"maxUsage,omitempty"`
	MinUsage *int32            `json:"minUsage,omitempty"`
}

// PoolChunkStats defines model for PoolChunkStats.
type PoolChunkStats struct {
	ChunkSize *int32 `json:"chunkSize,omitempty"`
	FreeBytes *int32 `json:"freeBytes,omitempty"`
	Usage     *int32 `json:"usage,omitempty"`
}

// PoolSubpageStats defines model for PoolSubpageStats.
type PoolSubpageStats struct {
	ElementSize    *int32 `json:"elementSize,omitempty"`
	MaxNumElements *int32 `json:"maxNumElements,omitempty"`
	NumAvailable   *int32 `json:"numAvailable,omitempty"`
	PageSize       *int32 `json:"pageSize,omitempty"`
}

// PositionInfo defines model for PositionInfo.
type PositionInfo struct {
	EntryId  *int64 `json:"entryId,omitempty"`
	LedgerId *int64 `json:"ledgerId,omitempty"`
}

// PostSchemaPayload defines model for PostSchemaPayload.
type PostSchemaPayload struct {
	Properties *map[string]string `json:"properties,omitempty"`
	Schema     *string            `json:"schema,omitempty"`
	Type       *string            `json:"type,omitempty"`
}

// PostSchemaResponse defines model for PostSchemaResponse.
type PostSchemaResponse struct {
	Version *SchemaVersion `json:"version,omitempty"`
}

// ProcessContainerFactory defines model for ProcessContainerFactory.
type ProcessContainerFactory struct {
	ExtraFunctionDependenciesDir *string `json:"extraFunctionDependenciesDir,omitempty"`
	JavaInstanceJarLocation      *string `json:"javaInstanceJarLocation,omitempty"`
	LogDirectory                 *string `json:"logDirectory,omitempty"`
	PythonInstanceLocation       *string `json:"pythonInstanceLocation,omitempty"`
}

// PublicKey defines model for PublicKey.
type PublicKey struct {
	Algorithm *string   `json:"algorithm,omitempty"`
	Encoded   *[][]byte `json:"encoded,omitempty"`
	Format    *string   `json:"format,omitempty"`
}

// PublishRate defines model for PublishRate.
type PublishRate struct {
	PublishThrottlingRateInByte *int64 `json:"publishThrottlingRateInByte,omitempty"`
	PublishThrottlingRateInMsg  *int32 `json:"publishThrottlingRateInMsg,omitempty"`
}

// PublisherStats defines model for PublisherStats.
type PublisherStats struct {
	AccessMode              *PublisherStatsAccessMode `json:"accessMode,omitempty"`
	Address                 *string                   `json:"address,omitempty"`
	AverageMsgSize          *float64                  `json:"averageMsgSize,omitempty"`
	ChunkedMessageRate      *float64                  `json:"chunkedMessageRate,omitempty"`
	ClientVersion           *string                   `json:"clientVersion,omitempty"`
	ConnectedSince          *string                   `json:"connectedSince,omitempty"`
	Metadata                *map[string]string        `json:"metadata,omitempty"`
	MsgRateIn               *float64                  `json:"msgRateIn,omitempty"`
	MsgThroughputIn         *float64                  `json:"msgThroughputIn,omitempty"`
	ProducerId              *int64                    `json:"producerId,omitempty"`
	ProducerName            *string                   `json:"producerName,omitempty"`
	SupportsPartialProducer *bool                     `json:"supportsPartialProducer,omitempty"`
}

// PublisherStatsAccessMode defines model for PublisherStats.AccessMode.
type PublisherStatsAccessMode string

// RawBookieInfo defines model for RawBookieInfo.
type RawBookieInfo struct {
	BookieId *string `json:"bookieId,omitempty"`
}

// ReplicatorStats defines model for ReplicatorStats.
type ReplicatorStats struct {
	Connected                 *bool    `json:"connected,omitempty"`
	InboundConnectedSince     *string  `json:"inboundConnectedSince,omitempty"`
	InboundConnection         *string  `json:"inboundConnection,omitempty"`
	MsgRateExpired            *float64 `json:"msgRateExpired,omitempty"`
	MsgRateIn                 *float64 `json:"msgRateIn,omitempty"`
	MsgRateOut                *float64 `json:"msgRateOut,omitempty"`
	MsgThroughputIn           *float64 `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut          *float64 `json:"msgThroughputOut,omitempty"`
	OutboundConnectedSince    *string  `json:"outboundConnectedSince,omitempty"`
	OutboundConnection        *string  `json:"outboundConnection,omitempty"`
	ReplicationBacklog        *int64   `json:"replicationBacklog,omitempty"`
	ReplicationDelayInSeconds *int64   `json:"replicationDelayInSeconds,omitempty"`
}

// ResetCursorData defines model for ResetCursorData.
type ResetCursorData struct {
	BatchIndex     *int32             `json:"batchIndex,omitempty"`
	EntryId        *int64             `json:"entryId,omitempty"`
	Excluded       *bool              `json:"excluded,omitempty"`
	LedgerId       *int64             `json:"ledgerId,omitempty"`
	PartitionIndex *int32             `json:"partitionIndex,omitempty"`
	Properties     *map[string]string `json:"properties,omitempty"`
}

// ResourceDescription defines model for ResourceDescription.
type ResourceDescription struct {
	ResourceUsage *map[string]ResourceUsage `json:"resourceUsage,omitempty"`
	UsagePct      *int32                    `json:"usagePct,omitempty"`
}

// ResourceGroup defines model for ResourceGroup.
type ResourceGroup struct {
	DispatchRateInBytes *int64 `json:"dispatchRateInBytes,omitempty"`
	DispatchRateInMsgs  *int32 `json:"dispatchRateInMsgs,omitempty"`
	PublishRateInBytes  *int64 `json:"publishRateInBytes,omitempty"`
	PublishRateInMsgs   *int32 `json:"publishRateInMsgs,omitempty"`
}

// ResourceQuota defines model for ResourceQuota.
type ResourceQuota struct {
	BandwidthIn  *float64 `json:"bandwidthIn,omitempty"`
	BandwidthOut *float64 `json:"bandwidthOut,omitempty"`
	Dynamic      *bool    `json:"dynamic,omitempty"`
	Memory       *float64 `json:"memory,omitempty"`
	MsgRateIn    *float64 `json:"msgRateIn,omitempty"`
	MsgRateOut   *float64 `json:"msgRateOut,omitempty"`
}

// ResourceUnit defines model for ResourceUnit.
type ResourceUnit struct {
	AvailableResource *ResourceDescription `json:"availableResource,omitempty"`
	ResourceId        *string              `json:"resourceId,omitempty"`
}

// ResourceUsage defines model for ResourceUsage.
type ResourceUsage struct {
	Limit *float64 `json:"limit,omitempty"`
	Usage *float64 `json:"usage,omitempty"`
}

// Resources defines model for Resources.
type Resources struct {
	Cpu  *float64 `json:"cpu,omitempty"`
	Disk *int64   `json:"disk,omitempty"`
	Ram  *int64   `json:"ram,omitempty"`
}

// RetentionPolicies defines model for RetentionPolicies.
type RetentionPolicies struct {
	RetentionSizeInMB      *int64 `json:"retentionSizeInMB,omitempty"`
	RetentionTimeInMinutes *int32 `json:"retentionTimeInMinutes,omitempty"`
}

// SchemaVersion defines model for SchemaVersion.
type SchemaVersion = map[string]interface{}

// Sinks defines model for Sinks.
type Sinks struct {
	ListOfConnectors *[]ConnectorDefinition `json:"listOfConnectors,omitempty"`
	SinkList         *[]ConnectorDefinition `json:"sinkList,omitempty"`
}

// SinksWorkerService defines model for SinksWorkerService.
type SinksWorkerService struct {
	ListOfConnectors *[]ConnectorDefinition `json:"listOfConnectors,omitempty"`
	SinkList         *[]ConnectorDefinition `json:"sinkList,omitempty"`
}

// SocketAddress defines model for SocketAddress.
type SocketAddress = map[string]interface{}

// Sources defines model for Sources.
type Sources struct {
	ListOfConnectors *[]ConnectorDefinition `json:"listOfConnectors,omitempty"`
	SourceList       *[]ConnectorDefinition `json:"sourceList,omitempty"`
}

// SourcesWorkerService defines model for SourcesWorkerService.
type SourcesWorkerService struct {
	ListOfConnectors *[]ConnectorDefinition `json:"listOfConnectors,omitempty"`
	SourceList       *[]ConnectorDefinition `json:"sourceList,omitempty"`
}

// SubscribeRate defines model for SubscribeRate.
type SubscribeRate struct {
	RatePeriodInSecond                 *int32 `json:"ratePeriodInSecond,omitempty"`
	SubscribeThrottlingRatePerConsumer *int32 `json:"subscribeThrottlingRatePerConsumer,omitempty"`
}

// SubscriptionStats defines model for SubscriptionStats.
type SubscriptionStats struct {
	ActiveConsumerName                               *string            `json:"activeConsumerName,omitempty"`
	AllowOutOfOrderDelivery                          *bool              `json:"allowOutOfOrderDelivery,omitempty"`
	BacklogSize                                      *int64             `json:"backlogSize,omitempty"`
	BlockedSubscriptionOnUnackedMsgs                 *bool              `json:"blockedSubscriptionOnUnackedMsgs,omitempty"`
	BytesOutCounter                                  *int64             `json:"bytesOutCounter,omitempty"`
	ChunkedMessageRate                               *int32             `json:"chunkedMessageRate,omitempty"`
	Consumers                                        *[]ConsumerStats   `json:"consumers,omitempty"`
	ConsumersAfterMarkDeletePosition                 *map[string]string `json:"consumersAfterMarkDeletePosition,omitempty"`
	DelayedMessageIndexSizeInBytes                   *int64             `json:"delayedMessageIndexSizeInBytes,omitempty"`
	Durable                                          *bool              `json:"durable,omitempty"`
	EarliestMsgPublishTimeInBacklog                  *int64             `json:"earliestMsgPublishTimeInBacklog,omitempty"`
	FilterAcceptedMsgCount                           *int64             `json:"filterAcceptedMsgCount,omitempty"`
	FilterProcessedMsgCount                          *int64             `json:"filterProcessedMsgCount,omitempty"`
	FilterRejectedMsgCount                           *int64             `json:"filterRejectedMsgCount,omitempty"`
	FilterRescheduledMsgCount                        *int64             `json:"filterRescheduledMsgCount,omitempty"`
	KeySharedMode                                    *string            `json:"keySharedMode,omitempty"`
	LastAckedTimestamp                               *int64             `json:"lastAckedTimestamp,omitempty"`
	LastConsumedFlowTimestamp                        *int64             `json:"lastConsumedFlowTimestamp,omitempty"`
	LastConsumedTimestamp                            *int64             `json:"lastConsumedTimestamp,omitempty"`
	LastExpireTimestamp                              *int64             `json:"lastExpireTimestamp,omitempty"`
	LastMarkDeleteAdvancedTimestamp                  *int64             `json:"lastMarkDeleteAdvancedTimestamp,omitempty"`
	MessageAckRate                                   *float64           `json:"messageAckRate,omitempty"`
	MsgBacklog                                       *int64             `json:"msgBacklog,omitempty"`
	MsgBacklogNoDelayed                              *int64             `json:"msgBacklogNoDelayed,omitempty"`
	MsgDelayed                                       *int64             `json:"msgDelayed,omitempty"`
	MsgOutCounter                                    *int64             `json:"msgOutCounter,omitempty"`
	MsgRateExpired                                   *float64           `json:"msgRateExpired,omitempty"`
	MsgRateOut                                       *float64           `json:"msgRateOut,omitempty"`
	MsgRateRedeliver                                 *float64           `json:"msgRateRedeliver,omitempty"`
	MsgThroughputOut                                 *float64           `json:"msgThroughputOut,omitempty"`
	NonContiguousDeletedMessagesRanges               *int32             `json:"nonContiguousDeletedMessagesRanges,omitempty"`
	NonContiguousDeletedMessagesRangesSerializedSize *int32             `json:"nonContiguousDeletedMessagesRangesSerializedSize,omitempty"`
	Replicated                                       *bool              `json:"replicated,omitempty"`
	SubscriptionProperties                           *map[string]string `json:"subscriptionProperties,omitempty"`
	TotalMsgExpired                                  *int64             `json:"totalMsgExpired,omitempty"`
	Type                                             *string            `json:"type,omitempty"`
	UnackedMessages                                  *int64             `json:"unackedMessages,omitempty"`
}

// SystemResourceUsage defines model for SystemResourceUsage.
type SystemResourceUsage struct {
	BandwidthIn  *ResourceUsage `json:"bandwidthIn,omitempty"`
	BandwidthOut *ResourceUsage `json:"bandwidthOut,omitempty"`
	Cpu          *ResourceUsage `json:"cpu,omitempty"`
	DirectMemory *ResourceUsage `json:"directMemory,omitempty"`
	Memory       *ResourceUsage `json:"memory,omitempty"`
}

// TenantInfo Information of adminRoles and allowedClusters for tenant
type TenantInfo struct {
	// AdminRoles Comma separated list of auth principal allowed to administrate the tenant.
	AdminRoles *[]string `json:"adminRoles,omitempty"`

	// AllowedClusters Comma separated allowed clusters.
	AllowedClusters *[]string `json:"allowedClusters,omitempty"`
}

// ThreadContainerFactory defines model for ThreadContainerFactory.
type ThreadContainerFactory struct {
	PulsarClientMemoryLimit *MemoryLimit `json:"pulsarClientMemoryLimit,omitempty"`
	ThreadGroupName         *string      `json:"threadGroupName,omitempty"`
}

// TopicStats defines model for TopicStats.
type TopicStats struct {
	AverageMsgSize                                   *float64                      `json:"averageMsgSize,omitempty"`
	BacklogSize                                      *int64                        `json:"backlogSize,omitempty"`
	BytesInCounter                                   *int64                        `json:"bytesInCounter,omitempty"`
	BytesOutCounter                                  *int64                        `json:"bytesOutCounter,omitempty"`
	Compaction                                       *CompactionStats              `json:"compaction,omitempty"`
	DeduplicationStatus                              *string                       `json:"deduplicationStatus,omitempty"`
	DelayedMessageIndexSizeInBytes                   *int64                        `json:"delayedMessageIndexSizeInBytes,omitempty"`
	EarliestMsgPublishTimeInBacklogs                 *int64                        `json:"earliestMsgPublishTimeInBacklogs,omitempty"`
	MsgChunkPublished                                *bool                         `json:"msgChunkPublished,omitempty"`
	MsgInCounter                                     *int64                        `json:"msgInCounter,omitempty"`
	MsgOutCounter                                    *int64                        `json:"msgOutCounter,omitempty"`
	MsgRateIn                                        *float64                      `json:"msgRateIn,omitempty"`
	MsgRateOut                                       *float64                      `json:"msgRateOut,omitempty"`
	MsgThroughputIn                                  *float64                      `json:"msgThroughputIn,omitempty"`
	MsgThroughputOut                                 *float64                      `json:"msgThroughputOut,omitempty"`
	NonContiguousDeletedMessagesRanges               *int32                        `json:"nonContiguousDeletedMessagesRanges,omitempty"`
	NonContiguousDeletedMessagesRangesSerializedSize *int32                        `json:"nonContiguousDeletedMessagesRangesSerializedSize,omitempty"`
	OffloadedStorageSize                             *int64                        `json:"offloadedStorageSize,omitempty"`
	OwnerBroker                                      *string                       `json:"ownerBroker,omitempty"`
	Publishers                                       *[]PublisherStats             `json:"publishers,omitempty"`
	Replication                                      *map[string]ReplicatorStats   `json:"replication,omitempty"`
	StorageSize                                      *int64                        `json:"storageSize,omitempty"`
	Subscriptions                                    *map[string]SubscriptionStats `json:"subscriptions,omitempty"`
	TopicEpoch                                       *int64                        `json:"topicEpoch,omitempty"`
	WaitingPublishers                                *int32                        `json:"waitingPublishers,omitempty"`
}

// WorkerConfig defines model for WorkerConfig.
type WorkerConfig struct {
	AdditionalJavaRuntimeArguments               *[]string                          `json:"additionalJavaRuntimeArguments,omitempty"`
	AssignmentWriteMaxRetries                    *int32                             `json:"assignmentWriteMaxRetries,omitempty"`
	AuthenticateMetricsEndpoint                  *bool                              `json:"authenticateMetricsEndpoint,omitempty"`
	AuthenticationEnabled                        *bool                              `json:"authenticationEnabled,omitempty"`
	AuthenticationProviders                      *[]string                          `json:"authenticationProviders,omitempty"`
	AuthorizationEnabled                         *bool                              `json:"authorizationEnabled,omitempty"`
	AuthorizationProvider                        *string                            `json:"authorizationProvider,omitempty"`
	BookkeeperClientAuthenticationParameters     *string                            `json:"bookkeeperClientAuthenticationParameters,omitempty"`
	BookkeeperClientAuthenticationParametersName *string                            `json:"bookkeeperClientAuthenticationParametersName,omitempty"`
	BookkeeperClientAuthenticationPlugin         *string                            `json:"bookkeeperClientAuthenticationPlugin,omitempty"`
	BrokerClientAuthenticationEnabled            *bool                              `json:"brokerClientAuthenticationEnabled,omitempty"`
	BrokerClientAuthenticationParameters         *string                            `json:"brokerClientAuthenticationParameters,omitempty"`
	BrokerClientAuthenticationPlugin             *string                            `json:"brokerClientAuthenticationPlugin,omitempty"`
	BrokerClientTrustCertsFilePath               *string                            `json:"brokerClientTrustCertsFilePath,omitempty"`
	ClientAuthenticationParameters               *string                            `json:"clientAuthenticationParameters,omitempty"`
	ClientAuthenticationPlugin                   *string                            `json:"clientAuthenticationPlugin,omitempty"`
	ClusterCoordinationTopic                     *string                            `json:"clusterCoordinationTopic,omitempty"`
	ClusterCoordinationTopicName                 *string                            `json:"clusterCoordinationTopicName,omitempty"`
	ConfigurationMetadataStoreUrl                *string                            `json:"configurationMetadataStoreUrl,omitempty"`
	ConfigurationStoreServers                    *string                            `json:"configurationStoreServers,omitempty"`
	ConnectorsDirectory                          *string                            `json:"connectorsDirectory,omitempty"`
	DownloadDirectory                            *string                            `json:"downloadDirectory,omitempty"`
	ExposeAdminClientEnabled                     *bool                              `json:"exposeAdminClientEnabled,omitempty"`
	FailureCheckFreqMs                           *int64                             `json:"failureCheckFreqMs,omitempty"`
	ForwardSourceMessageProperty                 *bool                              `json:"forwardSourceMessageProperty,omitempty"`
	FunctionAssignmentTopic                      *string                            `json:"functionAssignmentTopic,omitempty"`
	FunctionAssignmentTopicName                  *string                            `json:"functionAssignmentTopicName,omitempty"`
	FunctionAuthProviderClassName                *string                            `json:"functionAuthProviderClassName,omitempty"`
	FunctionInstanceMaxResources                 *Resources                         `json:"functionInstanceMaxResources,omitempty"`
	FunctionInstanceMinResources                 *Resources                         `json:"functionInstanceMinResources,omitempty"`
	FunctionInstanceResourceChangeInLockStep     *bool                              `json:"functionInstanceResourceChangeInLockStep,omitempty"`
	FunctionInstanceResourceGranularities        *Resources                         `json:"functionInstanceResourceGranularities,omitempty"`
	FunctionMetadataTopic                        *string                            `json:"functionMetadataTopic,omitempty"`
	FunctionMetadataTopicName                    *string                            `json:"functionMetadataTopicName,omitempty"`
	FunctionRuntimeFactoryClassName              *string                            `json:"functionRuntimeFactoryClassName,omitempty"`
	FunctionRuntimeFactoryConfigs                *map[string]map[string]interface{} `json:"functionRuntimeFactoryConfigs,omitempty"`
	FunctionWebServiceUrl                        *string                            `json:"functionWebServiceUrl,omitempty"`
	FunctionsDirectory                           *string                            `json:"functionsDirectory,omitempty"`
	FunctionsWorkerEnablePackageManagement       *bool                              `json:"functionsWorkerEnablePackageManagement,omitempty"`
	FunctionsWorkerServiceCustomConfigs          *map[string]map[string]interface{} `json:"functionsWorkerServiceCustomConfigs,omitempty"`
	FunctionsWorkerServiceNarPackage             *string                            `json:"functionsWorkerServiceNarPackage,omitempty"`
	HttpRequestsLimitEnabled                     *bool                              `json:"httpRequestsLimitEnabled,omitempty"`
	HttpRequestsMaxPerSecond                     *float64                           `json:"httpRequestsMaxPerSecond,omitempty"`
	HttpServerAcceptQueueSize                    *int32                             `json:"httpServerAcceptQueueSize,omitempty"`
	HttpServerThreadPoolQueueSize                *int32                             `json:"httpServerThreadPoolQueueSize,omitempty"`
	IgnoreUnknownConfigFields                    *bool                              `json:"ignoreUnknownConfigFields,omitempty"`
	IncludeStandardPrometheusMetrics             *bool                              `json:"includeStandardPrometheusMetrics,omitempty"`
	InitialBrokerReconnectMaxRetries             *int32                             `json:"initialBrokerReconnectMaxRetries,omitempty"`
	InitializedDlogMetadata                      *bool                              `json:"initializedDlogMetadata,omitempty"`
	InstanceLivenessCheckFreqMs                  *int64                             `json:"instanceLivenessCheckFreqMs,omitempty"`
	JvmGCMetricsLoggerClassName                  *string                            `json:"jvmGCMetricsLoggerClassName,omitempty"`
	KinitCommand                                 *string                            `json:"kinitCommand,omitempty"`
	KubernetesContainerFactory                   *KubernetesContainerFactory        `json:"kubernetesContainerFactory,omitempty"`
	MaxConcurrentHttpRequests                    *int32                             `json:"maxConcurrentHttpRequests,omitempty"`
	MaxHttpServerConnections                     *int32                             `json:"maxHttpServerConnections,omitempty"`
	MaxPendingAsyncRequests                      *int32                             `json:"maxPendingAsyncRequests,omitempty"`
	MetadataStoreAllowReadOnlyOperations         *bool                              `json:"metadataStoreAllowReadOnlyOperations,omitempty"`
	MetadataStoreCacheExpirySeconds              *int32                             `json:"metadataStoreCacheExpirySeconds,omitempty"`
	MetadataStoreOperationTimeoutSeconds         *int32                             `json:"metadataStoreOperationTimeoutSeconds,omitempty"`
	MetadataStoreSessionTimeoutMillis            *int64                             `json:"metadataStoreSessionTimeoutMillis,omitempty"`
	NarExtractionDirectory                       *string                            `json:"narExtractionDirectory,omitempty"`
	NumFunctionPackageReplicas                   *int32                             `json:"numFunctionPackageReplicas,omitempty"`
	NumHttpServerThreads                         *int32                             `json:"numHttpServerThreads,omitempty"`
	ProcessContainerFactory                      *ProcessContainerFactory           `json:"processContainerFactory,omitempty"`
	Properties                                   *map[string]string                 `json:"properties,omitempty"`
	ProxyRoles                                   *[]string                          `json:"proxyRoles,omitempty"`
	PulsarFunctionsCluster                       *string                            `json:"pulsarFunctionsCluster,omitempty"`
	PulsarFunctionsNamespace                     *string                            `json:"pulsarFunctionsNamespace,omitempty"`
	PulsarServiceUrl                             *string                            `json:"pulsarServiceUrl,omitempty"`
	PulsarWebServiceUrl                          *string                            `json:"pulsarWebServiceUrl,omitempty"`
	RebalanceCheckFreqSec                        *int64                             `json:"rebalanceCheckFreqSec,omitempty"`
	RescheduleTimeoutMs                          *int64                             `json:"rescheduleTimeoutMs,omitempty"`
	RuntimeCustomizerClassName                   *string                            `json:"runtimeCustomizerClassName,omitempty"`
	RuntimeCustomizerConfig                      *map[string]map[string]interface{} `json:"runtimeCustomizerConfig,omitempty"`
	SaslJaasClientAllowedIds                     *string                            `json:"saslJaasClientAllowedIds,omitempty"`
	SaslJaasServerRoleTokenSignerSecretPath      *string                            `json:"saslJaasServerRoleTokenSignerSecretPath,omitempty"`
	SaslJaasServerSectionName                    *string                            `json:"saslJaasServerSectionName,omitempty"`
	SchedulerClassName                           *string                            `json:"schedulerClassName,omitempty"`
	SecretsProviderConfiguratorClassName         *string                            `json:"secretsProviderConfiguratorClassName,omitempty"`
	SecretsProviderConfiguratorConfig            *map[string]string                 `json:"secretsProviderConfiguratorConfig,omitempty"`
	StateStorageProviderImplementation           *string                            `json:"stateStorageProviderImplementation,omitempty"`
	StateStorageServiceUrl                       *string                            `json:"stateStorageServiceUrl,omitempty"`
	SuperUserRoles                               *[]string                          `json:"superUserRoles,omitempty"`
	ThreadContainerFactory                       *ThreadContainerFactory            `json:"threadContainerFactory,omitempty"`
	TlsAllowInsecureConnection                   *bool                              `json:"tlsAllowInsecureConnection,omitempty"`
	TlsCertRefreshCheckDurationSec               *int64                             `json:"tlsCertRefreshCheckDurationSec,omitempty"`
	TlsCertificateFilePath                       *string                            `json:"tlsCertificateFilePath,omitempty"`
	TlsEnableHostnameVerification                *bool                              `json:"tlsEnableHostnameVerification,omitempty"`
	TlsEnabled                                   *bool                              `json:"tlsEnabled,omitempty"`
	TlsEnabledWithKeyStore                       *bool                              `json:"tlsEnabledWithKeyStore,omitempty"`
	TlsKeyFilePath                               *string                            `json:"tlsKeyFilePath,omitempty"`
	TlsKeyStore                                  *string                            `json:"tlsKeyStore,omitempty"`
	TlsKeyStorePassword                          *string                            `json:"tlsKeyStorePassword,omitempty"`
	TlsKeyStoreType                              *string                            `json:"tlsKeyStoreType,omitempty"`
	TlsProvider                                  *string                            `json:"tlsProvider,omitempty"`
	TlsRequireTrustedClientCertOnConnect         *bool                              `json:"tlsRequireTrustedClientCertOnConnect,omitempty"`
	TlsTrustCertsFilePath                        *string                            `json:"tlsTrustCertsFilePath,omitempty"`
	TlsTrustChainBytes                           *[][]byte                          `json:"tlsTrustChainBytes,omitempty"`
	TlsTrustStore                                *string                            `json:"tlsTrustStore,omitempty"`
	TlsTrustStorePassword                        *string                            `json:"tlsTrustStorePassword,omitempty"`
	TlsTrustStoreType                            *string                            `json:"tlsTrustStoreType,omitempty"`
	TopicCompactionFrequencySec                  *int64                             `json:"topicCompactionFrequencySec,omitempty"`
	UploadBuiltinSinksSources                    *bool                              `json:"uploadBuiltinSinksSources,omitempty"`
	UseCompactedMetadataTopic                    *bool                              `json:"useCompactedMetadataTopic,omitempty"`
	UseTls                                       *bool                              `json:"useTls,omitempty"`
	ValidateConnectorConfig                      *bool                              `json:"validateConnectorConfig,omitempty"`
	WebServiceTlsCiphers                         *[]string                          `json:"webServiceTlsCiphers,omitempty"`
	WebServiceTlsProtocols                       *[]string                          `json:"webServiceTlsProtocols,omitempty"`
	WorkerHostname                               *string                            `json:"workerHostname,omitempty"`
	WorkerId                                     *string                            `json:"workerId,omitempty"`
	WorkerListProbeIntervalSec                   *int32                             `json:"workerListProbeIntervalSec,omitempty"`
	WorkerPort                                   *int32                             `json:"workerPort,omitempty"`
	WorkerPortTls                                *int32                             `json:"workerPortTls,omitempty"`
	WorkerWebAddress                             *string                            `json:"workerWebAddress,omitempty"`
	WorkerWebAddressTls                          *string                            `json:"workerWebAddressTls,omitempty"`
	ZooKeeperAllowReadOnlyOperations             *bool                              `json:"zooKeeperAllowReadOnlyOperations,omitempty"`
	ZooKeeperCacheExpirySeconds                  *int32                             `json:"zooKeeperCacheExpirySeconds,omitempty"`
	ZooKeeperOperationTimeoutSeconds             *int32                             `json:"zooKeeperOperationTimeoutSeconds,omitempty"`
	ZooKeeperSessionTimeoutMillis                *int64                             `json:"zooKeeperSessionTimeoutMillis,omitempty"`
}

// WorkerFunctionInstanceStats defines model for WorkerFunctionInstanceStats.
type WorkerFunctionInstanceStats struct {
	Metrics *FunctionInstanceStatsData `json:"metrics,omitempty"`
	Name    *string                    `json:"name,omitempty"`
}

// WorkerInfo defines model for WorkerInfo.
type WorkerInfo struct {
	Port           *int32  `json:"port,omitempty"`
	WorkerHostname *string `json:"workerHostname,omitempty"`
	WorkerId       *string `json:"workerId,omitempty"`
}

// WorkerService defines model for WorkerService.
type WorkerService struct {
	Functions    *FunctionsWorkerService   `json:"functions,omitempty"`
	FunctionsV2  *FunctionsV2WorkerService `json:"functionsV2,omitempty"`
	Initialized  *bool                     `json:"initialized,omitempty"`
	Sinks        *SinksWorkerService       `json:"sinks,omitempty"`
	Sources      *SourcesWorkerService     `json:"sources,omitempty"`
	WorkerConfig *WorkerConfig             `json:"workerConfig,omitempty"`
	Workers      *WorkersWorkerService     `json:"workers,omitempty"`
}

// Workers defines model for Workers.
type Workers = map[string]interface{}

// WorkersWorkerService defines model for WorkersWorkerService.
type WorkersWorkerService = map[string]interface{}

// BookiesUpdateBookieRackInfoParams defines parameters for BookiesUpdateBookieRackInfo.
type BookiesUpdateBookieRackInfoParams struct {
	Group *string `form:"group,omitempty" json:"group,omitempty"`
}

// BrokersBaseHealthCheckParams defines parameters for BrokersBaseHealthCheck.
type BrokersBaseHealthCheckParams struct {
	TopicVersion *BrokersBaseHealthCheckParamsTopicVersion `form:"topicVersion,omitempty" json:"topicVersion,omitempty"`
}

// BrokersBaseHealthCheckParamsTopicVersion defines parameters for BrokersBaseHealthCheck.
type BrokersBaseHealthCheckParamsTopicVersion string

// BrokersBaseShutDownBrokerGracefullyParams defines parameters for BrokersBaseShutDownBrokerGracefully.
type BrokersBaseShutDownBrokerGracefullyParams struct {
	// MaxConcurrentUnloadPerSec if the value absent(value=0) means no concurrent limitation.
	MaxConcurrentUnloadPerSec *int32 `form:"maxConcurrentUnloadPerSec,omitempty" json:"maxConcurrentUnloadPerSec,omitempty"`
	ForcedTerminateTopic      *bool  `form:"forcedTerminateTopic,omitempty" json:"forcedTerminateTopic,omitempty"`
}

// ClustersBaseUpdateClusterMigrationParams defines parameters for ClustersBaseUpdateClusterMigration.
type ClustersBaseUpdateClusterMigrationParams struct {
	// Migrated Is cluster migrated
	Migrated bool `form:"migrated" json:"migrated"`
}

// NamespacesGetAntiAffinityNamespacesParams defines parameters for NamespacesGetAntiAffinityNamespaces.
type NamespacesGetAntiAffinityNamespacesParams struct {
	Tenant *string `form:"tenant,omitempty" json:"tenant,omitempty"`
}

// NamespacesDeleteNamespaceParams defines parameters for NamespacesDeleteNamespace.
type NamespacesDeleteNamespaceParams struct {
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NamespacesSetNamespaceAntiAffinityGroupJSONBody defines parameters for NamespacesSetNamespaceAntiAffinityGroup.
type NamespacesSetNamespaceAntiAffinityGroupJSONBody = string

// NamespacesRemoveBacklogQuotaParams defines parameters for NamespacesRemoveBacklogQuota.
type NamespacesRemoveBacklogQuotaParams struct {
	BacklogQuotaType *NamespacesRemoveBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// NamespacesRemoveBacklogQuotaParamsBacklogQuotaType defines parameters for NamespacesRemoveBacklogQuota.
type NamespacesRemoveBacklogQuotaParamsBacklogQuotaType string

// NamespacesSetBacklogQuotaParams defines parameters for NamespacesSetBacklogQuota.
type NamespacesSetBacklogQuotaParams struct {
	BacklogQuotaType *NamespacesSetBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// NamespacesSetBacklogQuotaParamsBacklogQuotaType defines parameters for NamespacesSetBacklogQuota.
type NamespacesSetBacklogQuotaParamsBacklogQuotaType string

// NamespacesClearNamespaceBacklogParams defines parameters for NamespacesClearNamespaceBacklog.
type NamespacesClearNamespaceBacklogParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NamespacesClearNamespaceBacklogForSubscriptionParams defines parameters for NamespacesClearNamespaceBacklogForSubscription.
type NamespacesClearNamespaceBacklogForSubscriptionParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NamespacesSetCompactionThresholdJSONBody defines parameters for NamespacesSetCompactionThreshold.
type NamespacesSetCompactionThresholdJSONBody = int64

// NamespacesModifyDeduplicationJSONBody defines parameters for NamespacesModifyDeduplication.
type NamespacesModifyDeduplicationJSONBody = bool

// NamespacesSetDeduplicationSnapshotIntervalJSONBody defines parameters for NamespacesSetDeduplicationSnapshotInterval.
type NamespacesSetDeduplicationSnapshotIntervalJSONBody = int32

// NamespacesModifyEncryptionRequiredJSONBody defines parameters for NamespacesModifyEncryptionRequired.
type NamespacesModifyEncryptionRequiredJSONBody = bool

// NamespacesSetIsAllowAutoUpdateSchemaJSONBody defines parameters for NamespacesSetIsAllowAutoUpdateSchema.
type NamespacesSetIsAllowAutoUpdateSchemaJSONBody = bool

// NamespacesSetMaxConsumersPerSubscriptionJSONBody defines parameters for NamespacesSetMaxConsumersPerSubscription.
type NamespacesSetMaxConsumersPerSubscriptionJSONBody = int32

// NamespacesSetMaxConsumersPerTopicJSONBody defines parameters for NamespacesSetMaxConsumersPerTopic.
type NamespacesSetMaxConsumersPerTopicJSONBody = int32

// NamespacesSetMaxProducersPerTopicJSONBody defines parameters for NamespacesSetMaxProducersPerTopic.
type NamespacesSetMaxProducersPerTopicJSONBody = int32

// NamespacesSetMaxSubscriptionsPerTopicJSONBody defines parameters for NamespacesSetMaxSubscriptionsPerTopic.
type NamespacesSetMaxSubscriptionsPerTopicJSONBody = int32

// NamespacesSetMaxTopicsPerNamespaceJSONBody defines parameters for NamespacesSetMaxTopicsPerNamespace.
type NamespacesSetMaxTopicsPerNamespaceJSONBody = int32

// NamespacesSetMaxUnackedMessagesPerConsumerJSONBody defines parameters for NamespacesSetMaxUnackedMessagesPerConsumer.
type NamespacesSetMaxUnackedMessagesPerConsumerJSONBody = int32

// NamespacesSetMaxUnackedMessagesPerSubscriptionJSONBody defines parameters for NamespacesSetMaxUnackedMessagesPerSubscription.
type NamespacesSetMaxUnackedMessagesPerSubscriptionJSONBody = int32

// NamespacesSetNamespaceMessageTTLJSONBody defines parameters for NamespacesSetNamespaceMessageTTL.
type NamespacesSetNamespaceMessageTTLJSONBody = int32

// NamespacesSetOffloadDeletionLagJSONBody defines parameters for NamespacesSetOffloadDeletionLag.
type NamespacesSetOffloadDeletionLagJSONBody = int64

// NamespacesSetOffloadThresholdJSONBody defines parameters for NamespacesSetOffloadThreshold.
type NamespacesSetOffloadThresholdJSONBody = int64

// NamespacesGrantPermissionOnNamespaceJSONBody defines parameters for NamespacesGrantPermissionOnNamespace.
type NamespacesGrantPermissionOnNamespaceJSONBody = []string

// NamespacesSetPropertiesJSONBody defines parameters for NamespacesSetProperties.
type NamespacesSetPropertiesJSONBody map[string]string

// NamespacesSetNamespaceReplicationClustersJSONBody defines parameters for NamespacesSetNamespaceReplicationClusters.
type NamespacesSetNamespaceReplicationClustersJSONBody = []string

// NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONBody defines parameters for NamespacesSetSchemaAutoUpdateCompatibilityStrategy.
type NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONBody = string

// NamespacesSetSchemaCompatibilityStrategyJSONBody defines parameters for NamespacesSetSchemaCompatibilityStrategy.
type NamespacesSetSchemaCompatibilityStrategyJSONBody = string

// NamespacesGetSchemaValidtionEnforcedParams defines parameters for NamespacesGetSchemaValidtionEnforced.
type NamespacesGetSchemaValidtionEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`
}

// NamespacesSetSchemaValidationEnforcedJSONBody defines parameters for NamespacesSetSchemaValidationEnforced.
type NamespacesSetSchemaValidationEnforcedJSONBody = bool

// NamespacesSetSubscriptionAuthModeJSONBody defines parameters for NamespacesSetSubscriptionAuthMode.
type NamespacesSetSubscriptionAuthModeJSONBody = string

// NamespacesSetSubscriptionExpirationTimeJSONBody defines parameters for NamespacesSetSubscriptionExpirationTime.
type NamespacesSetSubscriptionExpirationTimeJSONBody = int32

// NamespacesSetSubscriptionTypesEnabledJSONBody defines parameters for NamespacesSetSubscriptionTypesEnabled.
type NamespacesSetSubscriptionTypesEnabledJSONBody = []string

// NamespacesGetTopicsParams defines parameters for NamespacesGetTopics.
type NamespacesGetTopicsParams struct {
	Mode *NamespacesGetTopicsParamsMode `form:"mode,omitempty" json:"mode,omitempty"`

	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// NamespacesGetTopicsParamsMode defines parameters for NamespacesGetTopics.
type NamespacesGetTopicsParamsMode string

// NamespacesUnsubscribeNamespaceParams defines parameters for NamespacesUnsubscribeNamespace.
type NamespacesUnsubscribeNamespaceParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NamespacesDeleteNamespaceBundleParams defines parameters for NamespacesDeleteNamespaceBundle.
type NamespacesDeleteNamespaceBundleParams struct {
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NamespacesClearNamespaceBundleBacklogParams defines parameters for NamespacesClearNamespaceBundleBacklog.
type NamespacesClearNamespaceBundleBacklogParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NamespacesClearNamespaceBundleBacklogForSubscriptionParams defines parameters for NamespacesClearNamespaceBundleBacklogForSubscription.
type NamespacesClearNamespaceBundleBacklogForSubscriptionParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NamespacesSplitNamespaceBundleJSONBody defines parameters for NamespacesSplitNamespaceBundle.
type NamespacesSplitNamespaceBundleJSONBody = []int64

// NamespacesSplitNamespaceBundleParams defines parameters for NamespacesSplitNamespaceBundle.
type NamespacesSplitNamespaceBundleParams struct {
	Authoritative      *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Unload             *bool   `form:"unload,omitempty" json:"unload,omitempty"`
	SplitAlgorithmName *string `form:"splitAlgorithmName,omitempty" json:"splitAlgorithmName,omitempty"`
}

// NamespacesGetTopicHashPositionsParams defines parameters for NamespacesGetTopicHashPositions.
type NamespacesGetTopicHashPositionsParams struct {
	Topics *[]string `form:"topics,omitempty" json:"topics,omitempty"`
}

// NamespacesUnloadNamespaceBundleParams defines parameters for NamespacesUnloadNamespaceBundle.
type NamespacesUnloadNamespaceBundleParams struct {
	Authoritative     *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	DestinationBroker *string `form:"destinationBroker,omitempty" json:"destinationBroker,omitempty"`
}

// NamespacesUnsubscribeNamespaceBundleParams defines parameters for NamespacesUnsubscribeNamespaceBundle.
type NamespacesUnsubscribeNamespaceBundleParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetListParams defines parameters for NonPersistentTopicsGetList.
type NonPersistentTopicsGetListParams struct {
	// Bundle Specify the bundle name
	Bundle *string `form:"bundle,omitempty" json:"bundle,omitempty"`

	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// NonPersistentTopicsGetPartitionedTopicListParams defines parameters for NonPersistentTopicsGetPartitionedTopicList.
type NonPersistentTopicsGetPartitionedTopicListParams struct {
	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// NonPersistentTopicsDeleteTopicParams defines parameters for NonPersistentTopicsDeleteTopic.
type NonPersistentTopicsDeleteTopicParams struct {
	// Force Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsCreateNonPartitionedTopicParams defines parameters for NonPersistentTopicsCreateNonPartitionedTopic.
type NonPersistentTopicsCreateNonPartitionedTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsExpireMessagesForAllSubscriptionsParams defines parameters for NonPersistentTopicsExpireMessagesForAllSubscriptions.
type NonPersistentTopicsExpireMessagesForAllSubscriptionsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveAutoSubscriptionCreationParams defines parameters for NonPersistentTopicsRemoveAutoSubscriptionCreation.
type NonPersistentTopicsRemoveAutoSubscriptionCreationParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetAutoSubscriptionCreationParams defines parameters for NonPersistentTopicsGetAutoSubscriptionCreation.
type NonPersistentTopicsGetAutoSubscriptionCreationParams struct {
	Applied       *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetAutoSubscriptionCreationParams defines parameters for NonPersistentTopicsSetAutoSubscriptionCreation.
type NonPersistentTopicsSetAutoSubscriptionCreationParams struct {
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetBacklogParams defines parameters for NonPersistentTopicsGetBacklog.
type NonPersistentTopicsGetBacklogParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveBacklogQuotaParams defines parameters for NonPersistentTopicsRemoveBacklogQuota.
type NonPersistentTopicsRemoveBacklogQuotaParams struct {
	BacklogQuotaType *NonPersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType defines parameters for NonPersistentTopicsRemoveBacklogQuota.
type NonPersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType string

// NonPersistentTopicsSetBacklogQuotaParams defines parameters for NonPersistentTopicsSetBacklogQuota.
type NonPersistentTopicsSetBacklogQuotaParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative    *bool                                                     `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal         *bool                                                     `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	BacklogQuotaType *NonPersistentTopicsSetBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// NonPersistentTopicsSetBacklogQuotaParamsBacklogQuotaType defines parameters for NonPersistentTopicsSetBacklogQuota.
type NonPersistentTopicsSetBacklogQuotaParamsBacklogQuotaType string

// NonPersistentTopicsGetBacklogQuotaMapParams defines parameters for NonPersistentTopicsGetBacklogQuotaMap.
type NonPersistentTopicsGetBacklogQuotaMapParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsGetBacklogSizeByMessageIdParams defines parameters for NonPersistentTopicsGetBacklogSizeByMessageId.
type NonPersistentTopicsGetBacklogSizeByMessageIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsCompactionStatusParams defines parameters for NonPersistentTopicsCompactionStatus.
type NonPersistentTopicsCompactionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsCompactParams defines parameters for NonPersistentTopicsCompact.
type NonPersistentTopicsCompactParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveCompactionThresholdParams defines parameters for NonPersistentTopicsRemoveCompactionThreshold.
type NonPersistentTopicsRemoveCompactionThresholdParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetCompactionThresholdParams defines parameters for NonPersistentTopicsGetCompactionThreshold.
type NonPersistentTopicsGetCompactionThresholdParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetCompactionThresholdParams defines parameters for NonPersistentTopicsSetCompactionThreshold.
type NonPersistentTopicsSetCompactionThresholdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsRemoveDeduplicationParams defines parameters for NonPersistentTopicsRemoveDeduplication.
type NonPersistentTopicsRemoveDeduplicationParams struct {
	// IsGlobal Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetDeduplicationParams defines parameters for NonPersistentTopicsGetDeduplication.
type NonPersistentTopicsGetDeduplicationParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetDeduplicationParams defines parameters for NonPersistentTopicsSetDeduplication.
type NonPersistentTopicsSetDeduplicationParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsDeleteDeduplicationSnapshotIntervalParams defines parameters for NonPersistentTopicsDeleteDeduplicationSnapshotInterval.
type NonPersistentTopicsDeleteDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetDeduplicationSnapshotIntervalParams defines parameters for NonPersistentTopicsGetDeduplicationSnapshotInterval.
type NonPersistentTopicsGetDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetDeduplicationSnapshotIntervalParams defines parameters for NonPersistentTopicsSetDeduplicationSnapshotInterval.
type NonPersistentTopicsSetDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsDeleteDelayedDeliveryPoliciesParams defines parameters for NonPersistentTopicsDeleteDelayedDeliveryPolicies.
type NonPersistentTopicsDeleteDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetDelayedDeliveryPoliciesParams defines parameters for NonPersistentTopicsGetDelayedDeliveryPolicies.
type NonPersistentTopicsGetDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetDelayedDeliveryPoliciesParams defines parameters for NonPersistentTopicsSetDelayedDeliveryPolicies.
type NonPersistentTopicsSetDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveDispatchRateParams defines parameters for NonPersistentTopicsRemoveDispatchRate.
type NonPersistentTopicsRemoveDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetDispatchRateParams defines parameters for NonPersistentTopicsGetDispatchRate.
type NonPersistentTopicsGetDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetDispatchRateParams defines parameters for NonPersistentTopicsSetDispatchRate.
type NonPersistentTopicsSetDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsRemoveEntryFiltersParams defines parameters for NonPersistentTopicsRemoveEntryFilters.
type NonPersistentTopicsRemoveEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetEntryFiltersParams defines parameters for NonPersistentTopicsGetEntryFilters.
type NonPersistentTopicsGetEntryFiltersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetEntryFiltersParams defines parameters for NonPersistentTopicsSetEntryFilters.
type NonPersistentTopicsSetEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsExamineMessageParams defines parameters for NonPersistentTopicsExamineMessage.
type NonPersistentTopicsExamineMessageParams struct {
	// InitialPosition Relative start position to examine message.It can be 'latest' or 'earliest'
	InitialPosition *NonPersistentTopicsExamineMessageParamsInitialPosition `form:"initialPosition,omitempty" json:"initialPosition,omitempty"`

	// MessagePosition The position of messages (default 1)
	MessagePosition *int64 `form:"messagePosition,omitempty" json:"messagePosition,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsExamineMessageParamsInitialPosition defines parameters for NonPersistentTopicsExamineMessage.
type NonPersistentTopicsExamineMessageParamsInitialPosition string

// NonPersistentTopicsDeleteInactiveTopicPoliciesParams defines parameters for NonPersistentTopicsDeleteInactiveTopicPolicies.
type NonPersistentTopicsDeleteInactiveTopicPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetInactiveTopicPoliciesParams defines parameters for NonPersistentTopicsGetInactiveTopicPolicies.
type NonPersistentTopicsGetInactiveTopicPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetInactiveTopicPoliciesParams defines parameters for NonPersistentTopicsSetInactiveTopicPolicies.
type NonPersistentTopicsSetInactiveTopicPoliciesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsGetManagedLedgerInfoParams defines parameters for NonPersistentTopicsGetManagedLedgerInfo.
type NonPersistentTopicsGetManagedLedgerInfoParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetInternalStatsParams defines parameters for NonPersistentTopicsGetInternalStats.
type NonPersistentTopicsGetInternalStatsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Metadata      *bool `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// NonPersistentTopicsGetLastMessageIdParams defines parameters for NonPersistentTopicsGetLastMessageId.
type NonPersistentTopicsGetLastMessageIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMessageByIdParams defines parameters for NonPersistentTopicsGetMessageById.
type NonPersistentTopicsGetMessageByIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveMaxConsumersParams defines parameters for NonPersistentTopicsRemoveMaxConsumers.
type NonPersistentTopicsRemoveMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMaxConsumersParams defines parameters for NonPersistentTopicsGetMaxConsumers.
type NonPersistentTopicsGetMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetMaxConsumersParams defines parameters for NonPersistentTopicsSetMaxConsumers.
type NonPersistentTopicsSetMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveMaxConsumersPerSubscriptionParams defines parameters for NonPersistentTopicsRemoveMaxConsumersPerSubscription.
type NonPersistentTopicsRemoveMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMaxConsumersPerSubscriptionParams defines parameters for NonPersistentTopicsGetMaxConsumersPerSubscription.
type NonPersistentTopicsGetMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetMaxConsumersPerSubscriptionParams defines parameters for NonPersistentTopicsSetMaxConsumersPerSubscription.
type NonPersistentTopicsSetMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveMaxMessageSizeParams defines parameters for NonPersistentTopicsRemoveMaxMessageSize.
type NonPersistentTopicsRemoveMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMaxMessageSizeParams defines parameters for NonPersistentTopicsGetMaxMessageSize.
type NonPersistentTopicsGetMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetMaxMessageSizeParams defines parameters for NonPersistentTopicsSetMaxMessageSize.
type NonPersistentTopicsSetMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveMaxProducersParams defines parameters for NonPersistentTopicsRemoveMaxProducers.
type NonPersistentTopicsRemoveMaxProducersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMaxProducersParams defines parameters for NonPersistentTopicsGetMaxProducers.
type NonPersistentTopicsGetMaxProducersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetMaxProducersParams defines parameters for NonPersistentTopicsSetMaxProducers.
type NonPersistentTopicsSetMaxProducersParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsRemoveMaxSubscriptionsPerTopicParams defines parameters for NonPersistentTopicsRemoveMaxSubscriptionsPerTopic.
type NonPersistentTopicsRemoveMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMaxSubscriptionsPerTopicParams defines parameters for NonPersistentTopicsGetMaxSubscriptionsPerTopic.
type NonPersistentTopicsGetMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetMaxSubscriptionsPerTopicParams defines parameters for NonPersistentTopicsSetMaxSubscriptionsPerTopic.
type NonPersistentTopicsSetMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams defines parameters for NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumer.
type NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMaxUnackedMessagesOnConsumerParams defines parameters for NonPersistentTopicsGetMaxUnackedMessagesOnConsumer.
type NonPersistentTopicsGetMaxUnackedMessagesOnConsumerParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetMaxUnackedMessagesOnConsumerParams defines parameters for NonPersistentTopicsSetMaxUnackedMessagesOnConsumer.
type NonPersistentTopicsSetMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams defines parameters for NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscription.
type NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams defines parameters for NonPersistentTopicsGetMaxUnackedMessagesOnSubscription.
type NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams defines parameters for NonPersistentTopicsSetMaxUnackedMessagesOnSubscription.
type NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveMessageTTLParams defines parameters for NonPersistentTopicsRemoveMessageTTL.
type NonPersistentTopicsRemoveMessageTTLParams struct {
	// IsGlobal Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMessageTTLParams defines parameters for NonPersistentTopicsGetMessageTTL.
type NonPersistentTopicsGetMessageTTLParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetMessageTTLParams defines parameters for NonPersistentTopicsSetMessageTTL.
type NonPersistentTopicsSetMessageTTLParams struct {
	// MessageTTL TTL in seconds for the specified topic
	MessageTTL int32 `form:"messageTTL" json:"messageTTL"`
	IsGlobal   *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetMessageIdByTimestampParams defines parameters for NonPersistentTopicsGetMessageIdByTimestamp.
type NonPersistentTopicsGetMessageIdByTimestampParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsOffloadStatusParams defines parameters for NonPersistentTopicsOffloadStatus.
type NonPersistentTopicsOffloadStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsTriggerOffloadParams defines parameters for NonPersistentTopicsTriggerOffload.
type NonPersistentTopicsTriggerOffloadParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveOffloadPoliciesParams defines parameters for NonPersistentTopicsRemoveOffloadPolicies.
type NonPersistentTopicsRemoveOffloadPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetOffloadPoliciesParams defines parameters for NonPersistentTopicsGetOffloadPolicies.
type NonPersistentTopicsGetOffloadPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetOffloadPoliciesParams defines parameters for NonPersistentTopicsSetOffloadPolicies.
type NonPersistentTopicsSetOffloadPoliciesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsGetPartitionedStatsInternalParams defines parameters for NonPersistentTopicsGetPartitionedStatsInternal.
type NonPersistentTopicsGetPartitionedStatsInternalParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetPartitionedStatsParams defines parameters for NonPersistentTopicsGetPartitionedStats.
type NonPersistentTopicsGetPartitionedStatsParams struct {
	// PerPartition Get per partition stats
	PerPartition *bool `form:"perPartition,omitempty" json:"perPartition,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// GetPreciseBacklog If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// SubscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// GetEarliestTimeInBacklog If return the earliest time in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// NonPersistentTopicsDeletePartitionedTopicParams defines parameters for NonPersistentTopicsDeletePartitionedTopic.
type NonPersistentTopicsDeletePartitionedTopicParams struct {
	// Force Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetPartitionedMetadataParams defines parameters for NonPersistentTopicsGetPartitionedMetadata.
type NonPersistentTopicsGetPartitionedMetadataParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// CheckAllowAutoCreation Is check configuration required to automatically create topic
	CheckAllowAutoCreation *bool `form:"checkAllowAutoCreation,omitempty" json:"checkAllowAutoCreation,omitempty"`
}

// NonPersistentTopicsUpdatePartitionedTopicParams defines parameters for NonPersistentTopicsUpdatePartitionedTopic.
type NonPersistentTopicsUpdatePartitionedTopicParams struct {
	UpdateLocalTopicOnly *bool `form:"updateLocalTopicOnly,omitempty" json:"updateLocalTopicOnly,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// NonPersistentTopicsCreatePartitionedTopicParams defines parameters for NonPersistentTopicsCreatePartitionedTopic.
type NonPersistentTopicsCreatePartitionedTopicParams struct {
	CreateLocalTopicOnly *bool `form:"createLocalTopicOnly,omitempty" json:"createLocalTopicOnly,omitempty"`
}

// NonPersistentTopicsRemovePersistenceParams defines parameters for NonPersistentTopicsRemovePersistence.
type NonPersistentTopicsRemovePersistenceParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetPersistenceParams defines parameters for NonPersistentTopicsGetPersistence.
type NonPersistentTopicsGetPersistenceParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetPersistenceParams defines parameters for NonPersistentTopicsSetPersistence.
type NonPersistentTopicsSetPersistenceParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsRemovePropertiesParams defines parameters for NonPersistentTopicsRemoveProperties.
type NonPersistentTopicsRemovePropertiesParams struct {
	Key           *string `form:"key,omitempty" json:"key,omitempty"`
	Authoritative *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetPropertiesParams defines parameters for NonPersistentTopicsGetProperties.
type NonPersistentTopicsGetPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsUpdatePropertiesParams defines parameters for NonPersistentTopicsUpdateProperties.
type NonPersistentTopicsUpdatePropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemovePublishRateParams defines parameters for NonPersistentTopicsRemovePublishRate.
type NonPersistentTopicsRemovePublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetPublishRateParams defines parameters for NonPersistentTopicsGetPublishRate.
type NonPersistentTopicsGetPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetPublishRateParams defines parameters for NonPersistentTopicsSetPublishRate.
type NonPersistentTopicsSetPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveReplicationClustersParams defines parameters for NonPersistentTopicsRemoveReplicationClusters.
type NonPersistentTopicsRemoveReplicationClustersParams struct {
	BacklogQuotaType *NonPersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType defines parameters for NonPersistentTopicsRemoveReplicationClusters.
type NonPersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType string

// NonPersistentTopicsGetReplicationClustersParams defines parameters for NonPersistentTopicsGetReplicationClusters.
type NonPersistentTopicsGetReplicationClustersParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetReplicationClustersParams defines parameters for NonPersistentTopicsSetReplicationClusters.
type NonPersistentTopicsSetReplicationClustersParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveReplicatorDispatchRateParams defines parameters for NonPersistentTopicsRemoveReplicatorDispatchRate.
type NonPersistentTopicsRemoveReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetReplicatorDispatchRateParams defines parameters for NonPersistentTopicsGetReplicatorDispatchRate.
type NonPersistentTopicsGetReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetReplicatorDispatchRateParams defines parameters for NonPersistentTopicsSetReplicatorDispatchRate.
type NonPersistentTopicsSetReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveRetentionParams defines parameters for NonPersistentTopicsRemoveRetention.
type NonPersistentTopicsRemoveRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetRetentionParams defines parameters for NonPersistentTopicsGetRetention.
type NonPersistentTopicsGetRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetRetentionParams defines parameters for NonPersistentTopicsSetRetention.
type NonPersistentTopicsSetRetentionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsRemoveSchemaCompatibilityStrategyParams defines parameters for NonPersistentTopicsRemoveSchemaCompatibilityStrategy.
type NonPersistentTopicsRemoveSchemaCompatibilityStrategyParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetSchemaCompatibilityStrategyParams defines parameters for NonPersistentTopicsGetSchemaCompatibilityStrategy.
type NonPersistentTopicsGetSchemaCompatibilityStrategyParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetSchemaCompatibilityStrategyParams defines parameters for NonPersistentTopicsSetSchemaCompatibilityStrategy.
type NonPersistentTopicsSetSchemaCompatibilityStrategyParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetSchemaValidationEnforcedParams defines parameters for NonPersistentTopicsGetSchemaValidationEnforced.
type NonPersistentTopicsGetSchemaValidationEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetSchemaValidationEnforcedParams defines parameters for NonPersistentTopicsSetSchemaValidationEnforced.
type NonPersistentTopicsSetSchemaValidationEnforcedParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsDeleteShadowTopicsParams defines parameters for NonPersistentTopicsDeleteShadowTopics.
type NonPersistentTopicsDeleteShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetShadowTopicsParams defines parameters for NonPersistentTopicsGetShadowTopics.
type NonPersistentTopicsGetShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetShadowTopicsParams defines parameters for NonPersistentTopicsSetShadowTopics.
type NonPersistentTopicsSetShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetStatsParams defines parameters for NonPersistentTopicsGetStats.
type NonPersistentTopicsGetStatsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// GetPreciseBacklog If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// SubscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// GetEarliestTimeInBacklog If return time of the earliest message in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// NonPersistentTopicsRemoveSubscribeRateParams defines parameters for NonPersistentTopicsRemoveSubscribeRate.
type NonPersistentTopicsRemoveSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetSubscribeRateParams defines parameters for NonPersistentTopicsGetSubscribeRate.
type NonPersistentTopicsGetSubscribeRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetSubscribeRateParams defines parameters for NonPersistentTopicsSetSubscribeRate.
type NonPersistentTopicsSetSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsDeleteSubscriptionParams defines parameters for NonPersistentTopicsDeleteSubscription.
type NonPersistentTopicsDeleteSubscriptionParams struct {
	// Force Disconnect and close all consumers and delete subscription forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsAnalyzeSubscriptionBacklogParams defines parameters for NonPersistentTopicsAnalyzeSubscriptionBacklog.
type NonPersistentTopicsAnalyzeSubscriptionBacklogParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsExpireTopicMessagesParams defines parameters for NonPersistentTopicsExpireTopicMessages.
type NonPersistentTopicsExpireTopicMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsExpireTopicMessagesExpireTimeParams defines parameters for NonPersistentTopicsExpireTopicMessagesExpireTime.
type NonPersistentTopicsExpireTopicMessagesExpireTimeParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsPeekNthMessageParams defines parameters for NonPersistentTopicsPeekNthMessage.
type NonPersistentTopicsPeekNthMessageParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetSubscriptionPropertiesParams defines parameters for NonPersistentTopicsGetSubscriptionProperties.
type NonPersistentTopicsGetSubscriptionPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsUpdateSubscriptionPropertiesParams defines parameters for NonPersistentTopicsUpdateSubscriptionProperties.
type NonPersistentTopicsUpdateSubscriptionPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetReplicatedSubscriptionStatusParams defines parameters for NonPersistentTopicsGetReplicatedSubscriptionStatus.
type NonPersistentTopicsGetReplicatedSubscriptionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetReplicatedSubscriptionStatusParams defines parameters for NonPersistentTopicsSetReplicatedSubscriptionStatus.
type NonPersistentTopicsSetReplicatedSubscriptionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsResetCursorOnPositionParams defines parameters for NonPersistentTopicsResetCursorOnPosition.
type NonPersistentTopicsResetCursorOnPositionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsResetCursorParams defines parameters for NonPersistentTopicsResetCursor.
type NonPersistentTopicsResetCursorParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSkipMessagesParams defines parameters for NonPersistentTopicsSkipMessages.
type NonPersistentTopicsSkipMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSkipAllMessagesParams defines parameters for NonPersistentTopicsSkipAllMessages.
type NonPersistentTopicsSkipAllMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsCreateSubscriptionParams defines parameters for NonPersistentTopicsCreateSubscription.
type NonPersistentTopicsCreateSubscriptionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// Replicated Is replicated required to perform this operation
	Replicated *bool `form:"replicated,omitempty" json:"replicated,omitempty"`
}

// NonPersistentTopicsRemoveSubscriptionDispatchRateParams defines parameters for NonPersistentTopicsRemoveSubscriptionDispatchRate.
type NonPersistentTopicsRemoveSubscriptionDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetSubscriptionDispatchRateParams defines parameters for NonPersistentTopicsGetSubscriptionDispatchRate.
type NonPersistentTopicsGetSubscriptionDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetSubscriptionDispatchRateParams defines parameters for NonPersistentTopicsSetSubscriptionDispatchRate.
type NonPersistentTopicsSetSubscriptionDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// NonPersistentTopicsRemoveSubscriptionTypesEnabledParams defines parameters for NonPersistentTopicsRemoveSubscriptionTypesEnabled.
type NonPersistentTopicsRemoveSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetSubscriptionTypesEnabledParams defines parameters for NonPersistentTopicsGetSubscriptionTypesEnabled.
type NonPersistentTopicsGetSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetSubscriptionTypesEnabledParams defines parameters for NonPersistentTopicsSetSubscriptionTypesEnabled.
type NonPersistentTopicsSetSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetSubscriptionsParams defines parameters for NonPersistentTopicsGetSubscriptions.
type NonPersistentTopicsGetSubscriptionsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsTerminateParams defines parameters for NonPersistentTopicsTerminate.
type NonPersistentTopicsTerminateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsTerminatePartitionedTopicParams defines parameters for NonPersistentTopicsTerminatePartitionedTopic.
type NonPersistentTopicsTerminatePartitionedTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsTrimTopicParams defines parameters for NonPersistentTopicsTrimTopic.
type NonPersistentTopicsTrimTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsTruncateTopicParams defines parameters for NonPersistentTopicsTruncateTopic.
type NonPersistentTopicsTruncateTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsUnloadTopicParams defines parameters for NonPersistentTopicsUnloadTopic.
type NonPersistentTopicsUnloadTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsRemoveSubscriptionLevelDispatchRateParams defines parameters for NonPersistentTopicsRemoveSubscriptionLevelDispatchRate.
type NonPersistentTopicsRemoveSubscriptionLevelDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsGetSubscriptionLevelDispatchRateParams defines parameters for NonPersistentTopicsGetSubscriptionLevelDispatchRate.
type NonPersistentTopicsGetSubscriptionLevelDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// NonPersistentTopicsSetSubscriptionLevelDispatchRateParams defines parameters for NonPersistentTopicsSetSubscriptionLevelDispatchRate.
type NonPersistentTopicsSetSubscriptionLevelDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsGetListParams defines parameters for PersistentTopicsGetList.
type PersistentTopicsGetListParams struct {
	// Bundle Specify the bundle name
	Bundle *string `form:"bundle,omitempty" json:"bundle,omitempty"`

	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// PersistentTopicsGetPartitionedTopicListParams defines parameters for PersistentTopicsGetPartitionedTopicList.
type PersistentTopicsGetPartitionedTopicListParams struct {
	// IncludeSystemTopic Include system topic
	IncludeSystemTopic *bool `form:"includeSystemTopic,omitempty" json:"includeSystemTopic,omitempty"`
}

// PersistentTopicsDeleteTopicParams defines parameters for PersistentTopicsDeleteTopic.
type PersistentTopicsDeleteTopicParams struct {
	// Force Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsCreateNonPartitionedTopicParams defines parameters for PersistentTopicsCreateNonPartitionedTopic.
type PersistentTopicsCreateNonPartitionedTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsExpireMessagesForAllSubscriptionsParams defines parameters for PersistentTopicsExpireMessagesForAllSubscriptions.
type PersistentTopicsExpireMessagesForAllSubscriptionsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveAutoSubscriptionCreationParams defines parameters for PersistentTopicsRemoveAutoSubscriptionCreation.
type PersistentTopicsRemoveAutoSubscriptionCreationParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetAutoSubscriptionCreationParams defines parameters for PersistentTopicsGetAutoSubscriptionCreation.
type PersistentTopicsGetAutoSubscriptionCreationParams struct {
	Applied       *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetAutoSubscriptionCreationParams defines parameters for PersistentTopicsSetAutoSubscriptionCreation.
type PersistentTopicsSetAutoSubscriptionCreationParams struct {
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetBacklogParams defines parameters for PersistentTopicsGetBacklog.
type PersistentTopicsGetBacklogParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveBacklogQuotaParams defines parameters for PersistentTopicsRemoveBacklogQuota.
type PersistentTopicsRemoveBacklogQuotaParams struct {
	BacklogQuotaType *PersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType defines parameters for PersistentTopicsRemoveBacklogQuota.
type PersistentTopicsRemoveBacklogQuotaParamsBacklogQuotaType string

// PersistentTopicsSetBacklogQuotaParams defines parameters for PersistentTopicsSetBacklogQuota.
type PersistentTopicsSetBacklogQuotaParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative    *bool                                                  `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal         *bool                                                  `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	BacklogQuotaType *PersistentTopicsSetBacklogQuotaParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`
}

// PersistentTopicsSetBacklogQuotaParamsBacklogQuotaType defines parameters for PersistentTopicsSetBacklogQuota.
type PersistentTopicsSetBacklogQuotaParamsBacklogQuotaType string

// PersistentTopicsGetBacklogQuotaMapParams defines parameters for PersistentTopicsGetBacklogQuotaMap.
type PersistentTopicsGetBacklogQuotaMapParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsGetBacklogSizeByMessageIdParams defines parameters for PersistentTopicsGetBacklogSizeByMessageId.
type PersistentTopicsGetBacklogSizeByMessageIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsCompactionStatusParams defines parameters for PersistentTopicsCompactionStatus.
type PersistentTopicsCompactionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsCompactParams defines parameters for PersistentTopicsCompact.
type PersistentTopicsCompactParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveCompactionThresholdParams defines parameters for PersistentTopicsRemoveCompactionThreshold.
type PersistentTopicsRemoveCompactionThresholdParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetCompactionThresholdParams defines parameters for PersistentTopicsGetCompactionThreshold.
type PersistentTopicsGetCompactionThresholdParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetCompactionThresholdParams defines parameters for PersistentTopicsSetCompactionThreshold.
type PersistentTopicsSetCompactionThresholdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsRemoveDeduplicationParams defines parameters for PersistentTopicsRemoveDeduplication.
type PersistentTopicsRemoveDeduplicationParams struct {
	// IsGlobal Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetDeduplicationParams defines parameters for PersistentTopicsGetDeduplication.
type PersistentTopicsGetDeduplicationParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetDeduplicationParams defines parameters for PersistentTopicsSetDeduplication.
type PersistentTopicsSetDeduplicationParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsDeleteDeduplicationSnapshotIntervalParams defines parameters for PersistentTopicsDeleteDeduplicationSnapshotInterval.
type PersistentTopicsDeleteDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetDeduplicationSnapshotIntervalParams defines parameters for PersistentTopicsGetDeduplicationSnapshotInterval.
type PersistentTopicsGetDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetDeduplicationSnapshotIntervalParams defines parameters for PersistentTopicsSetDeduplicationSnapshotInterval.
type PersistentTopicsSetDeduplicationSnapshotIntervalParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsDeleteDelayedDeliveryPoliciesParams defines parameters for PersistentTopicsDeleteDelayedDeliveryPolicies.
type PersistentTopicsDeleteDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetDelayedDeliveryPoliciesParams defines parameters for PersistentTopicsGetDelayedDeliveryPolicies.
type PersistentTopicsGetDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetDelayedDeliveryPoliciesParams defines parameters for PersistentTopicsSetDelayedDeliveryPolicies.
type PersistentTopicsSetDelayedDeliveryPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveDispatchRateParams defines parameters for PersistentTopicsRemoveDispatchRate.
type PersistentTopicsRemoveDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetDispatchRateParams defines parameters for PersistentTopicsGetDispatchRate.
type PersistentTopicsGetDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetDispatchRateParams defines parameters for PersistentTopicsSetDispatchRate.
type PersistentTopicsSetDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsRemoveEntryFiltersParams defines parameters for PersistentTopicsRemoveEntryFilters.
type PersistentTopicsRemoveEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetEntryFiltersParams defines parameters for PersistentTopicsGetEntryFilters.
type PersistentTopicsGetEntryFiltersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetEntryFiltersParams defines parameters for PersistentTopicsSetEntryFilters.
type PersistentTopicsSetEntryFiltersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected thiscall to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsExamineMessageParams defines parameters for PersistentTopicsExamineMessage.
type PersistentTopicsExamineMessageParams struct {
	// InitialPosition Relative start position to examine message.It can be 'latest' or 'earliest'
	InitialPosition *PersistentTopicsExamineMessageParamsInitialPosition `form:"initialPosition,omitempty" json:"initialPosition,omitempty"`

	// MessagePosition The position of messages (default 1)
	MessagePosition *int64 `form:"messagePosition,omitempty" json:"messagePosition,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsExamineMessageParamsInitialPosition defines parameters for PersistentTopicsExamineMessage.
type PersistentTopicsExamineMessageParamsInitialPosition string

// PersistentTopicsDeleteInactiveTopicPoliciesParams defines parameters for PersistentTopicsDeleteInactiveTopicPolicies.
type PersistentTopicsDeleteInactiveTopicPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetInactiveTopicPoliciesParams defines parameters for PersistentTopicsGetInactiveTopicPolicies.
type PersistentTopicsGetInactiveTopicPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetInactiveTopicPoliciesParams defines parameters for PersistentTopicsSetInactiveTopicPolicies.
type PersistentTopicsSetInactiveTopicPoliciesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsGetManagedLedgerInfoParams defines parameters for PersistentTopicsGetManagedLedgerInfo.
type PersistentTopicsGetManagedLedgerInfoParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetInternalStatsParams defines parameters for PersistentTopicsGetInternalStats.
type PersistentTopicsGetInternalStatsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Metadata      *bool `form:"metadata,omitempty" json:"metadata,omitempty"`
}

// PersistentTopicsGetLastMessageIdParams defines parameters for PersistentTopicsGetLastMessageId.
type PersistentTopicsGetLastMessageIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMessageByIdParams defines parameters for PersistentTopicsGetMessageById.
type PersistentTopicsGetMessageByIdParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveMaxConsumersParams defines parameters for PersistentTopicsRemoveMaxConsumers.
type PersistentTopicsRemoveMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMaxConsumersParams defines parameters for PersistentTopicsGetMaxConsumers.
type PersistentTopicsGetMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetMaxConsumersParams defines parameters for PersistentTopicsSetMaxConsumers.
type PersistentTopicsSetMaxConsumersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveMaxConsumersPerSubscriptionParams defines parameters for PersistentTopicsRemoveMaxConsumersPerSubscription.
type PersistentTopicsRemoveMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMaxConsumersPerSubscriptionParams defines parameters for PersistentTopicsGetMaxConsumersPerSubscription.
type PersistentTopicsGetMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetMaxConsumersPerSubscriptionParams defines parameters for PersistentTopicsSetMaxConsumersPerSubscription.
type PersistentTopicsSetMaxConsumersPerSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveMaxMessageSizeParams defines parameters for PersistentTopicsRemoveMaxMessageSize.
type PersistentTopicsRemoveMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMaxMessageSizeParams defines parameters for PersistentTopicsGetMaxMessageSize.
type PersistentTopicsGetMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetMaxMessageSizeParams defines parameters for PersistentTopicsSetMaxMessageSize.
type PersistentTopicsSetMaxMessageSizeParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveMaxProducersParams defines parameters for PersistentTopicsRemoveMaxProducers.
type PersistentTopicsRemoveMaxProducersParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMaxProducersParams defines parameters for PersistentTopicsGetMaxProducers.
type PersistentTopicsGetMaxProducersParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetMaxProducersParams defines parameters for PersistentTopicsSetMaxProducers.
type PersistentTopicsSetMaxProducersParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsRemoveMaxSubscriptionsPerTopicParams defines parameters for PersistentTopicsRemoveMaxSubscriptionsPerTopic.
type PersistentTopicsRemoveMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMaxSubscriptionsPerTopicParams defines parameters for PersistentTopicsGetMaxSubscriptionsPerTopic.
type PersistentTopicsGetMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetMaxSubscriptionsPerTopicParams defines parameters for PersistentTopicsSetMaxSubscriptionsPerTopic.
type PersistentTopicsSetMaxSubscriptionsPerTopicParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams defines parameters for PersistentTopicsDeleteMaxUnackedMessagesOnConsumer.
type PersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMaxUnackedMessagesOnConsumerParams defines parameters for PersistentTopicsGetMaxUnackedMessagesOnConsumer.
type PersistentTopicsGetMaxUnackedMessagesOnConsumerParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetMaxUnackedMessagesOnConsumerParams defines parameters for PersistentTopicsSetMaxUnackedMessagesOnConsumer.
type PersistentTopicsSetMaxUnackedMessagesOnConsumerParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams defines parameters for PersistentTopicsDeleteMaxUnackedMessagesOnSubscription.
type PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams defines parameters for PersistentTopicsGetMaxUnackedMessagesOnSubscription.
type PersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams defines parameters for PersistentTopicsSetMaxUnackedMessagesOnSubscription.
type PersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveMessageTTLParams defines parameters for PersistentTopicsRemoveMessageTTL.
type PersistentTopicsRemoveMessageTTLParams struct {
	// IsGlobal Whether leader broker redirected this call to this broker. For internal use.
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMessageTTLParams defines parameters for PersistentTopicsGetMessageTTL.
type PersistentTopicsGetMessageTTLParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetMessageTTLParams defines parameters for PersistentTopicsSetMessageTTL.
type PersistentTopicsSetMessageTTLParams struct {
	// MessageTTL TTL in seconds for the specified topic
	MessageTTL int32 `form:"messageTTL" json:"messageTTL"`
	IsGlobal   *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetMessageIdByTimestampParams defines parameters for PersistentTopicsGetMessageIdByTimestamp.
type PersistentTopicsGetMessageIdByTimestampParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsOffloadStatusParams defines parameters for PersistentTopicsOffloadStatus.
type PersistentTopicsOffloadStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsTriggerOffloadParams defines parameters for PersistentTopicsTriggerOffload.
type PersistentTopicsTriggerOffloadParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveOffloadPoliciesParams defines parameters for PersistentTopicsRemoveOffloadPolicies.
type PersistentTopicsRemoveOffloadPoliciesParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetOffloadPoliciesParams defines parameters for PersistentTopicsGetOffloadPolicies.
type PersistentTopicsGetOffloadPoliciesParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetOffloadPoliciesParams defines parameters for PersistentTopicsSetOffloadPolicies.
type PersistentTopicsSetOffloadPoliciesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsGetPartitionedStatsInternalParams defines parameters for PersistentTopicsGetPartitionedStatsInternal.
type PersistentTopicsGetPartitionedStatsInternalParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetPartitionedStatsParams defines parameters for PersistentTopicsGetPartitionedStats.
type PersistentTopicsGetPartitionedStatsParams struct {
	// PerPartition Get per partition stats
	PerPartition *bool `form:"perPartition,omitempty" json:"perPartition,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// GetPreciseBacklog If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// SubscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// GetEarliestTimeInBacklog If return the earliest time in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// PersistentTopicsDeletePartitionedTopicParams defines parameters for PersistentTopicsDeletePartitionedTopic.
type PersistentTopicsDeletePartitionedTopicParams struct {
	// Force Stop all producer/consumer/replicator and delete topic forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetPartitionedMetadataParams defines parameters for PersistentTopicsGetPartitionedMetadata.
type PersistentTopicsGetPartitionedMetadataParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// CheckAllowAutoCreation Is check configuration required to automatically create topic
	CheckAllowAutoCreation *bool `form:"checkAllowAutoCreation,omitempty" json:"checkAllowAutoCreation,omitempty"`
}

// PersistentTopicsUpdatePartitionedTopicParams defines parameters for PersistentTopicsUpdatePartitionedTopic.
type PersistentTopicsUpdatePartitionedTopicParams struct {
	UpdateLocalTopicOnly *bool `form:"updateLocalTopicOnly,omitempty" json:"updateLocalTopicOnly,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// PersistentTopicsCreatePartitionedTopicParams defines parameters for PersistentTopicsCreatePartitionedTopic.
type PersistentTopicsCreatePartitionedTopicParams struct {
	CreateLocalTopicOnly *bool `form:"createLocalTopicOnly,omitempty" json:"createLocalTopicOnly,omitempty"`
}

// PersistentTopicsRemovePersistenceParams defines parameters for PersistentTopicsRemovePersistence.
type PersistentTopicsRemovePersistenceParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetPersistenceParams defines parameters for PersistentTopicsGetPersistence.
type PersistentTopicsGetPersistenceParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetPersistenceParams defines parameters for PersistentTopicsSetPersistence.
type PersistentTopicsSetPersistenceParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsRemovePropertiesParams defines parameters for PersistentTopicsRemoveProperties.
type PersistentTopicsRemovePropertiesParams struct {
	Key           *string `form:"key,omitempty" json:"key,omitempty"`
	Authoritative *bool   `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetPropertiesParams defines parameters for PersistentTopicsGetProperties.
type PersistentTopicsGetPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsUpdatePropertiesParams defines parameters for PersistentTopicsUpdateProperties.
type PersistentTopicsUpdatePropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemovePublishRateParams defines parameters for PersistentTopicsRemovePublishRate.
type PersistentTopicsRemovePublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetPublishRateParams defines parameters for PersistentTopicsGetPublishRate.
type PersistentTopicsGetPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetPublishRateParams defines parameters for PersistentTopicsSetPublishRate.
type PersistentTopicsSetPublishRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveReplicationClustersParams defines parameters for PersistentTopicsRemoveReplicationClusters.
type PersistentTopicsRemoveReplicationClustersParams struct {
	BacklogQuotaType *PersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType `form:"backlogQuotaType,omitempty" json:"backlogQuotaType,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType defines parameters for PersistentTopicsRemoveReplicationClusters.
type PersistentTopicsRemoveReplicationClustersParamsBacklogQuotaType string

// PersistentTopicsGetReplicationClustersParams defines parameters for PersistentTopicsGetReplicationClusters.
type PersistentTopicsGetReplicationClustersParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetReplicationClustersParams defines parameters for PersistentTopicsSetReplicationClusters.
type PersistentTopicsSetReplicationClustersParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveReplicatorDispatchRateParams defines parameters for PersistentTopicsRemoveReplicatorDispatchRate.
type PersistentTopicsRemoveReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetReplicatorDispatchRateParams defines parameters for PersistentTopicsGetReplicatorDispatchRate.
type PersistentTopicsGetReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetReplicatorDispatchRateParams defines parameters for PersistentTopicsSetReplicatorDispatchRate.
type PersistentTopicsSetReplicatorDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveRetentionParams defines parameters for PersistentTopicsRemoveRetention.
type PersistentTopicsRemoveRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetRetentionParams defines parameters for PersistentTopicsGetRetention.
type PersistentTopicsGetRetentionParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetRetentionParams defines parameters for PersistentTopicsSetRetention.
type PersistentTopicsSetRetentionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsRemoveSchemaCompatibilityStrategyParams defines parameters for PersistentTopicsRemoveSchemaCompatibilityStrategy.
type PersistentTopicsRemoveSchemaCompatibilityStrategyParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetSchemaCompatibilityStrategyParams defines parameters for PersistentTopicsGetSchemaCompatibilityStrategy.
type PersistentTopicsGetSchemaCompatibilityStrategyParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetSchemaCompatibilityStrategyParams defines parameters for PersistentTopicsSetSchemaCompatibilityStrategy.
type PersistentTopicsSetSchemaCompatibilityStrategyParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetSchemaValidationEnforcedParams defines parameters for PersistentTopicsGetSchemaValidationEnforced.
type PersistentTopicsGetSchemaValidationEnforcedParams struct {
	Applied *bool `form:"applied,omitempty" json:"applied,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetSchemaValidationEnforcedParams defines parameters for PersistentTopicsSetSchemaValidationEnforced.
type PersistentTopicsSetSchemaValidationEnforcedParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsDeleteShadowTopicsParams defines parameters for PersistentTopicsDeleteShadowTopics.
type PersistentTopicsDeleteShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetShadowTopicsParams defines parameters for PersistentTopicsGetShadowTopics.
type PersistentTopicsGetShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetShadowTopicsParams defines parameters for PersistentTopicsSetShadowTopics.
type PersistentTopicsSetShadowTopicsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetStatsParams defines parameters for PersistentTopicsGetStats.
type PersistentTopicsGetStatsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// GetPreciseBacklog If return precise backlog or imprecise backlog
	GetPreciseBacklog *bool `form:"getPreciseBacklog,omitempty" json:"getPreciseBacklog,omitempty"`

	// SubscriptionBacklogSize If return backlog size for each subscription, require locking on ledger so be careful not to use when there's heavy traffic.
	SubscriptionBacklogSize *bool `form:"subscriptionBacklogSize,omitempty" json:"subscriptionBacklogSize,omitempty"`

	// GetEarliestTimeInBacklog If return time of the earliest message in backlog
	GetEarliestTimeInBacklog *bool `form:"getEarliestTimeInBacklog,omitempty" json:"getEarliestTimeInBacklog,omitempty"`
}

// PersistentTopicsRemoveSubscribeRateParams defines parameters for PersistentTopicsRemoveSubscribeRate.
type PersistentTopicsRemoveSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetSubscribeRateParams defines parameters for PersistentTopicsGetSubscribeRate.
type PersistentTopicsGetSubscribeRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetSubscribeRateParams defines parameters for PersistentTopicsSetSubscribeRate.
type PersistentTopicsSetSubscribeRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsDeleteSubscriptionParams defines parameters for PersistentTopicsDeleteSubscription.
type PersistentTopicsDeleteSubscriptionParams struct {
	// Force Disconnect and close all consumers and delete subscription forcefully
	Force *bool `form:"force,omitempty" json:"force,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsAnalyzeSubscriptionBacklogParams defines parameters for PersistentTopicsAnalyzeSubscriptionBacklog.
type PersistentTopicsAnalyzeSubscriptionBacklogParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsExpireTopicMessagesParams defines parameters for PersistentTopicsExpireTopicMessages.
type PersistentTopicsExpireTopicMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsExpireTopicMessagesExpireTimeParams defines parameters for PersistentTopicsExpireTopicMessagesExpireTime.
type PersistentTopicsExpireTopicMessagesExpireTimeParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsPeekNthMessageParams defines parameters for PersistentTopicsPeekNthMessage.
type PersistentTopicsPeekNthMessageParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetSubscriptionPropertiesParams defines parameters for PersistentTopicsGetSubscriptionProperties.
type PersistentTopicsGetSubscriptionPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsUpdateSubscriptionPropertiesParams defines parameters for PersistentTopicsUpdateSubscriptionProperties.
type PersistentTopicsUpdateSubscriptionPropertiesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetReplicatedSubscriptionStatusParams defines parameters for PersistentTopicsGetReplicatedSubscriptionStatus.
type PersistentTopicsGetReplicatedSubscriptionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetReplicatedSubscriptionStatusParams defines parameters for PersistentTopicsSetReplicatedSubscriptionStatus.
type PersistentTopicsSetReplicatedSubscriptionStatusParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsResetCursorOnPositionParams defines parameters for PersistentTopicsResetCursorOnPosition.
type PersistentTopicsResetCursorOnPositionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsResetCursorParams defines parameters for PersistentTopicsResetCursor.
type PersistentTopicsResetCursorParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSkipMessagesParams defines parameters for PersistentTopicsSkipMessages.
type PersistentTopicsSkipMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSkipAllMessagesParams defines parameters for PersistentTopicsSkipAllMessages.
type PersistentTopicsSkipAllMessagesParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsCreateSubscriptionParams defines parameters for PersistentTopicsCreateSubscription.
type PersistentTopicsCreateSubscriptionParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`

	// Replicated Is replicated required to perform this operation
	Replicated *bool `form:"replicated,omitempty" json:"replicated,omitempty"`
}

// PersistentTopicsRemoveSubscriptionDispatchRateParams defines parameters for PersistentTopicsRemoveSubscriptionDispatchRate.
type PersistentTopicsRemoveSubscriptionDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetSubscriptionDispatchRateParams defines parameters for PersistentTopicsGetSubscriptionDispatchRate.
type PersistentTopicsGetSubscriptionDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetSubscriptionDispatchRateParams defines parameters for PersistentTopicsSetSubscriptionDispatchRate.
type PersistentTopicsSetSubscriptionDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// PersistentTopicsRemoveSubscriptionTypesEnabledParams defines parameters for PersistentTopicsRemoveSubscriptionTypesEnabled.
type PersistentTopicsRemoveSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetSubscriptionTypesEnabledParams defines parameters for PersistentTopicsGetSubscriptionTypesEnabled.
type PersistentTopicsGetSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetSubscriptionTypesEnabledParams defines parameters for PersistentTopicsSetSubscriptionTypesEnabled.
type PersistentTopicsSetSubscriptionTypesEnabledParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetSubscriptionsParams defines parameters for PersistentTopicsGetSubscriptions.
type PersistentTopicsGetSubscriptionsParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsTerminateParams defines parameters for PersistentTopicsTerminate.
type PersistentTopicsTerminateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsTerminatePartitionedTopicParams defines parameters for PersistentTopicsTerminatePartitionedTopic.
type PersistentTopicsTerminatePartitionedTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsTrimTopicParams defines parameters for PersistentTopicsTrimTopic.
type PersistentTopicsTrimTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsTruncateTopicParams defines parameters for PersistentTopicsTruncateTopic.
type PersistentTopicsTruncateTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsUnloadTopicParams defines parameters for PersistentTopicsUnloadTopic.
type PersistentTopicsUnloadTopicParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsRemoveSubscriptionLevelDispatchRateParams defines parameters for PersistentTopicsRemoveSubscriptionLevelDispatchRate.
type PersistentTopicsRemoveSubscriptionLevelDispatchRateParams struct {
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsGetSubscriptionLevelDispatchRateParams defines parameters for PersistentTopicsGetSubscriptionLevelDispatchRate.
type PersistentTopicsGetSubscriptionLevelDispatchRateParams struct {
	Applied  *bool `form:"applied,omitempty" json:"applied,omitempty"`
	IsGlobal *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`

	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// PersistentTopicsSetSubscriptionLevelDispatchRateParams defines parameters for PersistentTopicsSetSubscriptionLevelDispatchRate.
type PersistentTopicsSetSubscriptionLevelDispatchRateParams struct {
	// Authoritative Whether leader broker redirected this call to this broker. For internal use.
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	IsGlobal      *bool `form:"isGlobal,omitempty" json:"isGlobal,omitempty"`
}

// SchemasResourceTestCompatibilityParams defines parameters for SchemasResourceTestCompatibility.
type SchemasResourceTestCompatibilityParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SchemasResourceDeleteSchemaParams defines parameters for SchemasResourceDeleteSchema.
type SchemasResourceDeleteSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
	Force         *bool `form:"force,omitempty" json:"force,omitempty"`
}

// SchemasResourceGetSchemaParams defines parameters for SchemasResourceGetSchema.
type SchemasResourceGetSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SchemasResourcePostSchemaParams defines parameters for SchemasResourcePostSchema.
type SchemasResourcePostSchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SchemasResourceGetSchemaByVersionParams defines parameters for SchemasResourceGetSchemaByVersion.
type SchemasResourceGetSchemaByVersionParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SchemasResourceGetAllSchemasParams defines parameters for SchemasResourceGetAllSchemas.
type SchemasResourceGetAllSchemasParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// SchemasResourceGetVersionBySchemaParams defines parameters for SchemasResourceGetVersionBySchema.
type SchemasResourceGetVersionBySchemaParams struct {
	Authoritative *bool `form:"authoritative,omitempty" json:"authoritative,omitempty"`
}

// TenantsBaseDeleteTenantParams defines parameters for TenantsBaseDeleteTenant.
type TenantsBaseDeleteTenantParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// WorkerGetDrainStatusFromLeaderParams defines parameters for WorkerGetDrainStatusFromLeader.
type WorkerGetDrainStatusFromLeaderParams struct {
	WorkerId *string `form:"workerId,omitempty" json:"workerId,omitempty"`
}

// WorkerDrainAtLeaderParams defines parameters for WorkerDrainAtLeader.
type WorkerDrainAtLeaderParams struct {
	WorkerId *string `form:"workerId,omitempty" json:"workerId,omitempty"`
}

// NamespacesCreateNamespaceJSONRequestBody defines body for NamespacesCreateNamespace for application/json ContentType.
type NamespacesCreateNamespaceJSONRequestBody = Policies

// NamespacesSetNamespaceAntiAffinityGroupJSONRequestBody defines body for NamespacesSetNamespaceAntiAffinityGroup for application/json ContentType.
type NamespacesSetNamespaceAntiAffinityGroupJSONRequestBody = NamespacesSetNamespaceAntiAffinityGroupJSONBody

// NamespacesSetAutoSubscriptionCreationJSONRequestBody defines body for NamespacesSetAutoSubscriptionCreation for application/json ContentType.
type NamespacesSetAutoSubscriptionCreationJSONRequestBody = AutoSubscriptionCreationOverride

// NamespacesSetAutoTopicCreationJSONRequestBody defines body for NamespacesSetAutoTopicCreation for application/json ContentType.
type NamespacesSetAutoTopicCreationJSONRequestBody = AutoTopicCreationOverride

// NamespacesSetBacklogQuotaJSONRequestBody defines body for NamespacesSetBacklogQuota for application/json ContentType.
type NamespacesSetBacklogQuotaJSONRequestBody = BacklogQuota

// NamespacesSetCompactionThresholdJSONRequestBody defines body for NamespacesSetCompactionThreshold for application/json ContentType.
type NamespacesSetCompactionThresholdJSONRequestBody = NamespacesSetCompactionThresholdJSONBody

// NamespacesModifyDeduplicationJSONRequestBody defines body for NamespacesModifyDeduplication for application/json ContentType.
type NamespacesModifyDeduplicationJSONRequestBody = NamespacesModifyDeduplicationJSONBody

// NamespacesSetDeduplicationSnapshotIntervalJSONRequestBody defines body for NamespacesSetDeduplicationSnapshotInterval for application/json ContentType.
type NamespacesSetDeduplicationSnapshotIntervalJSONRequestBody = NamespacesSetDeduplicationSnapshotIntervalJSONBody

// NamespacesSetDelayedDeliveryPoliciesJSONRequestBody defines body for NamespacesSetDelayedDeliveryPolicies for application/json ContentType.
type NamespacesSetDelayedDeliveryPoliciesJSONRequestBody = DelayedDeliveryPolicies

// NamespacesSetDispatchRateJSONRequestBody defines body for NamespacesSetDispatchRate for application/json ContentType.
type NamespacesSetDispatchRateJSONRequestBody = DispatchRateImpl

// NamespacesModifyEncryptionRequiredJSONRequestBody defines body for NamespacesModifyEncryptionRequired for application/json ContentType.
type NamespacesModifyEncryptionRequiredJSONRequestBody = NamespacesModifyEncryptionRequiredJSONBody

// NamespacesSetEntryFiltersPerTopicJSONRequestBody defines body for NamespacesSetEntryFiltersPerTopic for application/json ContentType.
type NamespacesSetEntryFiltersPerTopicJSONRequestBody = EntryFilters

// NamespacesSetInactiveTopicPoliciesJSONRequestBody defines body for NamespacesSetInactiveTopicPolicies for application/json ContentType.
type NamespacesSetInactiveTopicPoliciesJSONRequestBody = InactiveTopicPolicies

// NamespacesSetIsAllowAutoUpdateSchemaJSONRequestBody defines body for NamespacesSetIsAllowAutoUpdateSchema for application/json ContentType.
type NamespacesSetIsAllowAutoUpdateSchemaJSONRequestBody = NamespacesSetIsAllowAutoUpdateSchemaJSONBody

// NamespacesSetMaxConsumersPerSubscriptionJSONRequestBody defines body for NamespacesSetMaxConsumersPerSubscription for application/json ContentType.
type NamespacesSetMaxConsumersPerSubscriptionJSONRequestBody = NamespacesSetMaxConsumersPerSubscriptionJSONBody

// NamespacesSetMaxConsumersPerTopicJSONRequestBody defines body for NamespacesSetMaxConsumersPerTopic for application/json ContentType.
type NamespacesSetMaxConsumersPerTopicJSONRequestBody = NamespacesSetMaxConsumersPerTopicJSONBody

// NamespacesSetMaxProducersPerTopicJSONRequestBody defines body for NamespacesSetMaxProducersPerTopic for application/json ContentType.
type NamespacesSetMaxProducersPerTopicJSONRequestBody = NamespacesSetMaxProducersPerTopicJSONBody

// NamespacesSetMaxSubscriptionsPerTopicJSONRequestBody defines body for NamespacesSetMaxSubscriptionsPerTopic for application/json ContentType.
type NamespacesSetMaxSubscriptionsPerTopicJSONRequestBody = NamespacesSetMaxSubscriptionsPerTopicJSONBody

// NamespacesSetMaxTopicsPerNamespaceJSONRequestBody defines body for NamespacesSetMaxTopicsPerNamespace for application/json ContentType.
type NamespacesSetMaxTopicsPerNamespaceJSONRequestBody = NamespacesSetMaxTopicsPerNamespaceJSONBody

// NamespacesSetMaxUnackedMessagesPerConsumerJSONRequestBody defines body for NamespacesSetMaxUnackedMessagesPerConsumer for application/json ContentType.
type NamespacesSetMaxUnackedMessagesPerConsumerJSONRequestBody = NamespacesSetMaxUnackedMessagesPerConsumerJSONBody

// NamespacesSetMaxUnackedMessagesPerSubscriptionJSONRequestBody defines body for NamespacesSetMaxUnackedMessagesPerSubscription for application/json ContentType.
type NamespacesSetMaxUnackedMessagesPerSubscriptionJSONRequestBody = NamespacesSetMaxUnackedMessagesPerSubscriptionJSONBody

// NamespacesSetNamespaceMessageTTLJSONRequestBody defines body for NamespacesSetNamespaceMessageTTL for application/json ContentType.
type NamespacesSetNamespaceMessageTTLJSONRequestBody = NamespacesSetNamespaceMessageTTLJSONBody

// NamespacesSetOffloadDeletionLagJSONRequestBody defines body for NamespacesSetOffloadDeletionLag for application/json ContentType.
type NamespacesSetOffloadDeletionLagJSONRequestBody = NamespacesSetOffloadDeletionLagJSONBody

// NamespacesSetOffloadPoliciesJSONRequestBody defines body for NamespacesSetOffloadPolicies for application/json ContentType.
type NamespacesSetOffloadPoliciesJSONRequestBody = OffloadPoliciesImpl

// NamespacesSetOffloadThresholdJSONRequestBody defines body for NamespacesSetOffloadThreshold for application/json ContentType.
type NamespacesSetOffloadThresholdJSONRequestBody = NamespacesSetOffloadThresholdJSONBody

// NamespacesGrantPermissionOnNamespaceJSONRequestBody defines body for NamespacesGrantPermissionOnNamespace for application/json ContentType.
type NamespacesGrantPermissionOnNamespaceJSONRequestBody = NamespacesGrantPermissionOnNamespaceJSONBody

// NamespacesSetPersistenceJSONRequestBody defines body for NamespacesSetPersistence for application/json ContentType.
type NamespacesSetPersistenceJSONRequestBody = PersistencePolicies

// NamespacesSetBookieAffinityGroupJSONRequestBody defines body for NamespacesSetBookieAffinityGroup for application/json ContentType.
type NamespacesSetBookieAffinityGroupJSONRequestBody = BookieAffinityGroupData

// NamespacesSetPropertiesJSONRequestBody defines body for NamespacesSetProperties for application/json ContentType.
type NamespacesSetPropertiesJSONRequestBody NamespacesSetPropertiesJSONBody

// NamespacesSetNamespaceReplicationClustersJSONRequestBody defines body for NamespacesSetNamespaceReplicationClusters for application/json ContentType.
type NamespacesSetNamespaceReplicationClustersJSONRequestBody = NamespacesSetNamespaceReplicationClustersJSONBody

// NamespacesSetReplicatorDispatchRateJSONRequestBody defines body for NamespacesSetReplicatorDispatchRate for application/json ContentType.
type NamespacesSetReplicatorDispatchRateJSONRequestBody = DispatchRateImpl

// NamespacesRemoveRetentionJSONRequestBody defines body for NamespacesRemoveRetention for application/json ContentType.
type NamespacesRemoveRetentionJSONRequestBody = RetentionPolicies

// NamespacesSetRetentionJSONRequestBody defines body for NamespacesSetRetention for application/json ContentType.
type NamespacesSetRetentionJSONRequestBody = RetentionPolicies

// NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody defines body for NamespacesSetSchemaAutoUpdateCompatibilityStrategy for application/json ContentType.
type NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody = NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONBody

// NamespacesSetSchemaCompatibilityStrategyJSONRequestBody defines body for NamespacesSetSchemaCompatibilityStrategy for application/json ContentType.
type NamespacesSetSchemaCompatibilityStrategyJSONRequestBody = NamespacesSetSchemaCompatibilityStrategyJSONBody

// NamespacesSetSchemaValidationEnforcedJSONRequestBody defines body for NamespacesSetSchemaValidationEnforced for application/json ContentType.
type NamespacesSetSchemaValidationEnforcedJSONRequestBody = NamespacesSetSchemaValidationEnforcedJSONBody

// NamespacesSetSubscribeRateJSONRequestBody defines body for NamespacesSetSubscribeRate for application/json ContentType.
type NamespacesSetSubscribeRateJSONRequestBody = SubscribeRate

// NamespacesSetSubscriptionAuthModeJSONRequestBody defines body for NamespacesSetSubscriptionAuthMode for application/json ContentType.
type NamespacesSetSubscriptionAuthModeJSONRequestBody = NamespacesSetSubscriptionAuthModeJSONBody

// NamespacesSetSubscriptionDispatchRateJSONRequestBody defines body for NamespacesSetSubscriptionDispatchRate for application/json ContentType.
type NamespacesSetSubscriptionDispatchRateJSONRequestBody = DispatchRateImpl

// NamespacesSetSubscriptionExpirationTimeJSONRequestBody defines body for NamespacesSetSubscriptionExpirationTime for application/json ContentType.
type NamespacesSetSubscriptionExpirationTimeJSONRequestBody = NamespacesSetSubscriptionExpirationTimeJSONBody

// NamespacesSetSubscriptionTypesEnabledJSONRequestBody defines body for NamespacesSetSubscriptionTypesEnabled for application/json ContentType.
type NamespacesSetSubscriptionTypesEnabledJSONRequestBody = NamespacesSetSubscriptionTypesEnabledJSONBody

// NamespacesSplitNamespaceBundleJSONRequestBody defines body for NamespacesSplitNamespaceBundle for application/json ContentType.
type NamespacesSplitNamespaceBundleJSONRequestBody = NamespacesSplitNamespaceBundleJSONBody

// ResourceQuotasSetDefaultResourceQuotaJSONRequestBody defines body for ResourceQuotasSetDefaultResourceQuota for application/json ContentType.
type ResourceQuotasSetDefaultResourceQuotaJSONRequestBody = ResourceQuota

// ResourceQuotasSetNamespaceBundleResourceQuotaJSONRequestBody defines body for ResourceQuotasSetNamespaceBundleResourceQuota for application/json ContentType.
type ResourceQuotasSetNamespaceBundleResourceQuotaJSONRequestBody = ResourceQuota

// ResourceGroupsCreateOrUpdateResourceGroupJSONRequestBody defines body for ResourceGroupsCreateOrUpdateResourceGroup for application/json ContentType.
type ResourceGroupsCreateOrUpdateResourceGroupJSONRequestBody = ResourceGroup

// SchemasResourceTestCompatibilityJSONRequestBody defines body for SchemasResourceTestCompatibility for application/json ContentType.
type SchemasResourceTestCompatibilityJSONRequestBody = PostSchemaPayload

// SchemasResourcePostSchemaJSONRequestBody defines body for SchemasResourcePostSchema for application/json ContentType.
type SchemasResourcePostSchemaJSONRequestBody = PostSchemaPayload

// SchemasResourceGetVersionBySchemaJSONRequestBody defines body for SchemasResourceGetVersionBySchema for application/json ContentType.
type SchemasResourceGetVersionBySchemaJSONRequestBody = PostSchemaPayload

// TenantsBaseUpdateTenantJSONRequestBody defines body for TenantsBaseUpdateTenant for application/json ContentType.
type TenantsBaseUpdateTenantJSONRequestBody = TenantInfo

// TenantsBaseCreateTenantJSONRequestBody defines body for TenantsBaseCreateTenant for application/json ContentType.
type TenantsBaseCreateTenantJSONRequestBody = TenantInfo

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// BookiesGetAllBookies request
	BookiesGetAllBookies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BookiesGetBookiesRackInfo request
	BookiesGetBookiesRackInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BookiesDeleteBookieRackInfo request
	BookiesDeleteBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BookiesGetBookieRackInfo request
	BookiesGetBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BookiesUpdateBookieRackInfo request
	BookiesUpdateBookieRackInfo(ctx context.Context, bookie string, params *BookiesUpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokerStatsBaseGetAllocatorStats request
	BrokerStatsBaseGetAllocatorStats(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokerStatsBaseGetPendingBookieOpsStats request
	BrokerStatsBaseGetPendingBookieOpsStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokerStatsGetBrokerResourceAvailability request
	BrokerStatsGetBrokerResourceAvailability(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokerStatsBaseGetLoadReport request
	BrokerStatsBaseGetLoadReport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokerStatsBaseGetMBeans request
	BrokerStatsBaseGetMBeans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokerStatsBaseGetMetrics request
	BrokerStatsBaseGetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokerStatsGetTopics2 request
	BrokerStatsGetTopics2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseGetActiveBrokers request
	BrokersBaseGetActiveBrokers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseBacklogQuotaCheck request
	BrokersBaseBacklogQuotaCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseGetDynamicConfigurationName request
	BrokersBaseGetDynamicConfigurationName(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseGetRuntimeConfiguration request
	BrokersBaseGetRuntimeConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseGetAllDynamicConfigurations request
	BrokersBaseGetAllDynamicConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseDeleteDynamicConfiguration request
	BrokersBaseDeleteDynamicConfiguration(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseUpdateDynamicConfiguration request
	BrokersBaseUpdateDynamicConfiguration(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseHealthCheck request
	BrokersBaseHealthCheck(ctx context.Context, params *BrokersBaseHealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseGetInternalConfigurationData request
	BrokersBaseGetInternalConfigurationData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseGetLeaderBroker request
	BrokersBaseGetLeaderBroker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseIsReady request
	BrokersBaseIsReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseShutDownBrokerGracefully request
	BrokersBaseShutDownBrokerGracefully(ctx context.Context, params *BrokersBaseShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseVersion request
	BrokersBaseVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseGetOwnedNamespaces request
	BrokersBaseGetOwnedNamespaces(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BrokersBaseGetActiveBrokersByCluster request
	BrokersBaseGetActiveBrokersByCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetClusters request
	ClustersBaseGetClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseDeleteCluster request
	ClustersBaseDeleteCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetCluster request
	ClustersBaseGetCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseUpdateClusterWithBody request with any body
	ClustersBaseUpdateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseCreateClusterWithBody request with any body
	ClustersBaseCreateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetFailureDomains request
	ClustersBaseGetFailureDomains(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseDeleteFailureDomain request
	ClustersBaseDeleteFailureDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetDomain request
	ClustersBaseGetDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseSetFailureDomainWithBody request with any body
	ClustersBaseSetFailureDomainWithBody(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseUpdateClusterMigrationWithBody request with any body
	ClustersBaseUpdateClusterMigrationWithBody(ctx context.Context, cluster string, params *ClustersBaseUpdateClusterMigrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetNamespaceIsolationPolicies request
	ClustersBaseGetNamespaceIsolationPolicies(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetBrokersWithNamespaceIsolationPolicy request
	ClustersBaseGetBrokersWithNamespaceIsolationPolicy(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetBrokerWithNamespaceIsolationPolicy request
	ClustersBaseGetBrokerWithNamespaceIsolationPolicy(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseDeleteNamespaceIsolationPolicy request
	ClustersBaseDeleteNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetNamespaceIsolationPolicy request
	ClustersBaseGetNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseSetNamespaceIsolationPolicyWithBody request with any body
	ClustersBaseSetNamespaceIsolationPolicyWithBody(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseGetPeerCluster request
	ClustersBaseGetPeerCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClustersBaseSetPeerClusterNamesWithBody request with any body
	ClustersBaseSetPeerClusterNamesWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetAntiAffinityNamespaces request
	NamespacesGetAntiAffinityNamespaces(ctx context.Context, cluster string, group string, params *NamespacesGetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesDeleteBookieAffinityGroup request
	NamespacesDeleteBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetBookieAffinityGroup request
	NamespacesGetBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetTenantNamespaces request
	NamespacesGetTenantNamespaces(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesDeleteNamespace request
	NamespacesDeleteNamespace(ctx context.Context, tenant string, namespace string, params *NamespacesDeleteNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetPolicies request
	NamespacesGetPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesCreateNamespaceWithBody request with any body
	NamespacesCreateNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesCreateNamespace(ctx context.Context, tenant string, namespace string, body NamespacesCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveNamespaceAntiAffinityGroup request
	NamespacesRemoveNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetNamespaceAntiAffinityGroup request
	NamespacesGetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetNamespaceAntiAffinityGroupWithBody request with any body
	NamespacesSetNamespaceAntiAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveAutoSubscriptionCreation request
	NamespacesRemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetAutoSubscriptionCreation request
	NamespacesGetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetAutoSubscriptionCreationWithBody request with any body
	NamespacesSetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, body NamespacesSetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveAutoTopicCreation request
	NamespacesRemoveAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetAutoTopicCreation request
	NamespacesGetAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetAutoTopicCreationWithBody request with any body
	NamespacesSetAutoTopicCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetAutoTopicCreation(ctx context.Context, tenant string, namespace string, body NamespacesSetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveBacklogQuota request
	NamespacesRemoveBacklogQuota(ctx context.Context, tenant string, namespace string, params *NamespacesRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetBacklogQuotaWithBody request with any body
	NamespacesSetBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetBacklogQuota(ctx context.Context, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, body NamespacesSetBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetBacklogQuotaMap request
	NamespacesGetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetBundlesData request
	NamespacesGetBundlesData(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesClearNamespaceBacklog request
	NamespacesClearNamespaceBacklog(ctx context.Context, tenant string, namespace string, params *NamespacesClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesClearNamespaceBacklogForSubscription request
	NamespacesClearNamespaceBacklogForSubscription(ctx context.Context, tenant string, namespace string, subscription string, params *NamespacesClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesDeleteCompactionThreshold request
	NamespacesDeleteCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetCompactionThreshold request
	NamespacesGetCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetCompactionThresholdWithBody request with any body
	NamespacesSetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetCompactionThreshold(ctx context.Context, tenant string, namespace string, body NamespacesSetCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveDeduplication request
	NamespacesRemoveDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetDeduplication request
	NamespacesGetDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesModifyDeduplicationWithBody request with any body
	NamespacesModifyDeduplicationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesModifyDeduplication(ctx context.Context, tenant string, namespace string, body NamespacesModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetDeduplicationSnapshotInterval request
	NamespacesGetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetDeduplicationSnapshotIntervalWithBody request with any body
	NamespacesSetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, body NamespacesSetDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveDelayedDeliveryPolicies request
	NamespacesRemoveDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetDelayedDeliveryPolicies request
	NamespacesGetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetDelayedDeliveryPoliciesWithBody request with any body
	NamespacesSetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, body NamespacesSetDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesDeleteDispatchRate request
	NamespacesDeleteDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetDispatchRate request
	NamespacesGetDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetDispatchRateWithBody request with any body
	NamespacesSetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetDispatchRate(ctx context.Context, tenant string, namespace string, body NamespacesSetDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetEncryptionRequired request
	NamespacesGetEncryptionRequired(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesModifyEncryptionRequiredWithBody request with any body
	NamespacesModifyEncryptionRequiredWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesModifyEncryptionRequired(ctx context.Context, tenant string, namespace string, body NamespacesModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveNamespaceEntryFilters request
	NamespacesRemoveNamespaceEntryFilters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetEntryFiltersPerTopic request
	NamespacesGetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetEntryFiltersPerTopicWithBody request with any body
	NamespacesSetEntryFiltersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, body NamespacesSetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveInactiveTopicPolicies request
	NamespacesRemoveInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetInactiveTopicPolicies request
	NamespacesGetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetInactiveTopicPoliciesWithBody request with any body
	NamespacesSetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, body NamespacesSetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetIsAllowAutoUpdateSchema request
	NamespacesGetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetIsAllowAutoUpdateSchemaWithBody request with any body
	NamespacesSetIsAllowAutoUpdateSchemaWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, body NamespacesSetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveMaxConsumersPerSubscription request
	NamespacesRemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetMaxConsumersPerSubscription request
	NamespacesGetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetMaxConsumersPerSubscriptionWithBody request with any body
	NamespacesSetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveMaxConsumersPerTopic request
	NamespacesRemoveMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetMaxConsumersPerTopic request
	NamespacesGetMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetMaxConsumersPerTopicWithBody request with any body
	NamespacesSetMaxConsumersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveMaxProducersPerTopic request
	NamespacesRemoveMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetMaxProducersPerTopic request
	NamespacesGetMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetMaxProducersPerTopicWithBody request with any body
	NamespacesSetMaxProducersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveMaxSubscriptionsPerTopic request
	NamespacesRemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetMaxSubscriptionsPerTopic request
	NamespacesGetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetMaxSubscriptionsPerTopicWithBody request with any body
	NamespacesSetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveMaxTopicsPerNamespace request
	NamespacesRemoveMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetMaxTopicsPerNamespace request
	NamespacesGetMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetMaxTopicsPerNamespaceWithBody request with any body
	NamespacesSetMaxTopicsPerNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxTopicsPerNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveMaxUnackedmessagesPerConsumer request
	NamespacesRemoveMaxUnackedmessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetMaxUnackedMessagesPerConsumer request
	NamespacesGetMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetMaxUnackedMessagesPerConsumerWithBody request with any body
	NamespacesSetMaxUnackedMessagesPerConsumerWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveMaxUnackedmessagesPerSubscription request
	NamespacesRemoveMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetMaxUnackedmessagesPerSubscription request
	NamespacesGetMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetMaxUnackedMessagesPerSubscriptionWithBody request with any body
	NamespacesSetMaxUnackedMessagesPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetMaxUnackedMessagesPerSubscription(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveNamespaceMessageTTL request
	NamespacesRemoveNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetNamespaceMessageTTL request
	NamespacesGetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetNamespaceMessageTTLWithBody request with any body
	NamespacesSetNamespaceMessageTTLWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesClearOffloadDeletionLag request
	NamespacesClearOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetOffloadDeletionLag request
	NamespacesGetOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetOffloadDeletionLagWithBody request with any body
	NamespacesSetOffloadDeletionLagWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetOffloadDeletionLag(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetOffloadPolicies request
	NamespacesGetOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetOffloadPoliciesWithBody request with any body
	NamespacesSetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetOffloadPolicies(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetOffloadThreshold request
	NamespacesGetOffloadThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetOffloadThresholdWithBody request with any body
	NamespacesSetOffloadThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetOffloadThreshold(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetOffloadThresholdInSeconds request
	NamespacesGetOffloadThresholdInSeconds(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetOffloadThresholdInSeconds request
	NamespacesSetOffloadThresholdInSeconds(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetPermissions request
	NamespacesGetPermissions(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetPermissionOnSubscription request
	NamespacesGetPermissionOnSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRevokePermissionsOnNamespace request
	NamespacesRevokePermissionsOnNamespace(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGrantPermissionOnNamespaceWithBody request with any body
	NamespacesGrantPermissionOnNamespaceWithBody(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesGrantPermissionOnNamespace(ctx context.Context, tenant string, namespace string, role string, body NamespacesGrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesDeletePersistence request
	NamespacesDeletePersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetPersistence request
	NamespacesGetPersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetPersistenceWithBody request with any body
	NamespacesSetPersistenceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetPersistence(ctx context.Context, tenant string, namespace string, body NamespacesSetPersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetBookieAffinityGroupWithBody request with any body
	NamespacesSetBookieAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetBookieAffinityGroup(ctx context.Context, tenant string, namespace string, body NamespacesSetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesClearProperties request
	NamespacesClearProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetProperties request
	NamespacesGetProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetPropertiesWithBody request with any body
	NamespacesSetPropertiesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetProperties(ctx context.Context, tenant string, namespace string, body NamespacesSetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveProperty request
	NamespacesRemoveProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetProperty request
	NamespacesGetProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetProperty request
	NamespacesSetProperty(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveOffloadPolicies request
	NamespacesRemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetNamespaceReplicationClusters request
	NamespacesGetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetNamespaceReplicationClustersWithBody request with any body
	NamespacesSetNamespaceReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveReplicatorDispatchRate request
	NamespacesRemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetReplicatorDispatchRate request
	NamespacesGetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetReplicatorDispatchRateWithBody request with any body
	NamespacesSetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, body NamespacesSetReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveNamespaceResourceGroup request
	NamespacesRemoveNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetNamespaceResourceGroup request
	NamespacesGetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetNamespaceResourceGroup request
	NamespacesSetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveRetentionWithBody request with any body
	NamespacesRemoveRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesRemoveRetention(ctx context.Context, tenant string, namespace string, body NamespacesRemoveRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetRetention request
	NamespacesGetRetention(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetRetentionWithBody request with any body
	NamespacesSetRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetRetention(ctx context.Context, tenant string, namespace string, body NamespacesSetRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesScanOffloadedLedgers request
	NamespacesScanOffloadedLedgers(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetSchemaAutoUpdateCompatibilityStrategy request
	NamespacesGetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithBody request with any body
	NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetSchemaCompatibilityStrategy request
	NamespacesGetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetSchemaCompatibilityStrategyWithBody request with any body
	NamespacesSetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetSchemaValidtionEnforced request
	NamespacesGetSchemaValidtionEnforced(ctx context.Context, tenant string, namespace string, params *NamespacesGetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetSchemaValidationEnforcedWithBody request with any body
	NamespacesSetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesDeleteSubscribeRate request
	NamespacesDeleteSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetSubscribeRate request
	NamespacesGetSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetSubscribeRateWithBody request with any body
	NamespacesSetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetSubscribeRate(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetSubscriptionAuthMode request
	NamespacesGetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetSubscriptionAuthModeWithBody request with any body
	NamespacesSetSubscriptionAuthModeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesDeleteSubscriptionDispatchRate request
	NamespacesDeleteSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetSubscriptionDispatchRate request
	NamespacesGetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetSubscriptionDispatchRateWithBody request with any body
	NamespacesSetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveSubscriptionExpirationTime request
	NamespacesRemoveSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetSubscriptionExpirationTime request
	NamespacesGetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetSubscriptionExpirationTimeWithBody request with any body
	NamespacesSetSubscriptionExpirationTimeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesRemoveSubscriptionTypesEnabled request
	NamespacesRemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetSubscriptionTypesEnabled request
	NamespacesGetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSetSubscriptionTypesEnabledWithBody request with any body
	NamespacesSetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetTopics request
	NamespacesGetTopics(ctx context.Context, tenant string, namespace string, params *NamespacesGetTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesUnloadNamespace request
	NamespacesUnloadNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesUnsubscribeNamespace request
	NamespacesUnsubscribeNamespace(ctx context.Context, tenant string, namespace string, subscription string, params *NamespacesUnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesDeleteNamespaceBundle request
	NamespacesDeleteNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesDeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesClearNamespaceBundleBacklog request
	NamespacesClearNamespaceBundleBacklog(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesClearNamespaceBundleBacklogForSubscription request
	NamespacesClearNamespaceBundleBacklogForSubscription(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *NamespacesClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesSplitNamespaceBundleWithBody request with any body
	NamespacesSplitNamespaceBundleWithBody(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	NamespacesSplitNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, body NamespacesSplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesGetTopicHashPositions request
	NamespacesGetTopicHashPositions(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesGetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesUnloadNamespaceBundle request
	NamespacesUnloadNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesUnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NamespacesUnsubscribeNamespaceBundle request
	NamespacesUnsubscribeNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *NamespacesUnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetList request
	NonPersistentTopicsGetList(ctx context.Context, tenant string, namespace string, params *NonPersistentTopicsGetListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetPartitionedTopicList request
	NonPersistentTopicsGetPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *NonPersistentTopicsGetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetListFromBundle request
	NonPersistentTopicsGetListFromBundle(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeleteTopic request
	NonPersistentTopicsDeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsCreateNonPartitionedTopicWithBody request with any body
	NonPersistentTopicsCreateNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsExpireMessagesForAllSubscriptions request
	NonPersistentTopicsExpireMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveAutoSubscriptionCreation request
	NonPersistentTopicsRemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetAutoSubscriptionCreation request
	NonPersistentTopicsGetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetAutoSubscriptionCreationWithBody request with any body
	NonPersistentTopicsSetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetBacklog request
	NonPersistentTopicsGetBacklog(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveBacklogQuota request
	NonPersistentTopicsRemoveBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetBacklogQuotaWithBody request with any body
	NonPersistentTopicsSetBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetBacklogQuotaMap request
	NonPersistentTopicsGetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetBacklogSizeByMessageId request
	NonPersistentTopicsGetBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsCompactionStatus request
	NonPersistentTopicsCompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsCompact request
	NonPersistentTopicsCompact(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveCompactionThreshold request
	NonPersistentTopicsRemoveCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetCompactionThreshold request
	NonPersistentTopicsGetCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetCompactionThresholdWithBody request with any body
	NonPersistentTopicsSetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsCreateMissedPartitions request
	NonPersistentTopicsCreateMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveDeduplication request
	NonPersistentTopicsRemoveDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetDeduplication request
	NonPersistentTopicsGetDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetDeduplicationWithBody request with any body
	NonPersistentTopicsSetDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeleteDeduplicationSnapshotInterval request
	NonPersistentTopicsDeleteDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetDeduplicationSnapshotInterval request
	NonPersistentTopicsGetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetDeduplicationSnapshotIntervalWithBody request with any body
	NonPersistentTopicsSetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeleteDelayedDeliveryPolicies request
	NonPersistentTopicsDeleteDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetDelayedDeliveryPolicies request
	NonPersistentTopicsGetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetDelayedDeliveryPoliciesWithBody request with any body
	NonPersistentTopicsSetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveDispatchRate request
	NonPersistentTopicsRemoveDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetDispatchRate request
	NonPersistentTopicsGetDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetDispatchRateWithBody request with any body
	NonPersistentTopicsSetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveEntryFilters request
	NonPersistentTopicsRemoveEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetEntryFilters request
	NonPersistentTopicsGetEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetEntryFiltersWithBody request with any body
	NonPersistentTopicsSetEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsExamineMessage request
	NonPersistentTopicsExamineMessage(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsExamineMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeleteInactiveTopicPolicies request
	NonPersistentTopicsDeleteInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetInactiveTopicPolicies request
	NonPersistentTopicsGetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetInactiveTopicPoliciesWithBody request with any body
	NonPersistentTopicsSetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetManagedLedgerInfo request
	NonPersistentTopicsGetManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetInternalStats request
	NonPersistentTopicsGetInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetLastMessageId request
	NonPersistentTopicsGetLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMessageById request
	NonPersistentTopicsGetMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *NonPersistentTopicsGetMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveMaxConsumers request
	NonPersistentTopicsRemoveMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMaxConsumers request
	NonPersistentTopicsGetMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetMaxConsumersWithBody request with any body
	NonPersistentTopicsSetMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveMaxConsumersPerSubscription request
	NonPersistentTopicsRemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMaxConsumersPerSubscription request
	NonPersistentTopicsGetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetMaxConsumersPerSubscriptionWithBody request with any body
	NonPersistentTopicsSetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveMaxMessageSize request
	NonPersistentTopicsRemoveMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMaxMessageSize request
	NonPersistentTopicsGetMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetMaxMessageSizeWithBody request with any body
	NonPersistentTopicsSetMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveMaxProducers request
	NonPersistentTopicsRemoveMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMaxProducers request
	NonPersistentTopicsGetMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetMaxProducersWithBody request with any body
	NonPersistentTopicsSetMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveMaxSubscriptionsPerTopic request
	NonPersistentTopicsRemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMaxSubscriptionsPerTopic request
	NonPersistentTopicsGetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetMaxSubscriptionsPerTopicWithBody request with any body
	NonPersistentTopicsSetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumer request
	NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMaxUnackedMessagesOnConsumer request
	NonPersistentTopicsGetMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithBody request with any body
	NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscription request
	NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMaxUnackedMessagesOnSubscription request
	NonPersistentTopicsGetMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBody request with any body
	NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveMessageTTL request
	NonPersistentTopicsRemoveMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMessageTTL request
	NonPersistentTopicsGetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetMessageTTL request
	NonPersistentTopicsSetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetMessageIdByTimestamp request
	NonPersistentTopicsGetMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *NonPersistentTopicsGetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsOffloadStatus request
	NonPersistentTopicsOffloadStatus(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsOffloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsTriggerOffload request
	NonPersistentTopicsTriggerOffload(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTriggerOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveOffloadPolicies request
	NonPersistentTopicsRemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetOffloadPolicies request
	NonPersistentTopicsGetOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetOffloadPoliciesWithBody request with any body
	NonPersistentTopicsSetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetPartitionedStatsInternal request
	NonPersistentTopicsGetPartitionedStatsInternal(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsInternalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetPartitionedStats request
	NonPersistentTopicsGetPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeletePartitionedTopic request
	NonPersistentTopicsDeletePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetPartitionedMetadata request
	NonPersistentTopicsGetPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsUpdatePartitionedTopicWithBody request with any body
	NonPersistentTopicsUpdatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsCreatePartitionedTopicWithBody request with any body
	NonPersistentTopicsCreatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetPermissionsOnTopic request
	NonPersistentTopicsGetPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRevokePermissionsOnTopic request
	NonPersistentTopicsRevokePermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGrantPermissionsOnTopicWithBody request with any body
	NonPersistentTopicsGrantPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemovePersistence request
	NonPersistentTopicsRemovePersistence(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetPersistence request
	NonPersistentTopicsGetPersistence(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetPersistenceWithBody request with any body
	NonPersistentTopicsSetPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveProperties request
	NonPersistentTopicsRemoveProperties(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetProperties request
	NonPersistentTopicsGetProperties(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsUpdatePropertiesWithBody request with any body
	NonPersistentTopicsUpdatePropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemovePublishRate request
	NonPersistentTopicsRemovePublishRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetPublishRate request
	NonPersistentTopicsGetPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetPublishRateWithBody request with any body
	NonPersistentTopicsSetPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveReplicationClusters request
	NonPersistentTopicsRemoveReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetReplicationClusters request
	NonPersistentTopicsGetReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetReplicationClustersWithBody request with any body
	NonPersistentTopicsSetReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveReplicatorDispatchRate request
	NonPersistentTopicsRemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetReplicatorDispatchRate request
	NonPersistentTopicsGetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetReplicatorDispatchRateWithBody request with any body
	NonPersistentTopicsSetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveRetention request
	NonPersistentTopicsRemoveRetention(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetRetention request
	NonPersistentTopicsGetRetention(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetRetentionWithBody request with any body
	NonPersistentTopicsSetRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithBody request with any body
	NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetSchemaCompatibilityStrategy request
	NonPersistentTopicsGetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetSchemaCompatibilityStrategyWithBody request with any body
	NonPersistentTopicsSetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetSchemaValidationEnforced request
	NonPersistentTopicsGetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetSchemaValidationEnforcedWithBody request with any body
	NonPersistentTopicsSetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeleteShadowTopics request
	NonPersistentTopicsDeleteShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetShadowTopics request
	NonPersistentTopicsGetShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetShadowTopicsWithBody request with any body
	NonPersistentTopicsSetShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetStats request
	NonPersistentTopicsGetStats(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveSubscribeRateWithBody request with any body
	NonPersistentTopicsRemoveSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetSubscribeRate request
	NonPersistentTopicsGetSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetSubscribeRateWithBody request with any body
	NonPersistentTopicsSetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsDeleteSubscription request
	NonPersistentTopicsDeleteSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsAnalyzeSubscriptionBacklogWithBody request with any body
	NonPersistentTopicsAnalyzeSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsExpireTopicMessagesWithBody request with any body
	NonPersistentTopicsExpireTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsExpireTopicMessagesExpireTime request
	NonPersistentTopicsExpireTopicMessagesExpireTime(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireTopicMessagesExpireTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsPeekNthMessage request
	NonPersistentTopicsPeekNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *NonPersistentTopicsPeekNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetSubscriptionProperties request
	NonPersistentTopicsGetSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsUpdateSubscriptionPropertiesWithBody request with any body
	NonPersistentTopicsUpdateSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetReplicatedSubscriptionStatus request
	NonPersistentTopicsGetReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetReplicatedSubscriptionStatusWithBody request with any body
	NonPersistentTopicsSetReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsResetCursorOnPositionWithBody request with any body
	NonPersistentTopicsResetCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsResetCursor request
	NonPersistentTopicsResetCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *NonPersistentTopicsResetCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSkipMessages request
	NonPersistentTopicsSkipMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *NonPersistentTopicsSkipMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSkipAllMessages request
	NonPersistentTopicsSkipAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSkipAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsCreateSubscriptionWithBody request with any body
	NonPersistentTopicsCreateSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *NonPersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveSubscriptionDispatchRate request
	NonPersistentTopicsRemoveSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetSubscriptionDispatchRate request
	NonPersistentTopicsGetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetSubscriptionDispatchRateWithBody request with any body
	NonPersistentTopicsSetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveSubscriptionTypesEnabled request
	NonPersistentTopicsRemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetSubscriptionTypesEnabled request
	NonPersistentTopicsGetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetSubscriptionTypesEnabledWithBody request with any body
	NonPersistentTopicsSetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetSubscriptions request
	NonPersistentTopicsGetSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsTerminate request
	NonPersistentTopicsTerminate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsTerminatePartitionedTopic request
	NonPersistentTopicsTerminatePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsTrimTopic request
	NonPersistentTopicsTrimTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTrimTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsTruncateTopic request
	NonPersistentTopicsTruncateTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTruncateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsUnloadTopic request
	NonPersistentTopicsUnloadTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUnloadTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsRemoveSubscriptionLevelDispatchRate request
	NonPersistentTopicsRemoveSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsRemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsGetSubscriptionLevelDispatchRate request
	NonPersistentTopicsGetSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// NonPersistentTopicsSetSubscriptionLevelDispatchRateWithBody request with any body
	NonPersistentTopicsSetSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetList request
	PersistentTopicsGetList(ctx context.Context, tenant string, namespace string, params *PersistentTopicsGetListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetPartitionedTopicList request
	PersistentTopicsGetPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *PersistentTopicsGetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeleteTopic request
	PersistentTopicsDeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsCreateNonPartitionedTopicWithBody request with any body
	PersistentTopicsCreateNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsExpireMessagesForAllSubscriptions request
	PersistentTopicsExpireMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *PersistentTopicsExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveAutoSubscriptionCreation request
	PersistentTopicsRemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetAutoSubscriptionCreation request
	PersistentTopicsGetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetAutoSubscriptionCreationWithBody request with any body
	PersistentTopicsSetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetBacklog request
	PersistentTopicsGetBacklog(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveBacklogQuota request
	PersistentTopicsRemoveBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetBacklogQuotaWithBody request with any body
	PersistentTopicsSetBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetBacklogQuotaMap request
	PersistentTopicsGetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetBacklogSizeByMessageId request
	PersistentTopicsGetBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsCompactionStatus request
	PersistentTopicsCompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsCompact request
	PersistentTopicsCompact(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCompactParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveCompactionThreshold request
	PersistentTopicsRemoveCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetCompactionThreshold request
	PersistentTopicsGetCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetCompactionThresholdWithBody request with any body
	PersistentTopicsSetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsCreateMissedPartitions request
	PersistentTopicsCreateMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveDeduplication request
	PersistentTopicsRemoveDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetDeduplication request
	PersistentTopicsGetDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetDeduplicationWithBody request with any body
	PersistentTopicsSetDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeleteDeduplicationSnapshotInterval request
	PersistentTopicsDeleteDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetDeduplicationSnapshotInterval request
	PersistentTopicsGetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetDeduplicationSnapshotIntervalWithBody request with any body
	PersistentTopicsSetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeleteDelayedDeliveryPolicies request
	PersistentTopicsDeleteDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetDelayedDeliveryPolicies request
	PersistentTopicsGetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetDelayedDeliveryPoliciesWithBody request with any body
	PersistentTopicsSetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveDispatchRate request
	PersistentTopicsRemoveDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetDispatchRate request
	PersistentTopicsGetDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetDispatchRateWithBody request with any body
	PersistentTopicsSetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveEntryFilters request
	PersistentTopicsRemoveEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetEntryFilters request
	PersistentTopicsGetEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetEntryFiltersWithBody request with any body
	PersistentTopicsSetEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsExamineMessage request
	PersistentTopicsExamineMessage(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsExamineMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeleteInactiveTopicPolicies request
	PersistentTopicsDeleteInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetInactiveTopicPolicies request
	PersistentTopicsGetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetInactiveTopicPoliciesWithBody request with any body
	PersistentTopicsSetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetManagedLedgerInfo request
	PersistentTopicsGetManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetInternalStats request
	PersistentTopicsGetInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetLastMessageId request
	PersistentTopicsGetLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMessageById request
	PersistentTopicsGetMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *PersistentTopicsGetMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveMaxConsumers request
	PersistentTopicsRemoveMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMaxConsumers request
	PersistentTopicsGetMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetMaxConsumersWithBody request with any body
	PersistentTopicsSetMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveMaxConsumersPerSubscription request
	PersistentTopicsRemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMaxConsumersPerSubscription request
	PersistentTopicsGetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetMaxConsumersPerSubscriptionWithBody request with any body
	PersistentTopicsSetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveMaxMessageSize request
	PersistentTopicsRemoveMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMaxMessageSize request
	PersistentTopicsGetMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetMaxMessageSizeWithBody request with any body
	PersistentTopicsSetMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveMaxProducers request
	PersistentTopicsRemoveMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMaxProducers request
	PersistentTopicsGetMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetMaxProducersWithBody request with any body
	PersistentTopicsSetMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveMaxSubscriptionsPerTopic request
	PersistentTopicsRemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMaxSubscriptionsPerTopic request
	PersistentTopicsGetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetMaxSubscriptionsPerTopicWithBody request with any body
	PersistentTopicsSetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeleteMaxUnackedMessagesOnConsumer request
	PersistentTopicsDeleteMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMaxUnackedMessagesOnConsumer request
	PersistentTopicsGetMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetMaxUnackedMessagesOnConsumerWithBody request with any body
	PersistentTopicsSetMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeleteMaxUnackedMessagesOnSubscription request
	PersistentTopicsDeleteMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMaxUnackedMessagesOnSubscription request
	PersistentTopicsGetMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBody request with any body
	PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveMessageTTL request
	PersistentTopicsRemoveMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMessageTTL request
	PersistentTopicsGetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetMessageTTL request
	PersistentTopicsSetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetMessageIdByTimestamp request
	PersistentTopicsGetMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *PersistentTopicsGetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsOffloadStatus request
	PersistentTopicsOffloadStatus(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsOffloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsTriggerOffload request
	PersistentTopicsTriggerOffload(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTriggerOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveOffloadPolicies request
	PersistentTopicsRemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetOffloadPolicies request
	PersistentTopicsGetOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetOffloadPoliciesWithBody request with any body
	PersistentTopicsSetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetPartitionedStatsInternal request
	PersistentTopicsGetPartitionedStatsInternal(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsInternalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetPartitionedStats request
	PersistentTopicsGetPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeletePartitionedTopic request
	PersistentTopicsDeletePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetPartitionedMetadata request
	PersistentTopicsGetPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsUpdatePartitionedTopicWithBody request with any body
	PersistentTopicsUpdatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsCreatePartitionedTopicWithBody request with any body
	PersistentTopicsCreatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetPermissionsOnTopic request
	PersistentTopicsGetPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRevokePermissionsOnTopic request
	PersistentTopicsRevokePermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGrantPermissionsOnTopicWithBody request with any body
	PersistentTopicsGrantPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemovePersistence request
	PersistentTopicsRemovePersistence(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetPersistence request
	PersistentTopicsGetPersistence(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetPersistenceWithBody request with any body
	PersistentTopicsSetPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveProperties request
	PersistentTopicsRemoveProperties(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetProperties request
	PersistentTopicsGetProperties(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsUpdatePropertiesWithBody request with any body
	PersistentTopicsUpdatePropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemovePublishRate request
	PersistentTopicsRemovePublishRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetPublishRate request
	PersistentTopicsGetPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetPublishRateWithBody request with any body
	PersistentTopicsSetPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveReplicationClusters request
	PersistentTopicsRemoveReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetReplicationClusters request
	PersistentTopicsGetReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetReplicationClustersWithBody request with any body
	PersistentTopicsSetReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveReplicatorDispatchRate request
	PersistentTopicsRemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetReplicatorDispatchRate request
	PersistentTopicsGetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetReplicatorDispatchRateWithBody request with any body
	PersistentTopicsSetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveRetention request
	PersistentTopicsRemoveRetention(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetRetention request
	PersistentTopicsGetRetention(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetRetentionWithBody request with any body
	PersistentTopicsSetRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveSchemaCompatibilityStrategyWithBody request with any body
	PersistentTopicsRemoveSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetSchemaCompatibilityStrategy request
	PersistentTopicsGetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetSchemaCompatibilityStrategyWithBody request with any body
	PersistentTopicsSetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetSchemaValidationEnforced request
	PersistentTopicsGetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetSchemaValidationEnforcedWithBody request with any body
	PersistentTopicsSetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeleteShadowTopics request
	PersistentTopicsDeleteShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetShadowTopics request
	PersistentTopicsGetShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetShadowTopicsWithBody request with any body
	PersistentTopicsSetShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetStats request
	PersistentTopicsGetStats(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveSubscribeRateWithBody request with any body
	PersistentTopicsRemoveSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetSubscribeRate request
	PersistentTopicsGetSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetSubscribeRateWithBody request with any body
	PersistentTopicsSetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsDeleteSubscription request
	PersistentTopicsDeleteSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsAnalyzeSubscriptionBacklogWithBody request with any body
	PersistentTopicsAnalyzeSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsExpireTopicMessagesWithBody request with any body
	PersistentTopicsExpireTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsExpireTopicMessagesExpireTime request
	PersistentTopicsExpireTopicMessagesExpireTime(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *PersistentTopicsExpireTopicMessagesExpireTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsPeekNthMessage request
	PersistentTopicsPeekNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PersistentTopicsPeekNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetSubscriptionProperties request
	PersistentTopicsGetSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsUpdateSubscriptionPropertiesWithBody request with any body
	PersistentTopicsUpdateSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetReplicatedSubscriptionStatus request
	PersistentTopicsGetReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetReplicatedSubscriptionStatusWithBody request with any body
	PersistentTopicsSetReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsResetCursorOnPositionWithBody request with any body
	PersistentTopicsResetCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsResetCursor request
	PersistentTopicsResetCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *PersistentTopicsResetCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSkipMessages request
	PersistentTopicsSkipMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *PersistentTopicsSkipMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSkipAllMessages request
	PersistentTopicsSkipAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSkipAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsCreateSubscriptionWithBody request with any body
	PersistentTopicsCreateSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *PersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveSubscriptionDispatchRate request
	PersistentTopicsRemoveSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetSubscriptionDispatchRate request
	PersistentTopicsGetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetSubscriptionDispatchRateWithBody request with any body
	PersistentTopicsSetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveSubscriptionTypesEnabled request
	PersistentTopicsRemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetSubscriptionTypesEnabled request
	PersistentTopicsGetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetSubscriptionTypesEnabledWithBody request with any body
	PersistentTopicsSetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetSubscriptions request
	PersistentTopicsGetSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsTerminate request
	PersistentTopicsTerminate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTerminateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsTerminatePartitionedTopic request
	PersistentTopicsTerminatePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsTrimTopic request
	PersistentTopicsTrimTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTrimTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsTruncateTopic request
	PersistentTopicsTruncateTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTruncateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsUnloadTopic request
	PersistentTopicsUnloadTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUnloadTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsRemoveSubscriptionLevelDispatchRate request
	PersistentTopicsRemoveSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsRemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsGetSubscriptionLevelDispatchRate request
	PersistentTopicsGetSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PersistentTopicsSetSubscriptionLevelDispatchRateWithBody request with any body
	PersistentTopicsSetSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceQuotasGetDefaultResourceQuota request
	ResourceQuotasGetDefaultResourceQuota(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceQuotasSetDefaultResourceQuotaWithBody request with any body
	ResourceQuotasSetDefaultResourceQuotaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResourceQuotasSetDefaultResourceQuota(ctx context.Context, body ResourceQuotasSetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceQuotasRemoveNamespaceBundleResourceQuota request
	ResourceQuotasRemoveNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceQuotasGetNamespaceBundleResourceQuota request
	ResourceQuotasGetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceQuotasSetNamespaceBundleResourceQuotaWithBody request with any body
	ResourceQuotasSetNamespaceBundleResourceQuotaWithBody(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResourceQuotasSetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, body ResourceQuotasSetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceGroupsGetResourceGroups request
	ResourceGroupsGetResourceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceGroupsDeleteResourceGroup request
	ResourceGroupsDeleteResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceGroupsGetResourceGroup request
	ResourceGroupsGetResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResourceGroupsCreateOrUpdateResourceGroupWithBody request with any body
	ResourceGroupsCreateOrUpdateResourceGroupWithBody(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResourceGroupsCreateOrUpdateResourceGroup(ctx context.Context, resourcegroup string, body ResourceGroupsCreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasResourceTestCompatibilityWithBody request with any body
	SchemasResourceTestCompatibilityWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SchemasResourceTestCompatibility(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, body SchemasResourceTestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasResourceDeleteSchema request
	SchemasResourceDeleteSchema(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceDeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasResourceGetSchema request
	SchemasResourceGetSchema(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasResourcePostSchemaWithBody request with any body
	SchemasResourcePostSchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SchemasResourcePostSchema(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, body SchemasResourcePostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasResourceGetSchemaByVersion request
	SchemasResourceGetSchemaByVersion(ctx context.Context, tenant string, namespace string, topic string, version string, params *SchemasResourceGetSchemaByVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasResourceGetAllSchemas request
	SchemasResourceGetAllSchemas(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetAllSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SchemasResourceGetVersionBySchemaWithBody request with any body
	SchemasResourceGetVersionBySchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SchemasResourceGetVersionBySchema(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, body SchemasResourceGetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantsBaseGetTenants request
	TenantsBaseGetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantsBaseDeleteTenant request
	TenantsBaseDeleteTenant(ctx context.Context, tenant string, params *TenantsBaseDeleteTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantsBaseGetTenantAdmin request
	TenantsBaseGetTenantAdmin(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantsBaseUpdateTenantWithBody request with any body
	TenantsBaseUpdateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantsBaseUpdateTenant(ctx context.Context, tenant string, body TenantsBaseUpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TenantsBaseCreateTenantWithBody request with any body
	TenantsBaseCreateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TenantsBaseCreateTenant(ctx context.Context, tenant string, body TenantsBaseCreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerStatsGetStats request
	WorkerStatsGetStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerStatsGetMetrics request
	WorkerStatsGetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGetAssignments request
	WorkerGetAssignments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGetCluster request
	WorkerGetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGetClusterLeader request
	WorkerGetClusterLeader(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerIsLeaderReady request
	WorkerIsLeaderReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGetConnectorsList request
	WorkerGetConnectorsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGetDrainStatus request
	WorkerGetDrainStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerDrain request
	WorkerDrain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerGetDrainStatusFromLeader request
	WorkerGetDrainStatusFromLeader(ctx context.Context, params *WorkerGetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerDrainAtLeader request
	WorkerDrainAtLeader(ctx context.Context, params *WorkerDrainAtLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WorkerRebalance request
	WorkerRebalance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) BookiesGetAllBookies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBookiesGetAllBookiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BookiesGetBookiesRackInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBookiesGetBookiesRackInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BookiesDeleteBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBookiesDeleteBookieRackInfoRequest(c.Server, bookie)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BookiesGetBookieRackInfo(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBookiesGetBookieRackInfoRequest(c.Server, bookie)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BookiesUpdateBookieRackInfo(ctx context.Context, bookie string, params *BookiesUpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBookiesUpdateBookieRackInfoRequest(c.Server, bookie, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokerStatsBaseGetAllocatorStats(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokerStatsBaseGetAllocatorStatsRequest(c.Server, allocator)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokerStatsBaseGetPendingBookieOpsStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokerStatsBaseGetPendingBookieOpsStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokerStatsGetBrokerResourceAvailability(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokerStatsGetBrokerResourceAvailabilityRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokerStatsBaseGetLoadReport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokerStatsBaseGetLoadReportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokerStatsBaseGetMBeans(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokerStatsBaseGetMBeansRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokerStatsBaseGetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokerStatsBaseGetMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokerStatsGetTopics2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokerStatsGetTopics2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseGetActiveBrokers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseGetActiveBrokersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseBacklogQuotaCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseBacklogQuotaCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseGetDynamicConfigurationName(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseGetDynamicConfigurationNameRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseGetRuntimeConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseGetRuntimeConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseGetAllDynamicConfigurations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseGetAllDynamicConfigurationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseDeleteDynamicConfiguration(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseDeleteDynamicConfigurationRequest(c.Server, configName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseUpdateDynamicConfiguration(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseUpdateDynamicConfigurationRequest(c.Server, configName, configValue)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseHealthCheck(ctx context.Context, params *BrokersBaseHealthCheckParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseHealthCheckRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseGetInternalConfigurationData(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseGetInternalConfigurationDataRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseGetLeaderBroker(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseGetLeaderBrokerRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseIsReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseIsReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseShutDownBrokerGracefully(ctx context.Context, params *BrokersBaseShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseShutDownBrokerGracefullyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseGetOwnedNamespaces(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseGetOwnedNamespacesRequest(c.Server, clusterName, brokerWebserviceurl)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BrokersBaseGetActiveBrokersByCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBrokersBaseGetActiveBrokersByClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetClusters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetClustersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseDeleteCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseDeleteClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseUpdateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseUpdateClusterRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseCreateClusterWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseCreateClusterRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetFailureDomains(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetFailureDomainsRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseDeleteFailureDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseDeleteFailureDomainRequest(c.Server, cluster, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetDomain(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetDomainRequest(c.Server, cluster, domainName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseSetFailureDomainWithBody(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseSetFailureDomainRequestWithBody(c.Server, cluster, domainName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseUpdateClusterMigrationWithBody(ctx context.Context, cluster string, params *ClustersBaseUpdateClusterMigrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseUpdateClusterMigrationRequestWithBody(c.Server, cluster, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetNamespaceIsolationPolicies(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetNamespaceIsolationPoliciesRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetBrokersWithNamespaceIsolationPolicy(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetBrokersWithNamespaceIsolationPolicyRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetBrokerWithNamespaceIsolationPolicy(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetBrokerWithNamespaceIsolationPolicyRequest(c.Server, cluster, broker)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseDeleteNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseDeleteNamespaceIsolationPolicyRequest(c.Server, cluster, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetNamespaceIsolationPolicy(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetNamespaceIsolationPolicyRequest(c.Server, cluster, policyName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseSetNamespaceIsolationPolicyWithBody(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseSetNamespaceIsolationPolicyRequestWithBody(c.Server, cluster, policyName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseGetPeerCluster(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseGetPeerClusterRequest(c.Server, cluster)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClustersBaseSetPeerClusterNamesWithBody(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClustersBaseSetPeerClusterNamesRequestWithBody(c.Server, cluster, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetAntiAffinityNamespaces(ctx context.Context, cluster string, group string, params *NamespacesGetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetAntiAffinityNamespacesRequest(c.Server, cluster, group, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesDeleteBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesDeleteBookieAffinityGroupRequest(c.Server, property, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetBookieAffinityGroup(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetBookieAffinityGroupRequest(c.Server, property, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetTenantNamespaces(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetTenantNamespacesRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesDeleteNamespace(ctx context.Context, tenant string, namespace string, params *NamespacesDeleteNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesDeleteNamespaceRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesCreateNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesCreateNamespaceRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesCreateNamespace(ctx context.Context, tenant string, namespace string, body NamespacesCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesCreateNamespaceRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetNamespaceAntiAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetNamespaceAntiAffinityGroupRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetNamespaceAntiAffinityGroup(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetNamespaceAntiAffinityGroupRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveAutoSubscriptionCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetAutoSubscriptionCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetAutoSubscriptionCreationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, body NamespacesSetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetAutoSubscriptionCreationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveAutoTopicCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetAutoTopicCreation(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetAutoTopicCreationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetAutoTopicCreationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetAutoTopicCreationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetAutoTopicCreation(ctx context.Context, tenant string, namespace string, body NamespacesSetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetAutoTopicCreationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveBacklogQuota(ctx context.Context, tenant string, namespace string, params *NamespacesRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveBacklogQuotaRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetBacklogQuotaRequestWithBody(c.Server, tenant, namespace, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetBacklogQuota(ctx context.Context, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, body NamespacesSetBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetBacklogQuotaRequest(c.Server, tenant, namespace, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetBacklogQuotaMapRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetBundlesData(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetBundlesDataRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesClearNamespaceBacklog(ctx context.Context, tenant string, namespace string, params *NamespacesClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesClearNamespaceBacklogRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesClearNamespaceBacklogForSubscription(ctx context.Context, tenant string, namespace string, subscription string, params *NamespacesClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesClearNamespaceBacklogForSubscriptionRequest(c.Server, tenant, namespace, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesDeleteCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesDeleteCompactionThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetCompactionThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetCompactionThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetCompactionThresholdRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetCompactionThreshold(ctx context.Context, tenant string, namespace string, body NamespacesSetCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetCompactionThresholdRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveDeduplicationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetDeduplication(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetDeduplicationRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesModifyDeduplicationWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesModifyDeduplicationRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesModifyDeduplication(ctx context.Context, tenant string, namespace string, body NamespacesModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesModifyDeduplicationRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, body NamespacesSetDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, body NamespacesSetDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesDeleteDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesDeleteDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetDispatchRate(ctx context.Context, tenant string, namespace string, body NamespacesSetDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetEncryptionRequired(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetEncryptionRequiredRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesModifyEncryptionRequiredWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesModifyEncryptionRequiredRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesModifyEncryptionRequired(ctx context.Context, tenant string, namespace string, body NamespacesModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesModifyEncryptionRequiredRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveNamespaceEntryFilters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveNamespaceEntryFiltersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetEntryFiltersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetEntryFiltersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetEntryFiltersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetEntryFiltersPerTopic(ctx context.Context, tenant string, namespace string, body NamespacesSetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetEntryFiltersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveInactiveTopicPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetInactiveTopicPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, body NamespacesSetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetInactiveTopicPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetIsAllowAutoUpdateSchemaRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetIsAllowAutoUpdateSchemaWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetIsAllowAutoUpdateSchemaRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetIsAllowAutoUpdateSchema(ctx context.Context, tenant string, namespace string, body NamespacesSetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetIsAllowAutoUpdateSchemaRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveMaxConsumersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetMaxConsumersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxConsumersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxConsumersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxConsumersPerTopic(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxConsumersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveMaxProducersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetMaxProducersPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxProducersPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxProducersPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxProducersPerTopic(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxProducersPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveMaxTopicsPerNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetMaxTopicsPerNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxTopicsPerNamespaceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxTopicsPerNamespaceRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxTopicsPerNamespace(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxTopicsPerNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxTopicsPerNamespaceRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveMaxUnackedmessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveMaxUnackedmessagesPerConsumerRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetMaxUnackedMessagesPerConsumerRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxUnackedMessagesPerConsumerWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxUnackedMessagesPerConsumerRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxUnackedMessagesPerConsumer(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxUnackedMessagesPerConsumerRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveMaxUnackedmessagesPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetMaxUnackedmessagesPerSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetMaxUnackedmessagesPerSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxUnackedMessagesPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxUnackedMessagesPerSubscriptionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetMaxUnackedMessagesPerSubscription(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetMaxUnackedMessagesPerSubscriptionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveNamespaceMessageTTLRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetNamespaceMessageTTLRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetNamespaceMessageTTLWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetNamespaceMessageTTLRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetNamespaceMessageTTL(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetNamespaceMessageTTLRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesClearOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesClearOffloadDeletionLagRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetOffloadDeletionLag(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetOffloadDeletionLagRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetOffloadDeletionLagWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetOffloadDeletionLagRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetOffloadDeletionLag(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetOffloadDeletionLagRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetOffloadPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetOffloadPolicies(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetOffloadPoliciesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetOffloadThreshold(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetOffloadThresholdRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetOffloadThresholdWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetOffloadThresholdRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetOffloadThreshold(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetOffloadThresholdRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetOffloadThresholdInSeconds(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetOffloadThresholdInSecondsRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetOffloadThresholdInSeconds(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetOffloadThresholdInSecondsRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetPermissions(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetPermissionsRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetPermissionOnSubscription(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetPermissionOnSubscriptionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRevokePermissionsOnNamespace(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRevokePermissionsOnNamespaceRequest(c.Server, tenant, namespace, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGrantPermissionOnNamespaceWithBody(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGrantPermissionOnNamespaceRequestWithBody(c.Server, tenant, namespace, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGrantPermissionOnNamespace(ctx context.Context, tenant string, namespace string, role string, body NamespacesGrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGrantPermissionOnNamespaceRequest(c.Server, tenant, namespace, role, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesDeletePersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesDeletePersistenceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetPersistence(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetPersistenceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetPersistenceWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetPersistenceRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetPersistence(ctx context.Context, tenant string, namespace string, body NamespacesSetPersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetPersistenceRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetBookieAffinityGroupWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetBookieAffinityGroupRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetBookieAffinityGroup(ctx context.Context, tenant string, namespace string, body NamespacesSetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetBookieAffinityGroupRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesClearProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesClearPropertiesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetProperties(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetPropertiesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetPropertiesWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetPropertiesRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetProperties(ctx context.Context, tenant string, namespace string, body NamespacesSetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetPropertiesRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemovePropertyRequest(c.Server, tenant, namespace, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetProperty(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetPropertyRequest(c.Server, tenant, namespace, key)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetProperty(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetPropertyRequest(c.Server, tenant, namespace, key, value)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveOffloadPoliciesRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetNamespaceReplicationClustersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetNamespaceReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetNamespaceReplicationClustersRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetNamespaceReplicationClusters(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetNamespaceReplicationClustersRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveReplicatorDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetReplicatorDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, body NamespacesSetReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetReplicatorDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveNamespaceResourceGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetNamespaceResourceGroupRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetNamespaceResourceGroup(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetNamespaceResourceGroupRequest(c.Server, tenant, namespace, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveRetentionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveRetention(ctx context.Context, tenant string, namespace string, body NamespacesRemoveRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveRetentionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetRetention(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetRetentionRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetRetentionWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetRetentionRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetRetention(ctx context.Context, tenant string, namespace string, body NamespacesSetRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetRetentionRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesScanOffloadedLedgers(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesScanOffloadedLedgersRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetSchemaAutoUpdateCompatibilityStrategyRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSchemaAutoUpdateCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSchemaAutoUpdateCompatibilityStrategyRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetSchemaValidtionEnforced(ctx context.Context, tenant string, namespace string, params *NamespacesGetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetSchemaValidtionEnforcedRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSchemaValidationEnforcedRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesDeleteSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesDeleteSubscribeRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetSubscribeRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetSubscribeRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscribeRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscribeRate(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscribeRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetSubscriptionAuthModeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscriptionAuthModeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscriptionAuthModeRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscriptionAuthMode(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscriptionAuthModeRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesDeleteSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesDeleteSubscriptionDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetSubscriptionDispatchRateRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscriptionDispatchRateRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveSubscriptionExpirationTimeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetSubscriptionExpirationTimeRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscriptionExpirationTimeWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscriptionExpirationTimeRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscriptionExpirationTime(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscriptionExpirationTimeRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesRemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesRemoveSubscriptionTypesEnabledRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetSubscriptionTypesEnabledRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSetSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetTopics(ctx context.Context, tenant string, namespace string, params *NamespacesGetTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetTopicsRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesUnloadNamespace(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesUnloadNamespaceRequest(c.Server, tenant, namespace)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesUnsubscribeNamespace(ctx context.Context, tenant string, namespace string, subscription string, params *NamespacesUnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesUnsubscribeNamespaceRequest(c.Server, tenant, namespace, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesDeleteNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesDeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesDeleteNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesClearNamespaceBundleBacklog(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesClearNamespaceBundleBacklogRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesClearNamespaceBundleBacklogForSubscription(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *NamespacesClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesClearNamespaceBundleBacklogForSubscriptionRequest(c.Server, tenant, namespace, bundle, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSplitNamespaceBundleWithBody(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSplitNamespaceBundleRequestWithBody(c.Server, tenant, namespace, bundle, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesSplitNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, body NamespacesSplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesSplitNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesGetTopicHashPositions(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesGetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesGetTopicHashPositionsRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesUnloadNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesUnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesUnloadNamespaceBundleRequest(c.Server, tenant, namespace, bundle, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NamespacesUnsubscribeNamespaceBundle(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *NamespacesUnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNamespacesUnsubscribeNamespaceBundleRequest(c.Server, tenant, namespace, bundle, subscription, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetList(ctx context.Context, tenant string, namespace string, params *NonPersistentTopicsGetListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *NonPersistentTopicsGetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetPartitionedTopicListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetListFromBundle(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetListFromBundleRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeleteTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsCreateNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsCreateNonPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsExpireMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsExpireMessagesForAllSubscriptionsRequest(c.Server, tenant, namespace, topic, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveAutoSubscriptionCreationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetAutoSubscriptionCreationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetAutoSubscriptionCreationRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetBacklog(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetBacklogRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetBacklogQuotaRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetBacklogQuotaMapRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetBacklogSizeByMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsCompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsCompactionStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsCompact(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsCompactRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetCompactionThresholdRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsCreateMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsCreateMissedPartitionsRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetDeduplicationRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeleteDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeleteDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeleteDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeleteDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetEntryFiltersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsExamineMessage(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsExamineMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsExamineMessageRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeleteInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeleteInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetManagedLedgerInfoRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetInternalStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetLastMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *NonPersistentTopicsGetMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMessageByIdRequest(c.Server, tenant, namespace, topic, ledgerId, entryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetMaxConsumersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetMaxMessageSizeRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetMaxProducersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetMaxUnackedMessagesOnConsumerRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *NonPersistentTopicsGetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetMessageIdByTimestampRequest(c.Server, tenant, namespace, topic, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsOffloadStatus(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsOffloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsOffloadStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsTriggerOffload(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTriggerOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsTriggerOffloadRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetPartitionedStatsInternal(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsInternalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetPartitionedStatsInternalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetPartitionedStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeletePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeletePartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetPartitionedMetadataRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsUpdatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsUpdatePartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsCreatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsCreatePartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetPermissionsOnTopicRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRevokePermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRevokePermissionsOnTopicRequest(c.Server, tenant, namespace, topic, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGrantPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGrantPermissionsOnTopicRequestWithBody(c.Server, tenant, namespace, topic, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemovePersistence(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemovePersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetPersistence(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetPersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetPersistenceRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveProperties(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemovePropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetProperties(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetPropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsUpdatePropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsUpdatePropertiesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemovePublishRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemovePublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetPublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetPublishRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetReplicationClustersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveRetention(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetRetention(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetRetentionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetSchemaValidationEnforcedRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeleteShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeleteShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetShadowTopicsRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetStats(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetSubscribeRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsDeleteSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsDeleteSubscriptionRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsAnalyzeSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsAnalyzeSubscriptionBacklogRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsExpireTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsExpireTopicMessagesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsExpireTopicMessagesExpireTime(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireTopicMessagesExpireTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsExpireTopicMessagesExpireTimeRequest(c.Server, tenant, namespace, topic, subName, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsPeekNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *NonPersistentTopicsPeekNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsPeekNthMessageRequest(c.Server, tenant, namespace, topic, subName, messagePosition, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetSubscriptionPropertiesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsUpdateSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsUpdateSubscriptionPropertiesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetReplicatedSubscriptionStatusRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetReplicatedSubscriptionStatusRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsResetCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsResetCursorOnPositionRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsResetCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *NonPersistentTopicsResetCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsResetCursorRequest(c.Server, tenant, namespace, topic, subName, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSkipMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *NonPersistentTopicsSkipMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSkipMessagesRequest(c.Server, tenant, namespace, topic, subName, numMessages, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSkipAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSkipAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSkipAllMessagesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsCreateSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *NonPersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsCreateSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, subscriptionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetSubscriptionsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsTerminate(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsTerminateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsTerminatePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsTerminatePartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsTrimTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTrimTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsTrimTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsTruncateTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTruncateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsTruncateTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsUnloadTopic(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUnloadTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsUnloadTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsRemoveSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsRemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsRemoveSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsGetSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsGetSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) NonPersistentTopicsSetSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewNonPersistentTopicsSetSubscriptionLevelDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetList(ctx context.Context, tenant string, namespace string, params *PersistentTopicsGetListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetPartitionedTopicList(ctx context.Context, tenant string, namespace string, params *PersistentTopicsGetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetPartitionedTopicListRequest(c.Server, tenant, namespace, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeleteTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeleteTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsCreateNonPartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsCreateNonPartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsExpireMessagesForAllSubscriptions(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *PersistentTopicsExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsExpireMessagesForAllSubscriptionsRequest(c.Server, tenant, namespace, topic, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveAutoSubscriptionCreationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetAutoSubscriptionCreation(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetAutoSubscriptionCreationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetAutoSubscriptionCreationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetAutoSubscriptionCreationRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetBacklog(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetBacklogRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveBacklogQuota(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveBacklogQuotaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetBacklogQuotaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetBacklogQuotaRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetBacklogQuotaMap(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetBacklogQuotaMapRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetBacklogSizeByMessageId(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetBacklogSizeByMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsCompactionStatus(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCompactionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsCompactionStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsCompact(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCompactParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsCompactRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetCompactionThreshold(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetCompactionThresholdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetCompactionThresholdWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetCompactionThresholdRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsCreateMissedPartitions(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsCreateMissedPartitionsRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetDeduplication(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetDeduplicationRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetDeduplicationWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetDeduplicationRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeleteDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeleteDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetDeduplicationSnapshotInterval(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetDeduplicationSnapshotIntervalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetDeduplicationSnapshotIntervalWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetDeduplicationSnapshotIntervalRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeleteDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeleteDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetDelayedDeliveryPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetDelayedDeliveryPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetDelayedDeliveryPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetDelayedDeliveryPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetEntryFilters(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetEntryFiltersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetEntryFiltersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetEntryFiltersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetEntryFiltersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsExamineMessage(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsExamineMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsExamineMessageRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeleteInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeleteInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetInactiveTopicPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetInactiveTopicPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetInactiveTopicPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetInactiveTopicPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetManagedLedgerInfo(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetManagedLedgerInfoRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetInternalStats(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetInternalStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetInternalStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetLastMessageId(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetLastMessageIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetLastMessageIdRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMessageById(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *PersistentTopicsGetMessageByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMessageByIdRequest(c.Server, tenant, namespace, topic, ledgerId, entryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMaxConsumers(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMaxConsumersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetMaxConsumersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetMaxConsumersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMaxConsumersPerSubscription(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMaxConsumersPerSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetMaxConsumersPerSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetMaxConsumersPerSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMaxMessageSize(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMaxMessageSizeRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetMaxMessageSizeWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetMaxMessageSizeRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMaxProducers(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMaxProducersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetMaxProducersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetMaxProducersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMaxSubscriptionsPerTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMaxSubscriptionsPerTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetMaxSubscriptionsPerTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetMaxSubscriptionsPerTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeleteMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeleteMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMaxUnackedMessagesOnConsumer(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMaxUnackedMessagesOnConsumerRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetMaxUnackedMessagesOnConsumerWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetMaxUnackedMessagesOnConsumerRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeleteMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMaxUnackedMessagesOnSubscription(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMaxUnackedMessagesOnSubscriptionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetMaxUnackedMessagesOnSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetMessageTTL(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMessageTTLParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetMessageTTLRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetMessageIdByTimestamp(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *PersistentTopicsGetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetMessageIdByTimestampRequest(c.Server, tenant, namespace, topic, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsOffloadStatus(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsOffloadStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsOffloadStatusRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsTriggerOffload(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTriggerOffloadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsTriggerOffloadRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetOffloadPolicies(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetOffloadPoliciesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetOffloadPoliciesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetOffloadPoliciesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetPartitionedStatsInternal(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsInternalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetPartitionedStatsInternalRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetPartitionedStats(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetPartitionedStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeletePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeletePartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetPartitionedMetadata(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetPartitionedMetadataRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsUpdatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsUpdatePartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsCreatePartitionedTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsCreatePartitionedTopicRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetPermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetPermissionsOnTopicRequest(c.Server, tenant, namespace, topic)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRevokePermissionsOnTopic(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRevokePermissionsOnTopicRequest(c.Server, tenant, namespace, topic, role)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGrantPermissionsOnTopicWithBody(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGrantPermissionsOnTopicRequestWithBody(c.Server, tenant, namespace, topic, role, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemovePersistence(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemovePersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetPersistence(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPersistenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetPersistenceRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetPersistenceWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetPersistenceRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveProperties(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemovePropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetProperties(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetPropertiesRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsUpdatePropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsUpdatePropertiesRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemovePublishRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemovePublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetPublishRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPublishRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetPublishRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetPublishRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetPublishRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetReplicationClusters(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicationClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetReplicationClustersRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetReplicationClustersWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetReplicationClustersRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetReplicatorDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetReplicatorDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetReplicatorDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetReplicatorDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveRetention(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetRetention(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetRetentionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetRetentionRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetRetentionWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetRetentionRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetSchemaCompatibilityStrategy(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetSchemaCompatibilityStrategyRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetSchemaCompatibilityStrategyWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetSchemaCompatibilityStrategyRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetSchemaValidationEnforced(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetSchemaValidationEnforcedRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetSchemaValidationEnforcedWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetSchemaValidationEnforcedRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeleteShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeleteShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetShadowTopics(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetShadowTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetShadowTopicsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetShadowTopicsWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetShadowTopicsRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetStats(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetStatsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetSubscribeRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscribeRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetSubscribeRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetSubscribeRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetSubscribeRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsDeleteSubscription(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsDeleteSubscriptionRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsAnalyzeSubscriptionBacklogWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsAnalyzeSubscriptionBacklogRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsExpireTopicMessagesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsExpireTopicMessagesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsExpireTopicMessagesExpireTime(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *PersistentTopicsExpireTopicMessagesExpireTimeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsExpireTopicMessagesExpireTimeRequest(c.Server, tenant, namespace, topic, subName, expireTimeInSeconds, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsPeekNthMessage(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PersistentTopicsPeekNthMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsPeekNthMessageRequest(c.Server, tenant, namespace, topic, subName, messagePosition, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetSubscriptionProperties(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetSubscriptionPropertiesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsUpdateSubscriptionPropertiesWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsUpdateSubscriptionPropertiesRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetReplicatedSubscriptionStatus(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetReplicatedSubscriptionStatusRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetReplicatedSubscriptionStatusWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetReplicatedSubscriptionStatusRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsResetCursorOnPositionWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsResetCursorOnPositionRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsResetCursor(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *PersistentTopicsResetCursorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsResetCursorRequest(c.Server, tenant, namespace, topic, subName, timestamp, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSkipMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *PersistentTopicsSkipMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSkipMessagesRequest(c.Server, tenant, namespace, topic, subName, numMessages, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSkipAllMessages(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSkipAllMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSkipAllMessagesRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsCreateSubscriptionWithBody(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *PersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsCreateSubscriptionRequestWithBody(c.Server, tenant, namespace, topic, subscriptionName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetSubscriptionDispatchRate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetSubscriptionDispatchRateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetSubscriptionDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetSubscriptionDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetSubscriptionTypesEnabled(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetSubscriptionTypesEnabledRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetSubscriptionTypesEnabledWithBody(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetSubscriptionTypesEnabledRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetSubscriptions(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetSubscriptionsRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsTerminate(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTerminateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsTerminateRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsTerminatePartitionedTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsTerminatePartitionedTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsTrimTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTrimTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsTrimTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsTruncateTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTruncateTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsTruncateTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsUnloadTopic(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUnloadTopicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsUnloadTopicRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsRemoveSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsRemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsRemoveSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsGetSubscriptionLevelDispatchRate(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsGetSubscriptionLevelDispatchRateRequest(c.Server, tenant, namespace, topic, subName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PersistentTopicsSetSubscriptionLevelDispatchRateWithBody(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPersistentTopicsSetSubscriptionLevelDispatchRateRequestWithBody(c.Server, tenant, namespace, topic, subName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceQuotasGetDefaultResourceQuota(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceQuotasGetDefaultResourceQuotaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceQuotasSetDefaultResourceQuotaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceQuotasSetDefaultResourceQuotaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceQuotasSetDefaultResourceQuota(ctx context.Context, body ResourceQuotasSetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceQuotasSetDefaultResourceQuotaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceQuotasRemoveNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceQuotasRemoveNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceQuotasGetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceQuotasGetNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceQuotasSetNamespaceBundleResourceQuotaWithBody(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceQuotasSetNamespaceBundleResourceQuotaRequestWithBody(c.Server, tenant, namespace, bundle, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceQuotasSetNamespaceBundleResourceQuota(ctx context.Context, tenant string, namespace string, bundle string, body ResourceQuotasSetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceQuotasSetNamespaceBundleResourceQuotaRequest(c.Server, tenant, namespace, bundle, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceGroupsGetResourceGroups(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceGroupsGetResourceGroupsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceGroupsDeleteResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceGroupsDeleteResourceGroupRequest(c.Server, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceGroupsGetResourceGroup(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceGroupsGetResourceGroupRequest(c.Server, resourcegroup)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceGroupsCreateOrUpdateResourceGroupWithBody(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceGroupsCreateOrUpdateResourceGroupRequestWithBody(c.Server, resourcegroup, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResourceGroupsCreateOrUpdateResourceGroup(ctx context.Context, resourcegroup string, body ResourceGroupsCreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResourceGroupsCreateOrUpdateResourceGroupRequest(c.Server, resourcegroup, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourceTestCompatibilityWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourceTestCompatibilityRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourceTestCompatibility(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, body SchemasResourceTestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourceTestCompatibilityRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourceDeleteSchema(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceDeleteSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourceDeleteSchemaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourceGetSchema(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetSchemaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourceGetSchemaRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourcePostSchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourcePostSchemaRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourcePostSchema(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, body SchemasResourcePostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourcePostSchemaRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourceGetSchemaByVersion(ctx context.Context, tenant string, namespace string, topic string, version string, params *SchemasResourceGetSchemaByVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourceGetSchemaByVersionRequest(c.Server, tenant, namespace, topic, version, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourceGetAllSchemas(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetAllSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourceGetAllSchemasRequest(c.Server, tenant, namespace, topic, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourceGetVersionBySchemaWithBody(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourceGetVersionBySchemaRequestWithBody(c.Server, tenant, namespace, topic, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SchemasResourceGetVersionBySchema(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, body SchemasResourceGetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSchemasResourceGetVersionBySchemaRequest(c.Server, tenant, namespace, topic, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantsBaseGetTenants(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantsBaseGetTenantsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantsBaseDeleteTenant(ctx context.Context, tenant string, params *TenantsBaseDeleteTenantParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantsBaseDeleteTenantRequest(c.Server, tenant, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantsBaseGetTenantAdmin(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantsBaseGetTenantAdminRequest(c.Server, tenant)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantsBaseUpdateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantsBaseUpdateTenantRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantsBaseUpdateTenant(ctx context.Context, tenant string, body TenantsBaseUpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantsBaseUpdateTenantRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantsBaseCreateTenantWithBody(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantsBaseCreateTenantRequestWithBody(c.Server, tenant, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TenantsBaseCreateTenant(ctx context.Context, tenant string, body TenantsBaseCreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTenantsBaseCreateTenantRequest(c.Server, tenant, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerStatsGetStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerStatsGetStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerStatsGetMetrics(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerStatsGetMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGetAssignments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetAssignmentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetClusterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGetClusterLeader(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetClusterLeaderRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerIsLeaderReady(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerIsLeaderReadyRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGetConnectorsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetConnectorsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGetDrainStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetDrainStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerDrain(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerDrainRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerGetDrainStatusFromLeader(ctx context.Context, params *WorkerGetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerGetDrainStatusFromLeaderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerDrainAtLeader(ctx context.Context, params *WorkerDrainAtLeaderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerDrainAtLeaderRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WorkerRebalance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWorkerRebalanceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewBookiesGetAllBookiesRequest generates requests for BookiesGetAllBookies
func NewBookiesGetAllBookiesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/all")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBookiesGetBookiesRackInfoRequest generates requests for BookiesGetBookiesRackInfo
func NewBookiesGetBookiesRackInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBookiesDeleteBookieRackInfoRequest generates requests for BookiesDeleteBookieRackInfo
func NewBookiesDeleteBookieRackInfoRequest(server string, bookie string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBookiesGetBookieRackInfoRequest generates requests for BookiesGetBookieRackInfo
func NewBookiesGetBookieRackInfoRequest(server string, bookie string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBookiesUpdateBookieRackInfoRequest generates requests for BookiesUpdateBookieRackInfo
func NewBookiesUpdateBookieRackInfoRequest(server string, bookie string, params *BookiesUpdateBookieRackInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bookie", runtime.ParamLocationPath, bookie)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bookies/racks-info/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokerStatsBaseGetAllocatorStatsRequest generates requests for BrokerStatsBaseGetAllocatorStats
func NewBrokerStatsBaseGetAllocatorStatsRequest(server string, allocator string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "allocator", runtime.ParamLocationPath, allocator)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/allocator-stats/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokerStatsBaseGetPendingBookieOpsStatsRequest generates requests for BrokerStatsBaseGetPendingBookieOpsStats
func NewBrokerStatsBaseGetPendingBookieOpsStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/bookieops")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokerStatsGetBrokerResourceAvailabilityRequest generates requests for BrokerStatsGetBrokerResourceAvailability
func NewBrokerStatsGetBrokerResourceAvailabilityRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/broker-resource-availability/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokerStatsBaseGetLoadReportRequest generates requests for BrokerStatsBaseGetLoadReport
func NewBrokerStatsBaseGetLoadReportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/load-report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokerStatsBaseGetMBeansRequest generates requests for BrokerStatsBaseGetMBeans
func NewBrokerStatsBaseGetMBeansRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/mbeans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokerStatsBaseGetMetricsRequest generates requests for BrokerStatsBaseGetMetrics
func NewBrokerStatsBaseGetMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokerStatsGetTopics2Request generates requests for BrokerStatsGetTopics2
func NewBrokerStatsGetTopics2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/broker-stats/topics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseGetActiveBrokersRequest generates requests for BrokersBaseGetActiveBrokers
func NewBrokersBaseGetActiveBrokersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseBacklogQuotaCheckRequest generates requests for BrokersBaseBacklogQuotaCheck
func NewBrokersBaseBacklogQuotaCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/backlog-quota-check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseGetDynamicConfigurationNameRequest generates requests for BrokersBaseGetDynamicConfigurationName
func NewBrokersBaseGetDynamicConfigurationNameRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseGetRuntimeConfigurationRequest generates requests for BrokersBaseGetRuntimeConfiguration
func NewBrokersBaseGetRuntimeConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/runtime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseGetAllDynamicConfigurationsRequest generates requests for BrokersBaseGetAllDynamicConfigurations
func NewBrokersBaseGetAllDynamicConfigurationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/values")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseDeleteDynamicConfigurationRequest generates requests for BrokersBaseDeleteDynamicConfiguration
func NewBrokersBaseDeleteDynamicConfigurationRequest(server string, configName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "configName", runtime.ParamLocationPath, configName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseUpdateDynamicConfigurationRequest generates requests for BrokersBaseUpdateDynamicConfiguration
func NewBrokersBaseUpdateDynamicConfigurationRequest(server string, configName string, configValue string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "configName", runtime.ParamLocationPath, configName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "configValue", runtime.ParamLocationPath, configValue)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/configuration/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseHealthCheckRequest generates requests for BrokersBaseHealthCheck
func NewBrokersBaseHealthCheckRequest(server string, params *BrokersBaseHealthCheckParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TopicVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topicVersion", runtime.ParamLocationQuery, *params.TopicVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseGetInternalConfigurationDataRequest generates requests for BrokersBaseGetInternalConfigurationData
func NewBrokersBaseGetInternalConfigurationDataRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/internal-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseGetLeaderBrokerRequest generates requests for BrokersBaseGetLeaderBroker
func NewBrokersBaseGetLeaderBrokerRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/leaderBroker")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseIsReadyRequest generates requests for BrokersBaseIsReady
func NewBrokersBaseIsReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseShutDownBrokerGracefullyRequest generates requests for BrokersBaseShutDownBrokerGracefully
func NewBrokersBaseShutDownBrokerGracefullyRequest(server string, params *BrokersBaseShutDownBrokerGracefullyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/shutdown")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.MaxConcurrentUnloadPerSec != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxConcurrentUnloadPerSec", runtime.ParamLocationQuery, *params.MaxConcurrentUnloadPerSec); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForcedTerminateTopic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "forcedTerminateTopic", runtime.ParamLocationQuery, *params.ForcedTerminateTopic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseVersionRequest generates requests for BrokersBaseVersion
func NewBrokersBaseVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseGetOwnedNamespacesRequest generates requests for BrokersBaseGetOwnedNamespaces
func NewBrokersBaseGetOwnedNamespacesRequest(server string, clusterName string, brokerWebserviceurl string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "clusterName", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "broker-webserviceurl", runtime.ParamLocationPath, brokerWebserviceurl)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/%s/%s/ownedNamespaces", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBrokersBaseGetActiveBrokersByClusterRequest generates requests for BrokersBaseGetActiveBrokersByCluster
func NewBrokersBaseGetActiveBrokersByClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/brokers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseGetClustersRequest generates requests for ClustersBaseGetClusters
func NewClustersBaseGetClustersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseDeleteClusterRequest generates requests for ClustersBaseDeleteCluster
func NewClustersBaseDeleteClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseGetClusterRequest generates requests for ClustersBaseGetCluster
func NewClustersBaseGetClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseUpdateClusterRequestWithBody generates requests for ClustersBaseUpdateCluster with any type of body
func NewClustersBaseUpdateClusterRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClustersBaseCreateClusterRequestWithBody generates requests for ClustersBaseCreateCluster with any type of body
func NewClustersBaseCreateClusterRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClustersBaseGetFailureDomainsRequest generates requests for ClustersBaseGetFailureDomains
func NewClustersBaseGetFailureDomainsRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseDeleteFailureDomainRequest generates requests for ClustersBaseDeleteFailureDomain
func NewClustersBaseDeleteFailureDomainRequest(server string, cluster string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseGetDomainRequest generates requests for ClustersBaseGetDomain
func NewClustersBaseGetDomainRequest(server string, cluster string, domainName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseSetFailureDomainRequestWithBody generates requests for ClustersBaseSetFailureDomain with any type of body
func NewClustersBaseSetFailureDomainRequestWithBody(server string, cluster string, domainName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "domainName", runtime.ParamLocationPath, domainName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/failureDomains/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClustersBaseUpdateClusterMigrationRequestWithBody generates requests for ClustersBaseUpdateClusterMigration with any type of body
func NewClustersBaseUpdateClusterMigrationRequestWithBody(server string, cluster string, params *ClustersBaseUpdateClusterMigrationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/migrate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "migrated", runtime.ParamLocationQuery, params.Migrated); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClustersBaseGetNamespaceIsolationPoliciesRequest generates requests for ClustersBaseGetNamespaceIsolationPolicies
func NewClustersBaseGetNamespaceIsolationPoliciesRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseGetBrokersWithNamespaceIsolationPolicyRequest generates requests for ClustersBaseGetBrokersWithNamespaceIsolationPolicy
func NewClustersBaseGetBrokersWithNamespaceIsolationPolicyRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/brokers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseGetBrokerWithNamespaceIsolationPolicyRequest generates requests for ClustersBaseGetBrokerWithNamespaceIsolationPolicy
func NewClustersBaseGetBrokerWithNamespaceIsolationPolicyRequest(server string, cluster string, broker string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "broker", runtime.ParamLocationPath, broker)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/brokers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseDeleteNamespaceIsolationPolicyRequest generates requests for ClustersBaseDeleteNamespaceIsolationPolicy
func NewClustersBaseDeleteNamespaceIsolationPolicyRequest(server string, cluster string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseGetNamespaceIsolationPolicyRequest generates requests for ClustersBaseGetNamespaceIsolationPolicy
func NewClustersBaseGetNamespaceIsolationPolicyRequest(server string, cluster string, policyName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseSetNamespaceIsolationPolicyRequestWithBody generates requests for ClustersBaseSetNamespaceIsolationPolicy with any type of body
func NewClustersBaseSetNamespaceIsolationPolicyRequestWithBody(server string, cluster string, policyName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "policyName", runtime.ParamLocationPath, policyName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/namespaceIsolationPolicies/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClustersBaseGetPeerClusterRequest generates requests for ClustersBaseGetPeerCluster
func NewClustersBaseGetPeerClusterRequest(server string, cluster string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/peers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClustersBaseSetPeerClusterNamesRequestWithBody generates requests for ClustersBaseSetPeerClusterNames with any type of body
func NewClustersBaseSetPeerClusterNamesRequestWithBody(server string, cluster string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clusters/%s/peers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetAntiAffinityNamespacesRequest generates requests for NamespacesGetAntiAffinityNamespaces
func NewNamespacesGetAntiAffinityNamespacesRequest(server string, cluster string, group string, params *NamespacesGetAntiAffinityNamespacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster", runtime.ParamLocationPath, cluster)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group", runtime.ParamLocationPath, group)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/antiAffinity/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Tenant != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tenant", runtime.ParamLocationQuery, *params.Tenant); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesDeleteBookieAffinityGroupRequest generates requests for NamespacesDeleteBookieAffinityGroup
func NewNamespacesDeleteBookieAffinityGroupRequest(server string, property string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "property", runtime.ParamLocationPath, property)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetBookieAffinityGroupRequest generates requests for NamespacesGetBookieAffinityGroup
func NewNamespacesGetBookieAffinityGroupRequest(server string, property string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "property", runtime.ParamLocationPath, property)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetTenantNamespacesRequest generates requests for NamespacesGetTenantNamespaces
func NewNamespacesGetTenantNamespacesRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesDeleteNamespaceRequest generates requests for NamespacesDeleteNamespace
func NewNamespacesDeleteNamespaceRequest(server string, tenant string, namespace string, params *NamespacesDeleteNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetPoliciesRequest generates requests for NamespacesGetPolicies
func NewNamespacesGetPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesCreateNamespaceRequest calls the generic NamespacesCreateNamespace builder with application/json body
func NewNamespacesCreateNamespaceRequest(server string, tenant string, namespace string, body NamespacesCreateNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesCreateNamespaceRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesCreateNamespaceRequestWithBody generates requests for NamespacesCreateNamespace with any type of body
func NewNamespacesCreateNamespaceRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveNamespaceAntiAffinityGroupRequest generates requests for NamespacesRemoveNamespaceAntiAffinityGroup
func NewNamespacesRemoveNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetNamespaceAntiAffinityGroupRequest generates requests for NamespacesGetNamespaceAntiAffinityGroup
func NewNamespacesGetNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetNamespaceAntiAffinityGroupRequest calls the generic NamespacesSetNamespaceAntiAffinityGroup builder with application/json body
func NewNamespacesSetNamespaceAntiAffinityGroupRequest(server string, tenant string, namespace string, body NamespacesSetNamespaceAntiAffinityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetNamespaceAntiAffinityGroupRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetNamespaceAntiAffinityGroupRequestWithBody generates requests for NamespacesSetNamespaceAntiAffinityGroup with any type of body
func NewNamespacesSetNamespaceAntiAffinityGroupRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/antiAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveAutoSubscriptionCreationRequest generates requests for NamespacesRemoveAutoSubscriptionCreation
func NewNamespacesRemoveAutoSubscriptionCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetAutoSubscriptionCreationRequest generates requests for NamespacesGetAutoSubscriptionCreation
func NewNamespacesGetAutoSubscriptionCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetAutoSubscriptionCreationRequest calls the generic NamespacesSetAutoSubscriptionCreation builder with application/json body
func NewNamespacesSetAutoSubscriptionCreationRequest(server string, tenant string, namespace string, body NamespacesSetAutoSubscriptionCreationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetAutoSubscriptionCreationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetAutoSubscriptionCreationRequestWithBody generates requests for NamespacesSetAutoSubscriptionCreation with any type of body
func NewNamespacesSetAutoSubscriptionCreationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveAutoTopicCreationRequest generates requests for NamespacesRemoveAutoTopicCreation
func NewNamespacesRemoveAutoTopicCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetAutoTopicCreationRequest generates requests for NamespacesGetAutoTopicCreation
func NewNamespacesGetAutoTopicCreationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetAutoTopicCreationRequest calls the generic NamespacesSetAutoTopicCreation builder with application/json body
func NewNamespacesSetAutoTopicCreationRequest(server string, tenant string, namespace string, body NamespacesSetAutoTopicCreationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetAutoTopicCreationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetAutoTopicCreationRequestWithBody generates requests for NamespacesSetAutoTopicCreation with any type of body
func NewNamespacesSetAutoTopicCreationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/autoTopicCreation", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveBacklogQuotaRequest generates requests for NamespacesRemoveBacklogQuota
func NewNamespacesRemoveBacklogQuotaRequest(server string, tenant string, namespace string, params *NamespacesRemoveBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuota", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BacklogQuotaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetBacklogQuotaRequest calls the generic NamespacesSetBacklogQuota builder with application/json body
func NewNamespacesSetBacklogQuotaRequest(server string, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, body NamespacesSetBacklogQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetBacklogQuotaRequestWithBody(server, tenant, namespace, params, "application/json", bodyReader)
}

// NewNamespacesSetBacklogQuotaRequestWithBody generates requests for NamespacesSetBacklogQuota with any type of body
func NewNamespacesSetBacklogQuotaRequestWithBody(server string, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuota", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BacklogQuotaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetBacklogQuotaMapRequest generates requests for NamespacesGetBacklogQuotaMap
func NewNamespacesGetBacklogQuotaMapRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/backlogQuotaMap", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetBundlesDataRequest generates requests for NamespacesGetBundlesData
func NewNamespacesGetBundlesDataRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/bundles", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesClearNamespaceBacklogRequest generates requests for NamespacesClearNamespaceBacklog
func NewNamespacesClearNamespaceBacklogRequest(server string, tenant string, namespace string, params *NamespacesClearNamespaceBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/clearBacklog", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesClearNamespaceBacklogForSubscriptionRequest generates requests for NamespacesClearNamespaceBacklogForSubscription
func NewNamespacesClearNamespaceBacklogForSubscriptionRequest(server string, tenant string, namespace string, subscription string, params *NamespacesClearNamespaceBacklogForSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/clearBacklog/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesDeleteCompactionThresholdRequest generates requests for NamespacesDeleteCompactionThreshold
func NewNamespacesDeleteCompactionThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetCompactionThresholdRequest generates requests for NamespacesGetCompactionThreshold
func NewNamespacesGetCompactionThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetCompactionThresholdRequest calls the generic NamespacesSetCompactionThreshold builder with application/json body
func NewNamespacesSetCompactionThresholdRequest(server string, tenant string, namespace string, body NamespacesSetCompactionThresholdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetCompactionThresholdRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetCompactionThresholdRequestWithBody generates requests for NamespacesSetCompactionThreshold with any type of body
func NewNamespacesSetCompactionThresholdRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/compactionThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveDeduplicationRequest generates requests for NamespacesRemoveDeduplication
func NewNamespacesRemoveDeduplicationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetDeduplicationRequest generates requests for NamespacesGetDeduplication
func NewNamespacesGetDeduplicationRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesModifyDeduplicationRequest calls the generic NamespacesModifyDeduplication builder with application/json body
func NewNamespacesModifyDeduplicationRequest(server string, tenant string, namespace string, body NamespacesModifyDeduplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesModifyDeduplicationRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesModifyDeduplicationRequestWithBody generates requests for NamespacesModifyDeduplication with any type of body
func NewNamespacesModifyDeduplicationRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetDeduplicationSnapshotIntervalRequest generates requests for NamespacesGetDeduplicationSnapshotInterval
func NewNamespacesGetDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetDeduplicationSnapshotIntervalRequest calls the generic NamespacesSetDeduplicationSnapshotInterval builder with application/json body
func NewNamespacesSetDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, body NamespacesSetDeduplicationSnapshotIntervalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetDeduplicationSnapshotIntervalRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetDeduplicationSnapshotIntervalRequestWithBody generates requests for NamespacesSetDeduplicationSnapshotInterval with any type of body
func NewNamespacesSetDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveDelayedDeliveryPoliciesRequest generates requests for NamespacesRemoveDelayedDeliveryPolicies
func NewNamespacesRemoveDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetDelayedDeliveryPoliciesRequest generates requests for NamespacesGetDelayedDeliveryPolicies
func NewNamespacesGetDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetDelayedDeliveryPoliciesRequest calls the generic NamespacesSetDelayedDeliveryPolicies builder with application/json body
func NewNamespacesSetDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, body NamespacesSetDelayedDeliveryPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetDelayedDeliveryPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetDelayedDeliveryPoliciesRequestWithBody generates requests for NamespacesSetDelayedDeliveryPolicies with any type of body
func NewNamespacesSetDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/delayedDelivery", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesDeleteDispatchRateRequest generates requests for NamespacesDeleteDispatchRate
func NewNamespacesDeleteDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetDispatchRateRequest generates requests for NamespacesGetDispatchRate
func NewNamespacesGetDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetDispatchRateRequest calls the generic NamespacesSetDispatchRate builder with application/json body
func NewNamespacesSetDispatchRateRequest(server string, tenant string, namespace string, body NamespacesSetDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetDispatchRateRequestWithBody generates requests for NamespacesSetDispatchRate with any type of body
func NewNamespacesSetDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/dispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetEncryptionRequiredRequest generates requests for NamespacesGetEncryptionRequired
func NewNamespacesGetEncryptionRequiredRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/encryptionRequired", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesModifyEncryptionRequiredRequest calls the generic NamespacesModifyEncryptionRequired builder with application/json body
func NewNamespacesModifyEncryptionRequiredRequest(server string, tenant string, namespace string, body NamespacesModifyEncryptionRequiredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesModifyEncryptionRequiredRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesModifyEncryptionRequiredRequestWithBody generates requests for NamespacesModifyEncryptionRequired with any type of body
func NewNamespacesModifyEncryptionRequiredRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/encryptionRequired", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveNamespaceEntryFiltersRequest generates requests for NamespacesRemoveNamespaceEntryFilters
func NewNamespacesRemoveNamespaceEntryFiltersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetEntryFiltersPerTopicRequest generates requests for NamespacesGetEntryFiltersPerTopic
func NewNamespacesGetEntryFiltersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetEntryFiltersPerTopicRequest calls the generic NamespacesSetEntryFiltersPerTopic builder with application/json body
func NewNamespacesSetEntryFiltersPerTopicRequest(server string, tenant string, namespace string, body NamespacesSetEntryFiltersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetEntryFiltersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetEntryFiltersPerTopicRequestWithBody generates requests for NamespacesSetEntryFiltersPerTopic with any type of body
func NewNamespacesSetEntryFiltersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/entryFilters", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveInactiveTopicPoliciesRequest generates requests for NamespacesRemoveInactiveTopicPolicies
func NewNamespacesRemoveInactiveTopicPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetInactiveTopicPoliciesRequest generates requests for NamespacesGetInactiveTopicPolicies
func NewNamespacesGetInactiveTopicPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetInactiveTopicPoliciesRequest calls the generic NamespacesSetInactiveTopicPolicies builder with application/json body
func NewNamespacesSetInactiveTopicPoliciesRequest(server string, tenant string, namespace string, body NamespacesSetInactiveTopicPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetInactiveTopicPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetInactiveTopicPoliciesRequestWithBody generates requests for NamespacesSetInactiveTopicPolicies with any type of body
func NewNamespacesSetInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetIsAllowAutoUpdateSchemaRequest generates requests for NamespacesGetIsAllowAutoUpdateSchema
func NewNamespacesGetIsAllowAutoUpdateSchemaRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/isAllowAutoUpdateSchema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetIsAllowAutoUpdateSchemaRequest calls the generic NamespacesSetIsAllowAutoUpdateSchema builder with application/json body
func NewNamespacesSetIsAllowAutoUpdateSchemaRequest(server string, tenant string, namespace string, body NamespacesSetIsAllowAutoUpdateSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetIsAllowAutoUpdateSchemaRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetIsAllowAutoUpdateSchemaRequestWithBody generates requests for NamespacesSetIsAllowAutoUpdateSchema with any type of body
func NewNamespacesSetIsAllowAutoUpdateSchemaRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/isAllowAutoUpdateSchema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveMaxConsumersPerSubscriptionRequest generates requests for NamespacesRemoveMaxConsumersPerSubscription
func NewNamespacesRemoveMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetMaxConsumersPerSubscriptionRequest generates requests for NamespacesGetMaxConsumersPerSubscription
func NewNamespacesGetMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetMaxConsumersPerSubscriptionRequest calls the generic NamespacesSetMaxConsumersPerSubscription builder with application/json body
func NewNamespacesSetMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, body NamespacesSetMaxConsumersPerSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetMaxConsumersPerSubscriptionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetMaxConsumersPerSubscriptionRequestWithBody generates requests for NamespacesSetMaxConsumersPerSubscription with any type of body
func NewNamespacesSetMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveMaxConsumersPerTopicRequest generates requests for NamespacesRemoveMaxConsumersPerTopic
func NewNamespacesRemoveMaxConsumersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetMaxConsumersPerTopicRequest generates requests for NamespacesGetMaxConsumersPerTopic
func NewNamespacesGetMaxConsumersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetMaxConsumersPerTopicRequest calls the generic NamespacesSetMaxConsumersPerTopic builder with application/json body
func NewNamespacesSetMaxConsumersPerTopicRequest(server string, tenant string, namespace string, body NamespacesSetMaxConsumersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetMaxConsumersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetMaxConsumersPerTopicRequestWithBody generates requests for NamespacesSetMaxConsumersPerTopic with any type of body
func NewNamespacesSetMaxConsumersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxConsumersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveMaxProducersPerTopicRequest generates requests for NamespacesRemoveMaxProducersPerTopic
func NewNamespacesRemoveMaxProducersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetMaxProducersPerTopicRequest generates requests for NamespacesGetMaxProducersPerTopic
func NewNamespacesGetMaxProducersPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetMaxProducersPerTopicRequest calls the generic NamespacesSetMaxProducersPerTopic builder with application/json body
func NewNamespacesSetMaxProducersPerTopicRequest(server string, tenant string, namespace string, body NamespacesSetMaxProducersPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetMaxProducersPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetMaxProducersPerTopicRequestWithBody generates requests for NamespacesSetMaxProducersPerTopic with any type of body
func NewNamespacesSetMaxProducersPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxProducersPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveMaxSubscriptionsPerTopicRequest generates requests for NamespacesRemoveMaxSubscriptionsPerTopic
func NewNamespacesRemoveMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetMaxSubscriptionsPerTopicRequest generates requests for NamespacesGetMaxSubscriptionsPerTopic
func NewNamespacesGetMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetMaxSubscriptionsPerTopicRequest calls the generic NamespacesSetMaxSubscriptionsPerTopic builder with application/json body
func NewNamespacesSetMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, body NamespacesSetMaxSubscriptionsPerTopicJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetMaxSubscriptionsPerTopicRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetMaxSubscriptionsPerTopicRequestWithBody generates requests for NamespacesSetMaxSubscriptionsPerTopic with any type of body
func NewNamespacesSetMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveMaxTopicsPerNamespaceRequest generates requests for NamespacesRemoveMaxTopicsPerNamespace
func NewNamespacesRemoveMaxTopicsPerNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetMaxTopicsPerNamespaceRequest generates requests for NamespacesGetMaxTopicsPerNamespace
func NewNamespacesGetMaxTopicsPerNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetMaxTopicsPerNamespaceRequest calls the generic NamespacesSetMaxTopicsPerNamespace builder with application/json body
func NewNamespacesSetMaxTopicsPerNamespaceRequest(server string, tenant string, namespace string, body NamespacesSetMaxTopicsPerNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetMaxTopicsPerNamespaceRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetMaxTopicsPerNamespaceRequestWithBody generates requests for NamespacesSetMaxTopicsPerNamespace with any type of body
func NewNamespacesSetMaxTopicsPerNamespaceRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxTopicsPerNamespace", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveMaxUnackedmessagesPerConsumerRequest generates requests for NamespacesRemoveMaxUnackedmessagesPerConsumer
func NewNamespacesRemoveMaxUnackedmessagesPerConsumerRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetMaxUnackedMessagesPerConsumerRequest generates requests for NamespacesGetMaxUnackedMessagesPerConsumer
func NewNamespacesGetMaxUnackedMessagesPerConsumerRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetMaxUnackedMessagesPerConsumerRequest calls the generic NamespacesSetMaxUnackedMessagesPerConsumer builder with application/json body
func NewNamespacesSetMaxUnackedMessagesPerConsumerRequest(server string, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerConsumerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetMaxUnackedMessagesPerConsumerRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetMaxUnackedMessagesPerConsumerRequestWithBody generates requests for NamespacesSetMaxUnackedMessagesPerConsumer with any type of body
func NewNamespacesSetMaxUnackedMessagesPerConsumerRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerConsumer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveMaxUnackedmessagesPerSubscriptionRequest generates requests for NamespacesRemoveMaxUnackedmessagesPerSubscription
func NewNamespacesRemoveMaxUnackedmessagesPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetMaxUnackedmessagesPerSubscriptionRequest generates requests for NamespacesGetMaxUnackedmessagesPerSubscription
func NewNamespacesGetMaxUnackedmessagesPerSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetMaxUnackedMessagesPerSubscriptionRequest calls the generic NamespacesSetMaxUnackedMessagesPerSubscription builder with application/json body
func NewNamespacesSetMaxUnackedMessagesPerSubscriptionRequest(server string, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetMaxUnackedMessagesPerSubscriptionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetMaxUnackedMessagesPerSubscriptionRequestWithBody generates requests for NamespacesSetMaxUnackedMessagesPerSubscription with any type of body
func NewNamespacesSetMaxUnackedMessagesPerSubscriptionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/maxUnackedMessagesPerSubscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveNamespaceMessageTTLRequest generates requests for NamespacesRemoveNamespaceMessageTTL
func NewNamespacesRemoveNamespaceMessageTTLRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetNamespaceMessageTTLRequest generates requests for NamespacesGetNamespaceMessageTTL
func NewNamespacesGetNamespaceMessageTTLRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetNamespaceMessageTTLRequest calls the generic NamespacesSetNamespaceMessageTTL builder with application/json body
func NewNamespacesSetNamespaceMessageTTLRequest(server string, tenant string, namespace string, body NamespacesSetNamespaceMessageTTLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetNamespaceMessageTTLRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetNamespaceMessageTTLRequestWithBody generates requests for NamespacesSetNamespaceMessageTTL with any type of body
func NewNamespacesSetNamespaceMessageTTLRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/messageTTL", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesClearOffloadDeletionLagRequest generates requests for NamespacesClearOffloadDeletionLag
func NewNamespacesClearOffloadDeletionLagRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetOffloadDeletionLagRequest generates requests for NamespacesGetOffloadDeletionLag
func NewNamespacesGetOffloadDeletionLagRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetOffloadDeletionLagRequest calls the generic NamespacesSetOffloadDeletionLag builder with application/json body
func NewNamespacesSetOffloadDeletionLagRequest(server string, tenant string, namespace string, body NamespacesSetOffloadDeletionLagJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetOffloadDeletionLagRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetOffloadDeletionLagRequestWithBody generates requests for NamespacesSetOffloadDeletionLag with any type of body
func NewNamespacesSetOffloadDeletionLagRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadDeletionLagMs", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetOffloadPoliciesRequest generates requests for NamespacesGetOffloadPolicies
func NewNamespacesGetOffloadPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetOffloadPoliciesRequest calls the generic NamespacesSetOffloadPolicies builder with application/json body
func NewNamespacesSetOffloadPoliciesRequest(server string, tenant string, namespace string, body NamespacesSetOffloadPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetOffloadPoliciesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetOffloadPoliciesRequestWithBody generates requests for NamespacesSetOffloadPolicies with any type of body
func NewNamespacesSetOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetOffloadThresholdRequest generates requests for NamespacesGetOffloadThreshold
func NewNamespacesGetOffloadThresholdRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetOffloadThresholdRequest calls the generic NamespacesSetOffloadThreshold builder with application/json body
func NewNamespacesSetOffloadThresholdRequest(server string, tenant string, namespace string, body NamespacesSetOffloadThresholdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetOffloadThresholdRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetOffloadThresholdRequestWithBody generates requests for NamespacesSetOffloadThreshold with any type of body
func NewNamespacesSetOffloadThresholdRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadThreshold", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetOffloadThresholdInSecondsRequest generates requests for NamespacesGetOffloadThresholdInSeconds
func NewNamespacesGetOffloadThresholdInSecondsRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadThresholdInSeconds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetOffloadThresholdInSecondsRequest generates requests for NamespacesSetOffloadThresholdInSeconds
func NewNamespacesSetOffloadThresholdInSecondsRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/offloadThresholdInSeconds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetPermissionsRequest generates requests for NamespacesGetPermissions
func NewNamespacesGetPermissionsRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetPermissionOnSubscriptionRequest generates requests for NamespacesGetPermissionOnSubscription
func NewNamespacesGetPermissionOnSubscriptionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/subscription", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesRevokePermissionsOnNamespaceRequest generates requests for NamespacesRevokePermissionsOnNamespace
func NewNamespacesRevokePermissionsOnNamespaceRequest(server string, tenant string, namespace string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGrantPermissionOnNamespaceRequest calls the generic NamespacesGrantPermissionOnNamespace builder with application/json body
func NewNamespacesGrantPermissionOnNamespaceRequest(server string, tenant string, namespace string, role string, body NamespacesGrantPermissionOnNamespaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesGrantPermissionOnNamespaceRequestWithBody(server, tenant, namespace, role, "application/json", bodyReader)
}

// NewNamespacesGrantPermissionOnNamespaceRequestWithBody generates requests for NamespacesGrantPermissionOnNamespace with any type of body
func NewNamespacesGrantPermissionOnNamespaceRequestWithBody(server string, tenant string, namespace string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesDeletePersistenceRequest generates requests for NamespacesDeletePersistence
func NewNamespacesDeletePersistenceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetPersistenceRequest generates requests for NamespacesGetPersistence
func NewNamespacesGetPersistenceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetPersistenceRequest calls the generic NamespacesSetPersistence builder with application/json body
func NewNamespacesSetPersistenceRequest(server string, tenant string, namespace string, body NamespacesSetPersistenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetPersistenceRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetPersistenceRequestWithBody generates requests for NamespacesSetPersistence with any type of body
func NewNamespacesSetPersistenceRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesSetBookieAffinityGroupRequest calls the generic NamespacesSetBookieAffinityGroup builder with application/json body
func NewNamespacesSetBookieAffinityGroupRequest(server string, tenant string, namespace string, body NamespacesSetBookieAffinityGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetBookieAffinityGroupRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetBookieAffinityGroupRequestWithBody generates requests for NamespacesSetBookieAffinityGroup with any type of body
func NewNamespacesSetBookieAffinityGroupRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/persistence/bookieAffinity", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesClearPropertiesRequest generates requests for NamespacesClearProperties
func NewNamespacesClearPropertiesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetPropertiesRequest generates requests for NamespacesGetProperties
func NewNamespacesGetPropertiesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetPropertiesRequest calls the generic NamespacesSetProperties builder with application/json body
func NewNamespacesSetPropertiesRequest(server string, tenant string, namespace string, body NamespacesSetPropertiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetPropertiesRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetPropertiesRequestWithBody generates requests for NamespacesSetProperties with any type of body
func NewNamespacesSetPropertiesRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/properties", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemovePropertyRequest generates requests for NamespacesRemoveProperty
func NewNamespacesRemovePropertyRequest(server string, tenant string, namespace string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetPropertyRequest generates requests for NamespacesGetProperty
func NewNamespacesGetPropertyRequest(server string, tenant string, namespace string, key string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetPropertyRequest generates requests for NamespacesSetProperty
func NewNamespacesSetPropertyRequest(server string, tenant string, namespace string, key string, value string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "key", runtime.ParamLocationPath, key)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "value", runtime.ParamLocationPath, value)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/property/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesRemoveOffloadPoliciesRequest generates requests for NamespacesRemoveOffloadPolicies
func NewNamespacesRemoveOffloadPoliciesRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/removeOffloadPolicies", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetNamespaceReplicationClustersRequest generates requests for NamespacesGetNamespaceReplicationClusters
func NewNamespacesGetNamespaceReplicationClustersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetNamespaceReplicationClustersRequest calls the generic NamespacesSetNamespaceReplicationClusters builder with application/json body
func NewNamespacesSetNamespaceReplicationClustersRequest(server string, tenant string, namespace string, body NamespacesSetNamespaceReplicationClustersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetNamespaceReplicationClustersRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetNamespaceReplicationClustersRequestWithBody generates requests for NamespacesSetNamespaceReplicationClusters with any type of body
func NewNamespacesSetNamespaceReplicationClustersRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replication", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveReplicatorDispatchRateRequest generates requests for NamespacesRemoveReplicatorDispatchRate
func NewNamespacesRemoveReplicatorDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetReplicatorDispatchRateRequest generates requests for NamespacesGetReplicatorDispatchRate
func NewNamespacesGetReplicatorDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetReplicatorDispatchRateRequest calls the generic NamespacesSetReplicatorDispatchRate builder with application/json body
func NewNamespacesSetReplicatorDispatchRateRequest(server string, tenant string, namespace string, body NamespacesSetReplicatorDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetReplicatorDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetReplicatorDispatchRateRequestWithBody generates requests for NamespacesSetReplicatorDispatchRate with any type of body
func NewNamespacesSetReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/replicatorDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveNamespaceResourceGroupRequest generates requests for NamespacesRemoveNamespaceResourceGroup
func NewNamespacesRemoveNamespaceResourceGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetNamespaceResourceGroupRequest generates requests for NamespacesGetNamespaceResourceGroup
func NewNamespacesGetNamespaceResourceGroupRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetNamespaceResourceGroupRequest generates requests for NamespacesSetNamespaceResourceGroup
func NewNamespacesSetNamespaceResourceGroupRequest(server string, tenant string, namespace string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/resourcegroup/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesRemoveRetentionRequest calls the generic NamespacesRemoveRetention builder with application/json body
func NewNamespacesRemoveRetentionRequest(server string, tenant string, namespace string, body NamespacesRemoveRetentionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesRemoveRetentionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesRemoveRetentionRequestWithBody generates requests for NamespacesRemoveRetention with any type of body
func NewNamespacesRemoveRetentionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetRetentionRequest generates requests for NamespacesGetRetention
func NewNamespacesGetRetentionRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetRetentionRequest calls the generic NamespacesSetRetention builder with application/json body
func NewNamespacesSetRetentionRequest(server string, tenant string, namespace string, body NamespacesSetRetentionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetRetentionRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetRetentionRequestWithBody generates requests for NamespacesSetRetention with any type of body
func NewNamespacesSetRetentionRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/retention", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesScanOffloadedLedgersRequest generates requests for NamespacesScanOffloadedLedgers
func NewNamespacesScanOffloadedLedgersRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/scanOffloadedLedgers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetSchemaAutoUpdateCompatibilityStrategyRequest generates requests for NamespacesGetSchemaAutoUpdateCompatibilityStrategy
func NewNamespacesGetSchemaAutoUpdateCompatibilityStrategyRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaAutoUpdateCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetSchemaAutoUpdateCompatibilityStrategyRequest calls the generic NamespacesSetSchemaAutoUpdateCompatibilityStrategy builder with application/json body
func NewNamespacesSetSchemaAutoUpdateCompatibilityStrategyRequest(server string, tenant string, namespace string, body NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody generates requests for NamespacesSetSchemaAutoUpdateCompatibilityStrategy with any type of body
func NewNamespacesSetSchemaAutoUpdateCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaAutoUpdateCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetSchemaCompatibilityStrategyRequest generates requests for NamespacesGetSchemaCompatibilityStrategy
func NewNamespacesGetSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetSchemaCompatibilityStrategyRequest calls the generic NamespacesSetSchemaCompatibilityStrategy builder with application/json body
func NewNamespacesSetSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, body NamespacesSetSchemaCompatibilityStrategyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetSchemaCompatibilityStrategyRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetSchemaCompatibilityStrategyRequestWithBody generates requests for NamespacesSetSchemaCompatibilityStrategy with any type of body
func NewNamespacesSetSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetSchemaValidtionEnforcedRequest generates requests for NamespacesGetSchemaValidtionEnforced
func NewNamespacesGetSchemaValidtionEnforcedRequest(server string, tenant string, namespace string, params *NamespacesGetSchemaValidtionEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaValidationEnforced", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetSchemaValidationEnforcedRequest calls the generic NamespacesSetSchemaValidationEnforced builder with application/json body
func NewNamespacesSetSchemaValidationEnforcedRequest(server string, tenant string, namespace string, body NamespacesSetSchemaValidationEnforcedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetSchemaValidationEnforcedRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetSchemaValidationEnforcedRequestWithBody generates requests for NamespacesSetSchemaValidationEnforced with any type of body
func NewNamespacesSetSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/schemaValidationEnforced", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesDeleteSubscribeRateRequest generates requests for NamespacesDeleteSubscribeRate
func NewNamespacesDeleteSubscribeRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetSubscribeRateRequest generates requests for NamespacesGetSubscribeRate
func NewNamespacesGetSubscribeRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetSubscribeRateRequest calls the generic NamespacesSetSubscribeRate builder with application/json body
func NewNamespacesSetSubscribeRateRequest(server string, tenant string, namespace string, body NamespacesSetSubscribeRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetSubscribeRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetSubscribeRateRequestWithBody generates requests for NamespacesSetSubscribeRate with any type of body
func NewNamespacesSetSubscribeRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscribeRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetSubscriptionAuthModeRequest generates requests for NamespacesGetSubscriptionAuthMode
func NewNamespacesGetSubscriptionAuthModeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionAuthMode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetSubscriptionAuthModeRequest calls the generic NamespacesSetSubscriptionAuthMode builder with application/json body
func NewNamespacesSetSubscriptionAuthModeRequest(server string, tenant string, namespace string, body NamespacesSetSubscriptionAuthModeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetSubscriptionAuthModeRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetSubscriptionAuthModeRequestWithBody generates requests for NamespacesSetSubscriptionAuthMode with any type of body
func NewNamespacesSetSubscriptionAuthModeRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionAuthMode", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesDeleteSubscriptionDispatchRateRequest generates requests for NamespacesDeleteSubscriptionDispatchRate
func NewNamespacesDeleteSubscriptionDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetSubscriptionDispatchRateRequest generates requests for NamespacesGetSubscriptionDispatchRate
func NewNamespacesGetSubscriptionDispatchRateRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetSubscriptionDispatchRateRequest calls the generic NamespacesSetSubscriptionDispatchRate builder with application/json body
func NewNamespacesSetSubscriptionDispatchRateRequest(server string, tenant string, namespace string, body NamespacesSetSubscriptionDispatchRateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetSubscriptionDispatchRateRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetSubscriptionDispatchRateRequestWithBody generates requests for NamespacesSetSubscriptionDispatchRate with any type of body
func NewNamespacesSetSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveSubscriptionExpirationTimeRequest generates requests for NamespacesRemoveSubscriptionExpirationTime
func NewNamespacesRemoveSubscriptionExpirationTimeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetSubscriptionExpirationTimeRequest generates requests for NamespacesGetSubscriptionExpirationTime
func NewNamespacesGetSubscriptionExpirationTimeRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetSubscriptionExpirationTimeRequest calls the generic NamespacesSetSubscriptionExpirationTime builder with application/json body
func NewNamespacesSetSubscriptionExpirationTimeRequest(server string, tenant string, namespace string, body NamespacesSetSubscriptionExpirationTimeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetSubscriptionExpirationTimeRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetSubscriptionExpirationTimeRequestWithBody generates requests for NamespacesSetSubscriptionExpirationTime with any type of body
func NewNamespacesSetSubscriptionExpirationTimeRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionExpirationTime", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesRemoveSubscriptionTypesEnabledRequest generates requests for NamespacesRemoveSubscriptionTypesEnabled
func NewNamespacesRemoveSubscriptionTypesEnabledRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesGetSubscriptionTypesEnabledRequest generates requests for NamespacesGetSubscriptionTypesEnabled
func NewNamespacesGetSubscriptionTypesEnabledRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSetSubscriptionTypesEnabledRequest calls the generic NamespacesSetSubscriptionTypesEnabled builder with application/json body
func NewNamespacesSetSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, body NamespacesSetSubscriptionTypesEnabledJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSetSubscriptionTypesEnabledRequestWithBody(server, tenant, namespace, "application/json", bodyReader)
}

// NewNamespacesSetSubscriptionTypesEnabledRequestWithBody generates requests for NamespacesSetSubscriptionTypesEnabled with any type of body
func NewNamespacesSetSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetTopicsRequest generates requests for NamespacesGetTopics
func NewNamespacesGetTopicsRequest(server string, tenant string, namespace string, params *NamespacesGetTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/topics", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Mode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mode", runtime.ParamLocationQuery, *params.Mode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSystemTopic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesUnloadNamespaceRequest generates requests for NamespacesUnloadNamespace
func NewNamespacesUnloadNamespaceRequest(server string, tenant string, namespace string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/unload", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesUnsubscribeNamespaceRequest generates requests for NamespacesUnsubscribeNamespace
func NewNamespacesUnsubscribeNamespaceRequest(server string, tenant string, namespace string, subscription string, params *NamespacesUnsubscribeNamespaceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/unsubscribe/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesDeleteNamespaceBundleRequest generates requests for NamespacesDeleteNamespaceBundle
func NewNamespacesDeleteNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *NamespacesDeleteNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesClearNamespaceBundleBacklogRequest generates requests for NamespacesClearNamespaceBundleBacklog
func NewNamespacesClearNamespaceBundleBacklogRequest(server string, tenant string, namespace string, bundle string, params *NamespacesClearNamespaceBundleBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/clearBacklog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesClearNamespaceBundleBacklogForSubscriptionRequest generates requests for NamespacesClearNamespaceBundleBacklogForSubscription
func NewNamespacesClearNamespaceBundleBacklogForSubscriptionRequest(server string, tenant string, namespace string, bundle string, subscription string, params *NamespacesClearNamespaceBundleBacklogForSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/clearBacklog/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesSplitNamespaceBundleRequest calls the generic NamespacesSplitNamespaceBundle builder with application/json body
func NewNamespacesSplitNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, body NamespacesSplitNamespaceBundleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNamespacesSplitNamespaceBundleRequestWithBody(server, tenant, namespace, bundle, params, "application/json", bodyReader)
}

// NewNamespacesSplitNamespaceBundleRequestWithBody generates requests for NamespacesSplitNamespaceBundle with any type of body
func NewNamespacesSplitNamespaceBundleRequestWithBody(server string, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/split", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unload", runtime.ParamLocationQuery, *params.Unload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SplitAlgorithmName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "splitAlgorithmName", runtime.ParamLocationQuery, *params.SplitAlgorithmName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNamespacesGetTopicHashPositionsRequest generates requests for NamespacesGetTopicHashPositions
func NewNamespacesGetTopicHashPositionsRequest(server string, tenant string, namespace string, bundle string, params *NamespacesGetTopicHashPositionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/topicHashPositions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Topics != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "topics", runtime.ParamLocationQuery, *params.Topics); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesUnloadNamespaceBundleRequest generates requests for NamespacesUnloadNamespaceBundle
func NewNamespacesUnloadNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, params *NamespacesUnloadNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DestinationBroker != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destinationBroker", runtime.ParamLocationQuery, *params.DestinationBroker); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNamespacesUnsubscribeNamespaceBundleRequest generates requests for NamespacesUnsubscribeNamespaceBundle
func NewNamespacesUnsubscribeNamespaceBundleRequest(server string, tenant string, namespace string, bundle string, subscription string, params *NamespacesUnsubscribeNamespaceBundleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscription", runtime.ParamLocationPath, subscription)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/namespaces/%s/%s/%s/unsubscribe/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetListRequest generates requests for NonPersistentTopicsGetList
func NewNonPersistentTopicsGetListRequest(server string, tenant string, namespace string, params *NonPersistentTopicsGetListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Bundle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundle", runtime.ParamLocationQuery, *params.Bundle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSystemTopic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetPartitionedTopicListRequest generates requests for NonPersistentTopicsGetPartitionedTopicList
func NewNonPersistentTopicsGetPartitionedTopicListRequest(server string, tenant string, namespace string, params *NonPersistentTopicsGetPartitionedTopicListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/partitioned", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeSystemTopic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetListFromBundleRequest generates requests for NonPersistentTopicsGetListFromBundle
func NewNonPersistentTopicsGetListFromBundleRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsDeleteTopicRequest generates requests for NonPersistentTopicsDeleteTopic
func NewNonPersistentTopicsDeleteTopicRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsCreateNonPartitionedTopicRequestWithBody generates requests for NonPersistentTopicsCreateNonPartitionedTopic with any type of body
func NewNonPersistentTopicsCreateNonPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsExpireMessagesForAllSubscriptionsRequest generates requests for NonPersistentTopicsExpireMessagesForAllSubscriptions
func NewNonPersistentTopicsExpireMessagesForAllSubscriptionsRequest(server string, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireMessagesForAllSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/all_subscription/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRemoveAutoSubscriptionCreationRequest generates requests for NonPersistentTopicsRemoveAutoSubscriptionCreation
func NewNonPersistentTopicsRemoveAutoSubscriptionCreationRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveAutoSubscriptionCreationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetAutoSubscriptionCreationRequest generates requests for NonPersistentTopicsGetAutoSubscriptionCreation
func NewNonPersistentTopicsGetAutoSubscriptionCreationRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetAutoSubscriptionCreationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetAutoSubscriptionCreationRequestWithBody generates requests for NonPersistentTopicsSetAutoSubscriptionCreation with any type of body
func NewNonPersistentTopicsSetAutoSubscriptionCreationRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetBacklogRequest generates requests for NonPersistentTopicsGetBacklog
func NewNonPersistentTopicsGetBacklogRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRemoveBacklogQuotaRequest generates requests for NonPersistentTopicsRemoveBacklogQuota
func NewNonPersistentTopicsRemoveBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BacklogQuotaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetBacklogQuotaRequestWithBody generates requests for NonPersistentTopicsSetBacklogQuota with any type of body
func NewNonPersistentTopicsSetBacklogQuotaRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BacklogQuotaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetBacklogQuotaMapRequest generates requests for NonPersistentTopicsGetBacklogQuotaMap
func NewNonPersistentTopicsGetBacklogQuotaMapRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogQuotaMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogQuotaMap", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetBacklogSizeByMessageIdRequest generates requests for NonPersistentTopicsGetBacklogSizeByMessageId
func NewNonPersistentTopicsGetBacklogSizeByMessageIdRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogSizeByMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/backlogSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsCompactionStatusRequest generates requests for NonPersistentTopicsCompactionStatus
func NewNonPersistentTopicsCompactionStatusRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsCompactRequest generates requests for NonPersistentTopicsCompact
func NewNonPersistentTopicsCompactRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRemoveCompactionThresholdRequest generates requests for NonPersistentTopicsRemoveCompactionThreshold
func NewNonPersistentTopicsRemoveCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetCompactionThresholdRequest generates requests for NonPersistentTopicsGetCompactionThreshold
func NewNonPersistentTopicsGetCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetCompactionThresholdRequestWithBody generates requests for NonPersistentTopicsSetCompactionThreshold with any type of body
func NewNonPersistentTopicsSetCompactionThresholdRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsCreateMissedPartitionsRequest generates requests for NonPersistentTopicsCreateMissedPartitions
func NewNonPersistentTopicsCreateMissedPartitionsRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/createMissedPartitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRemoveDeduplicationRequest generates requests for NonPersistentTopicsRemoveDeduplication
func NewNonPersistentTopicsRemoveDeduplicationRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetDeduplicationRequest generates requests for NonPersistentTopicsGetDeduplication
func NewNonPersistentTopicsGetDeduplicationRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetDeduplicationRequestWithBody generates requests for NonPersistentTopicsSetDeduplication with any type of body
func NewNonPersistentTopicsSetDeduplicationRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsDeleteDeduplicationSnapshotIntervalRequest generates requests for NonPersistentTopicsDeleteDeduplicationSnapshotInterval
func NewNonPersistentTopicsDeleteDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetDeduplicationSnapshotIntervalRequest generates requests for NonPersistentTopicsGetDeduplicationSnapshotInterval
func NewNonPersistentTopicsGetDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetDeduplicationSnapshotIntervalRequestWithBody generates requests for NonPersistentTopicsSetDeduplicationSnapshotInterval with any type of body
func NewNonPersistentTopicsSetDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsDeleteDelayedDeliveryPoliciesRequest generates requests for NonPersistentTopicsDeleteDelayedDeliveryPolicies
func NewNonPersistentTopicsDeleteDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetDelayedDeliveryPoliciesRequest generates requests for NonPersistentTopicsGetDelayedDeliveryPolicies
func NewNonPersistentTopicsGetDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetDelayedDeliveryPoliciesRequestWithBody generates requests for NonPersistentTopicsSetDelayedDeliveryPolicies with any type of body
func NewNonPersistentTopicsSetDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveDispatchRateRequest generates requests for NonPersistentTopicsRemoveDispatchRate
func NewNonPersistentTopicsRemoveDispatchRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetDispatchRateRequest generates requests for NonPersistentTopicsGetDispatchRate
func NewNonPersistentTopicsGetDispatchRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetDispatchRateRequestWithBody generates requests for NonPersistentTopicsSetDispatchRate with any type of body
func NewNonPersistentTopicsSetDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveEntryFiltersRequest generates requests for NonPersistentTopicsRemoveEntryFilters
func NewNonPersistentTopicsRemoveEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetEntryFiltersRequest generates requests for NonPersistentTopicsGetEntryFilters
func NewNonPersistentTopicsGetEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetEntryFiltersRequestWithBody generates requests for NonPersistentTopicsSetEntryFilters with any type of body
func NewNonPersistentTopicsSetEntryFiltersRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsExamineMessageRequest generates requests for NonPersistentTopicsExamineMessage
func NewNonPersistentTopicsExamineMessageRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsExamineMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/examinemessage", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InitialPosition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "initialPosition", runtime.ParamLocationQuery, *params.InitialPosition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MessagePosition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messagePosition", runtime.ParamLocationQuery, *params.MessagePosition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsDeleteInactiveTopicPoliciesRequest generates requests for NonPersistentTopicsDeleteInactiveTopicPolicies
func NewNonPersistentTopicsDeleteInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetInactiveTopicPoliciesRequest generates requests for NonPersistentTopicsGetInactiveTopicPolicies
func NewNonPersistentTopicsGetInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetInactiveTopicPoliciesRequestWithBody generates requests for NonPersistentTopicsSetInactiveTopicPolicies with any type of body
func NewNonPersistentTopicsSetInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetManagedLedgerInfoRequest generates requests for NonPersistentTopicsGetManagedLedgerInfo
func NewNonPersistentTopicsGetManagedLedgerInfoRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetManagedLedgerInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/internal-info", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetInternalStatsRequest generates requests for NonPersistentTopicsGetInternalStats
func NewNonPersistentTopicsGetInternalStatsRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInternalStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/internalStats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetLastMessageIdRequest generates requests for NonPersistentTopicsGetLastMessageId
func NewNonPersistentTopicsGetLastMessageIdRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetLastMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/lastMessageId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMessageByIdRequest generates requests for NonPersistentTopicsGetMessageById
func NewNonPersistentTopicsGetMessageByIdRequest(server string, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *NonPersistentTopicsGetMessageByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "ledgerId", runtime.ParamLocationPath, ledgerId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "entryId", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/ledger/%s/entry/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRemoveMaxConsumersRequest generates requests for NonPersistentTopicsRemoveMaxConsumers
func NewNonPersistentTopicsRemoveMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMaxConsumersRequest generates requests for NonPersistentTopicsGetMaxConsumers
func NewNonPersistentTopicsGetMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetMaxConsumersRequestWithBody generates requests for NonPersistentTopicsSetMaxConsumers with any type of body
func NewNonPersistentTopicsSetMaxConsumersRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveMaxConsumersPerSubscriptionRequest generates requests for NonPersistentTopicsRemoveMaxConsumersPerSubscription
func NewNonPersistentTopicsRemoveMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMaxConsumersPerSubscriptionRequest generates requests for NonPersistentTopicsGetMaxConsumersPerSubscription
func NewNonPersistentTopicsGetMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetMaxConsumersPerSubscriptionRequestWithBody generates requests for NonPersistentTopicsSetMaxConsumersPerSubscription with any type of body
func NewNonPersistentTopicsSetMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveMaxMessageSizeRequest generates requests for NonPersistentTopicsRemoveMaxMessageSize
func NewNonPersistentTopicsRemoveMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMaxMessageSizeRequest generates requests for NonPersistentTopicsGetMaxMessageSize
func NewNonPersistentTopicsGetMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetMaxMessageSizeRequestWithBody generates requests for NonPersistentTopicsSetMaxMessageSize with any type of body
func NewNonPersistentTopicsSetMaxMessageSizeRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveMaxProducersRequest generates requests for NonPersistentTopicsRemoveMaxProducers
func NewNonPersistentTopicsRemoveMaxProducersRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMaxProducersRequest generates requests for NonPersistentTopicsGetMaxProducers
func NewNonPersistentTopicsGetMaxProducersRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetMaxProducersRequestWithBody generates requests for NonPersistentTopicsSetMaxProducers with any type of body
func NewNonPersistentTopicsSetMaxProducersRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxProducersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveMaxSubscriptionsPerTopicRequest generates requests for NonPersistentTopicsRemoveMaxSubscriptionsPerTopic
func NewNonPersistentTopicsRemoveMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMaxSubscriptionsPerTopicRequest generates requests for NonPersistentTopicsGetMaxSubscriptionsPerTopic
func NewNonPersistentTopicsGetMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetMaxSubscriptionsPerTopicRequestWithBody generates requests for NonPersistentTopicsSetMaxSubscriptionsPerTopic with any type of body
func NewNonPersistentTopicsSetMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerRequest generates requests for NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumer
func NewNonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMaxUnackedMessagesOnConsumerRequest generates requests for NonPersistentTopicsGetMaxUnackedMessagesOnConsumer
func NewNonPersistentTopicsGetMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetMaxUnackedMessagesOnConsumerRequestWithBody generates requests for NonPersistentTopicsSetMaxUnackedMessagesOnConsumer with any type of body
func NewNonPersistentTopicsSetMaxUnackedMessagesOnConsumerRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionRequest generates requests for NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscription
func NewNonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionRequest generates requests for NonPersistentTopicsGetMaxUnackedMessagesOnSubscription
func NewNonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionRequestWithBody generates requests for NonPersistentTopicsSetMaxUnackedMessagesOnSubscription with any type of body
func NewNonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveMessageTTLRequest generates requests for NonPersistentTopicsRemoveMessageTTL
func NewNonPersistentTopicsRemoveMessageTTLRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMessageTTLRequest generates requests for NonPersistentTopicsGetMessageTTL
func NewNonPersistentTopicsGetMessageTTLRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetMessageTTLRequest generates requests for NonPersistentTopicsSetMessageTTL
func NewNonPersistentTopicsSetMessageTTLRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageTTL", runtime.ParamLocationQuery, params.MessageTTL); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetMessageIdByTimestampRequest generates requests for NonPersistentTopicsGetMessageIdByTimestamp
func NewNonPersistentTopicsGetMessageIdByTimestampRequest(server string, tenant string, namespace string, topic string, timestamp int64, params *NonPersistentTopicsGetMessageIdByTimestampParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/messageid/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsOffloadStatusRequest generates requests for NonPersistentTopicsOffloadStatus
func NewNonPersistentTopicsOffloadStatusRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsOffloadStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsTriggerOffloadRequest generates requests for NonPersistentTopicsTriggerOffload
func NewNonPersistentTopicsTriggerOffloadRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsTriggerOffloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRemoveOffloadPoliciesRequest generates requests for NonPersistentTopicsRemoveOffloadPolicies
func NewNonPersistentTopicsRemoveOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetOffloadPoliciesRequest generates requests for NonPersistentTopicsGetOffloadPolicies
func NewNonPersistentTopicsGetOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetOffloadPoliciesRequestWithBody generates requests for NonPersistentTopicsSetOffloadPolicies with any type of body
func NewNonPersistentTopicsSetOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetPartitionedStatsInternalRequest generates requests for NonPersistentTopicsGetPartitionedStatsInternal
func NewNonPersistentTopicsGetPartitionedStatsInternalRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsInternalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitioned-internalStats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetPartitionedStatsRequest generates requests for NonPersistentTopicsGetPartitionedStats
func NewNonPersistentTopicsGetPartitionedStatsRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitioned-stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPartition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPartition", runtime.ParamLocationQuery, *params.PerPartition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetPreciseBacklog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubscriptionBacklogSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetEarliestTimeInBacklog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsDeletePartitionedTopicRequest generates requests for NonPersistentTopicsDeletePartitionedTopic
func NewNonPersistentTopicsDeletePartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsDeletePartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetPartitionedMetadataRequest generates requests for NonPersistentTopicsGetPartitionedMetadata
func NewNonPersistentTopicsGetPartitionedMetadataRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CheckAllowAutoCreation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkAllowAutoCreation", runtime.ParamLocationQuery, *params.CheckAllowAutoCreation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsUpdatePartitionedTopicRequestWithBody generates requests for NonPersistentTopicsUpdatePartitionedTopic with any type of body
func NewNonPersistentTopicsUpdatePartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateLocalTopicOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateLocalTopicOnly", runtime.ParamLocationQuery, *params.UpdateLocalTopicOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsCreatePartitionedTopicRequestWithBody generates requests for NonPersistentTopicsCreatePartitionedTopic with any type of body
func NewNonPersistentTopicsCreatePartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreateLocalTopicOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createLocalTopicOnly", runtime.ParamLocationQuery, *params.CreateLocalTopicOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetPermissionsOnTopicRequest generates requests for NonPersistentTopicsGetPermissionsOnTopic
func NewNonPersistentTopicsGetPermissionsOnTopicRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRevokePermissionsOnTopicRequest generates requests for NonPersistentTopicsRevokePermissionsOnTopic
func NewNonPersistentTopicsRevokePermissionsOnTopicRequest(server string, tenant string, namespace string, topic string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGrantPermissionsOnTopicRequestWithBody generates requests for NonPersistentTopicsGrantPermissionsOnTopic with any type of body
func NewNonPersistentTopicsGrantPermissionsOnTopicRequestWithBody(server string, tenant string, namespace string, topic string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemovePersistenceRequest generates requests for NonPersistentTopicsRemovePersistence
func NewNonPersistentTopicsRemovePersistenceRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetPersistenceRequest generates requests for NonPersistentTopicsGetPersistence
func NewNonPersistentTopicsGetPersistenceRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetPersistenceRequestWithBody generates requests for NonPersistentTopicsSetPersistence with any type of body
func NewNonPersistentTopicsSetPersistenceRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPersistenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemovePropertiesRequest generates requests for NonPersistentTopicsRemoveProperties
func NewNonPersistentTopicsRemovePropertiesRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetPropertiesRequest generates requests for NonPersistentTopicsGetProperties
func NewNonPersistentTopicsGetPropertiesRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsUpdatePropertiesRequestWithBody generates requests for NonPersistentTopicsUpdateProperties with any type of body
func NewNonPersistentTopicsUpdatePropertiesRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemovePublishRateRequest generates requests for NonPersistentTopicsRemovePublishRate
func NewNonPersistentTopicsRemovePublishRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetPublishRateRequest generates requests for NonPersistentTopicsGetPublishRate
func NewNonPersistentTopicsGetPublishRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetPublishRateRequestWithBody generates requests for NonPersistentTopicsSetPublishRate with any type of body
func NewNonPersistentTopicsSetPublishRateRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPublishRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveReplicationClustersRequest generates requests for NonPersistentTopicsRemoveReplicationClusters
func NewNonPersistentTopicsRemoveReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BacklogQuotaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetReplicationClustersRequest generates requests for NonPersistentTopicsGetReplicationClusters
func NewNonPersistentTopicsGetReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetReplicationClustersRequestWithBody generates requests for NonPersistentTopicsSetReplicationClusters with any type of body
func NewNonPersistentTopicsSetReplicationClustersRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveReplicatorDispatchRateRequest generates requests for NonPersistentTopicsRemoveReplicatorDispatchRate
func NewNonPersistentTopicsRemoveReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetReplicatorDispatchRateRequest generates requests for NonPersistentTopicsGetReplicatorDispatchRate
func NewNonPersistentTopicsGetReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetReplicatorDispatchRateRequestWithBody generates requests for NonPersistentTopicsSetReplicatorDispatchRate with any type of body
func NewNonPersistentTopicsSetReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveRetentionRequest generates requests for NonPersistentTopicsRemoveRetention
func NewNonPersistentTopicsRemoveRetentionRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetRetentionRequest generates requests for NonPersistentTopicsGetRetention
func NewNonPersistentTopicsGetRetentionRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetRetentionRequestWithBody generates requests for NonPersistentTopicsSetRetention with any type of body
func NewNonPersistentTopicsSetRetentionRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetRetentionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveSchemaCompatibilityStrategyRequestWithBody generates requests for NonPersistentTopicsRemoveSchemaCompatibilityStrategy with any type of body
func NewNonPersistentTopicsRemoveSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetSchemaCompatibilityStrategyRequest generates requests for NonPersistentTopicsGetSchemaCompatibilityStrategy
func NewNonPersistentTopicsGetSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaCompatibilityStrategyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetSchemaCompatibilityStrategyRequestWithBody generates requests for NonPersistentTopicsSetSchemaCompatibilityStrategy with any type of body
func NewNonPersistentTopicsSetSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetSchemaValidationEnforcedRequest generates requests for NonPersistentTopicsGetSchemaValidationEnforced
func NewNonPersistentTopicsGetSchemaValidationEnforcedRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaValidationEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetSchemaValidationEnforcedRequestWithBody generates requests for NonPersistentTopicsSetSchemaValidationEnforced with any type of body
func NewNonPersistentTopicsSetSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsDeleteShadowTopicsRequest generates requests for NonPersistentTopicsDeleteShadowTopics
func NewNonPersistentTopicsDeleteShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetShadowTopicsRequest generates requests for NonPersistentTopicsGetShadowTopics
func NewNonPersistentTopicsGetShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetShadowTopicsRequestWithBody generates requests for NonPersistentTopicsSetShadowTopics with any type of body
func NewNonPersistentTopicsSetShadowTopicsRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetStatsRequest generates requests for NonPersistentTopicsGetStats
func NewNonPersistentTopicsGetStatsRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetPreciseBacklog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubscriptionBacklogSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetEarliestTimeInBacklog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRemoveSubscribeRateRequestWithBody generates requests for NonPersistentTopicsRemoveSubscribeRate with any type of body
func NewNonPersistentTopicsRemoveSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetSubscribeRateRequest generates requests for NonPersistentTopicsGetSubscribeRate
func NewNonPersistentTopicsGetSubscribeRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscribeRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetSubscribeRateRequestWithBody generates requests for NonPersistentTopicsSetSubscribeRate with any type of body
func NewNonPersistentTopicsSetSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsDeleteSubscriptionRequest generates requests for NonPersistentTopicsDeleteSubscription
func NewNonPersistentTopicsDeleteSubscriptionRequest(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsDeleteSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsAnalyzeSubscriptionBacklogRequestWithBody generates requests for NonPersistentTopicsAnalyzeSubscriptionBacklog with any type of body
func NewNonPersistentTopicsAnalyzeSubscriptionBacklogRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/analyzeBacklog", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsExpireTopicMessagesRequestWithBody generates requests for NonPersistentTopicsExpireTopicMessages with any type of body
func NewNonPersistentTopicsExpireTopicMessagesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/expireMessages", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsExpireTopicMessagesExpireTimeRequest generates requests for NonPersistentTopicsExpireTopicMessagesExpireTime
func NewNonPersistentTopicsExpireTopicMessagesExpireTimeRequest(server string, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireTopicMessagesExpireTimeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsPeekNthMessageRequest generates requests for NonPersistentTopicsPeekNthMessage
func NewNonPersistentTopicsPeekNthMessageRequest(server string, tenant string, namespace string, topic string, subName string, messagePosition int32, params *NonPersistentTopicsPeekNthMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "messagePosition", runtime.ParamLocationPath, messagePosition)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/position/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetSubscriptionPropertiesRequest generates requests for NonPersistentTopicsGetSubscriptionProperties
func NewNonPersistentTopicsGetSubscriptionPropertiesRequest(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsUpdateSubscriptionPropertiesRequestWithBody generates requests for NonPersistentTopicsUpdateSubscriptionProperties with any type of body
func NewNonPersistentTopicsUpdateSubscriptionPropertiesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetReplicatedSubscriptionStatusRequest generates requests for NonPersistentTopicsGetReplicatedSubscriptionStatus
func NewNonPersistentTopicsGetReplicatedSubscriptionStatusRequest(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetReplicatedSubscriptionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetReplicatedSubscriptionStatusRequestWithBody generates requests for NonPersistentTopicsSetReplicatedSubscriptionStatus with any type of body
func NewNonPersistentTopicsSetReplicatedSubscriptionStatusRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsResetCursorOnPositionRequestWithBody generates requests for NonPersistentTopicsResetCursorOnPosition with any type of body
func NewNonPersistentTopicsResetCursorOnPositionRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/resetcursor", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsResetCursorRequest generates requests for NonPersistentTopicsResetCursor
func NewNonPersistentTopicsResetCursorRequest(server string, tenant string, namespace string, topic string, subName string, timestamp int64, params *NonPersistentTopicsResetCursorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/resetcursor/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSkipMessagesRequest generates requests for NonPersistentTopicsSkipMessages
func NewNonPersistentTopicsSkipMessagesRequest(server string, tenant string, namespace string, topic string, subName string, numMessages int32, params *NonPersistentTopicsSkipMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "numMessages", runtime.ParamLocationPath, numMessages)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/skip/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSkipAllMessagesRequest generates requests for NonPersistentTopicsSkipAllMessages
func NewNonPersistentTopicsSkipAllMessagesRequest(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSkipAllMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s/skip_all", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsCreateSubscriptionRequestWithBody generates requests for NonPersistentTopicsCreateSubscription with any type of body
func NewNonPersistentTopicsCreateSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, subscriptionName string, params *NonPersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscriptionName", runtime.ParamLocationPath, subscriptionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Replicated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replicated", runtime.ParamLocationQuery, *params.Replicated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveSubscriptionDispatchRateRequest generates requests for NonPersistentTopicsRemoveSubscriptionDispatchRate
func NewNonPersistentTopicsRemoveSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetSubscriptionDispatchRateRequest generates requests for NonPersistentTopicsGetSubscriptionDispatchRate
func NewNonPersistentTopicsGetSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetSubscriptionDispatchRateRequestWithBody generates requests for NonPersistentTopicsSetSubscriptionDispatchRate with any type of body
func NewNonPersistentTopicsSetSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsRemoveSubscriptionTypesEnabledRequest generates requests for NonPersistentTopicsRemoveSubscriptionTypesEnabled
func NewNonPersistentTopicsRemoveSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetSubscriptionTypesEnabledRequest generates requests for NonPersistentTopicsGetSubscriptionTypesEnabled
func NewNonPersistentTopicsGetSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetSubscriptionTypesEnabledRequestWithBody generates requests for NonPersistentTopicsSetSubscriptionTypesEnabled with any type of body
func NewNonPersistentTopicsSetSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewNonPersistentTopicsGetSubscriptionsRequest generates requests for NonPersistentTopicsGetSubscriptions
func NewNonPersistentTopicsGetSubscriptionsRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/subscriptions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsTerminateRequest generates requests for NonPersistentTopicsTerminate
func NewNonPersistentTopicsTerminateRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/terminate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsTerminatePartitionedTopicRequest generates requests for NonPersistentTopicsTerminatePartitionedTopic
func NewNonPersistentTopicsTerminatePartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminatePartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/terminate/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsTrimTopicRequest generates requests for NonPersistentTopicsTrimTopic
func NewNonPersistentTopicsTrimTopicRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsTrimTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/trim", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsTruncateTopicRequest generates requests for NonPersistentTopicsTruncateTopic
func NewNonPersistentTopicsTruncateTopicRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsTruncateTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/truncate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsUnloadTopicRequest generates requests for NonPersistentTopicsUnloadTopic
func NewNonPersistentTopicsUnloadTopicRequest(server string, tenant string, namespace string, topic string, params *NonPersistentTopicsUnloadTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsRemoveSubscriptionLevelDispatchRateRequest generates requests for NonPersistentTopicsRemoveSubscriptionLevelDispatchRate
func NewNonPersistentTopicsRemoveSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsRemoveSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsGetSubscriptionLevelDispatchRateRequest generates requests for NonPersistentTopicsGetSubscriptionLevelDispatchRate
func NewNonPersistentTopicsGetSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNonPersistentTopicsSetSubscriptionLevelDispatchRateRequestWithBody generates requests for NonPersistentTopicsSetSubscriptionLevelDispatchRate with any type of body
func NewNonPersistentTopicsSetSubscriptionLevelDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/non-persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetListRequest generates requests for PersistentTopicsGetList
func NewPersistentTopicsGetListRequest(server string, tenant string, namespace string, params *PersistentTopicsGetListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Bundle != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bundle", runtime.ParamLocationQuery, *params.Bundle); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeSystemTopic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetPartitionedTopicListRequest generates requests for PersistentTopicsGetPartitionedTopicList
func NewPersistentTopicsGetPartitionedTopicListRequest(server string, tenant string, namespace string, params *PersistentTopicsGetPartitionedTopicListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/partitioned", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeSystemTopic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeSystemTopic", runtime.ParamLocationQuery, *params.IncludeSystemTopic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsDeleteTopicRequest generates requests for PersistentTopicsDeleteTopic
func NewPersistentTopicsDeleteTopicRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsDeleteTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsCreateNonPartitionedTopicRequestWithBody generates requests for PersistentTopicsCreateNonPartitionedTopic with any type of body
func NewPersistentTopicsCreateNonPartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsExpireMessagesForAllSubscriptionsRequest generates requests for PersistentTopicsExpireMessagesForAllSubscriptions
func NewPersistentTopicsExpireMessagesForAllSubscriptionsRequest(server string, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *PersistentTopicsExpireMessagesForAllSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/all_subscription/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRemoveAutoSubscriptionCreationRequest generates requests for PersistentTopicsRemoveAutoSubscriptionCreation
func NewPersistentTopicsRemoveAutoSubscriptionCreationRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveAutoSubscriptionCreationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetAutoSubscriptionCreationRequest generates requests for PersistentTopicsGetAutoSubscriptionCreation
func NewPersistentTopicsGetAutoSubscriptionCreationRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetAutoSubscriptionCreationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetAutoSubscriptionCreationRequestWithBody generates requests for PersistentTopicsSetAutoSubscriptionCreation with any type of body
func NewPersistentTopicsSetAutoSubscriptionCreationRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/autoSubscriptionCreation", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetBacklogRequest generates requests for PersistentTopicsGetBacklog
func NewPersistentTopicsGetBacklogRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlog", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRemoveBacklogQuotaRequest generates requests for PersistentTopicsRemoveBacklogQuota
func NewPersistentTopicsRemoveBacklogQuotaRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveBacklogQuotaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BacklogQuotaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetBacklogQuotaRequestWithBody generates requests for PersistentTopicsSetBacklogQuota with any type of body
func NewPersistentTopicsSetBacklogQuotaRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuota", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BacklogQuotaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetBacklogQuotaMapRequest generates requests for PersistentTopicsGetBacklogQuotaMap
func NewPersistentTopicsGetBacklogQuotaMapRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogQuotaMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogQuotaMap", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetBacklogSizeByMessageIdRequest generates requests for PersistentTopicsGetBacklogSizeByMessageId
func NewPersistentTopicsGetBacklogSizeByMessageIdRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogSizeByMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/backlogSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsCompactionStatusRequest generates requests for PersistentTopicsCompactionStatus
func NewPersistentTopicsCompactionStatusRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsCompactionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsCompactRequest generates requests for PersistentTopicsCompact
func NewPersistentTopicsCompactRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsCompactParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compaction", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRemoveCompactionThresholdRequest generates requests for PersistentTopicsRemoveCompactionThreshold
func NewPersistentTopicsRemoveCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetCompactionThresholdRequest generates requests for PersistentTopicsGetCompactionThreshold
func NewPersistentTopicsGetCompactionThresholdRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetCompactionThresholdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetCompactionThresholdRequestWithBody generates requests for PersistentTopicsSetCompactionThreshold with any type of body
func NewPersistentTopicsSetCompactionThresholdRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/compactionThreshold", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsCreateMissedPartitionsRequest generates requests for PersistentTopicsCreateMissedPartitions
func NewPersistentTopicsCreateMissedPartitionsRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/createMissedPartitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRemoveDeduplicationRequest generates requests for PersistentTopicsRemoveDeduplication
func NewPersistentTopicsRemoveDeduplicationRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetDeduplicationRequest generates requests for PersistentTopicsGetDeduplication
func NewPersistentTopicsGetDeduplicationRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetDeduplicationRequestWithBody generates requests for PersistentTopicsSetDeduplication with any type of body
func NewPersistentTopicsSetDeduplicationRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsDeleteDeduplicationSnapshotIntervalRequest generates requests for PersistentTopicsDeleteDeduplicationSnapshotInterval
func NewPersistentTopicsDeleteDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetDeduplicationSnapshotIntervalRequest generates requests for PersistentTopicsGetDeduplicationSnapshotInterval
func NewPersistentTopicsGetDeduplicationSnapshotIntervalRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationSnapshotIntervalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetDeduplicationSnapshotIntervalRequestWithBody generates requests for PersistentTopicsSetDeduplicationSnapshotInterval with any type of body
func NewPersistentTopicsSetDeduplicationSnapshotIntervalRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/deduplicationSnapshotInterval", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsDeleteDelayedDeliveryPoliciesRequest generates requests for PersistentTopicsDeleteDelayedDeliveryPolicies
func NewPersistentTopicsDeleteDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetDelayedDeliveryPoliciesRequest generates requests for PersistentTopicsGetDelayedDeliveryPolicies
func NewPersistentTopicsGetDelayedDeliveryPoliciesRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetDelayedDeliveryPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetDelayedDeliveryPoliciesRequestWithBody generates requests for PersistentTopicsSetDelayedDeliveryPolicies with any type of body
func NewPersistentTopicsSetDelayedDeliveryPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/delayedDelivery", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveDispatchRateRequest generates requests for PersistentTopicsRemoveDispatchRate
func NewPersistentTopicsRemoveDispatchRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetDispatchRateRequest generates requests for PersistentTopicsGetDispatchRate
func NewPersistentTopicsGetDispatchRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetDispatchRateRequestWithBody generates requests for PersistentTopicsSetDispatchRate with any type of body
func NewPersistentTopicsSetDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveEntryFiltersRequest generates requests for PersistentTopicsRemoveEntryFilters
func NewPersistentTopicsRemoveEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetEntryFiltersRequest generates requests for PersistentTopicsGetEntryFilters
func NewPersistentTopicsGetEntryFiltersRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetEntryFiltersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetEntryFiltersRequestWithBody generates requests for PersistentTopicsSetEntryFilters with any type of body
func NewPersistentTopicsSetEntryFiltersRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/entryFilters", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsExamineMessageRequest generates requests for PersistentTopicsExamineMessage
func NewPersistentTopicsExamineMessageRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsExamineMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/examinemessage", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.InitialPosition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "initialPosition", runtime.ParamLocationQuery, *params.InitialPosition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MessagePosition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messagePosition", runtime.ParamLocationQuery, *params.MessagePosition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsDeleteInactiveTopicPoliciesRequest generates requests for PersistentTopicsDeleteInactiveTopicPolicies
func NewPersistentTopicsDeleteInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsDeleteInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetInactiveTopicPoliciesRequest generates requests for PersistentTopicsGetInactiveTopicPolicies
func NewPersistentTopicsGetInactiveTopicPoliciesRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetInactiveTopicPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetInactiveTopicPoliciesRequestWithBody generates requests for PersistentTopicsSetInactiveTopicPolicies with any type of body
func NewPersistentTopicsSetInactiveTopicPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/inactiveTopicPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetManagedLedgerInfoRequest generates requests for PersistentTopicsGetManagedLedgerInfo
func NewPersistentTopicsGetManagedLedgerInfoRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetManagedLedgerInfoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/internal-info", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetInternalStatsRequest generates requests for PersistentTopicsGetInternalStats
func NewPersistentTopicsGetInternalStatsRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetInternalStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/internalStats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetLastMessageIdRequest generates requests for PersistentTopicsGetLastMessageId
func NewPersistentTopicsGetLastMessageIdRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetLastMessageIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/lastMessageId", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMessageByIdRequest generates requests for PersistentTopicsGetMessageById
func NewPersistentTopicsGetMessageByIdRequest(server string, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *PersistentTopicsGetMessageByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "ledgerId", runtime.ParamLocationPath, ledgerId)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "entryId", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/ledger/%s/entry/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRemoveMaxConsumersRequest generates requests for PersistentTopicsRemoveMaxConsumers
func NewPersistentTopicsRemoveMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMaxConsumersRequest generates requests for PersistentTopicsGetMaxConsumers
func NewPersistentTopicsGetMaxConsumersRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetMaxConsumersRequestWithBody generates requests for PersistentTopicsSetMaxConsumers with any type of body
func NewPersistentTopicsSetMaxConsumersRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveMaxConsumersPerSubscriptionRequest generates requests for PersistentTopicsRemoveMaxConsumersPerSubscription
func NewPersistentTopicsRemoveMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMaxConsumersPerSubscriptionRequest generates requests for PersistentTopicsGetMaxConsumersPerSubscription
func NewPersistentTopicsGetMaxConsumersPerSubscriptionRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersPerSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetMaxConsumersPerSubscriptionRequestWithBody generates requests for PersistentTopicsSetMaxConsumersPerSubscription with any type of body
func NewPersistentTopicsSetMaxConsumersPerSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxConsumersPerSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveMaxMessageSizeRequest generates requests for PersistentTopicsRemoveMaxMessageSize
func NewPersistentTopicsRemoveMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMaxMessageSizeRequest generates requests for PersistentTopicsGetMaxMessageSize
func NewPersistentTopicsGetMaxMessageSizeRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxMessageSizeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetMaxMessageSizeRequestWithBody generates requests for PersistentTopicsSetMaxMessageSize with any type of body
func NewPersistentTopicsSetMaxMessageSizeRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxMessageSize", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveMaxProducersRequest generates requests for PersistentTopicsRemoveMaxProducers
func NewPersistentTopicsRemoveMaxProducersRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMaxProducersRequest generates requests for PersistentTopicsGetMaxProducers
func NewPersistentTopicsGetMaxProducersRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxProducersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetMaxProducersRequestWithBody generates requests for PersistentTopicsSetMaxProducers with any type of body
func NewPersistentTopicsSetMaxProducersRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxProducersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxProducers", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveMaxSubscriptionsPerTopicRequest generates requests for PersistentTopicsRemoveMaxSubscriptionsPerTopic
func NewPersistentTopicsRemoveMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMaxSubscriptionsPerTopicRequest generates requests for PersistentTopicsGetMaxSubscriptionsPerTopic
func NewPersistentTopicsGetMaxSubscriptionsPerTopicRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxSubscriptionsPerTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetMaxSubscriptionsPerTopicRequestWithBody generates requests for PersistentTopicsSetMaxSubscriptionsPerTopic with any type of body
func NewPersistentTopicsSetMaxSubscriptionsPerTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxSubscriptionsPerTopic", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsDeleteMaxUnackedMessagesOnConsumerRequest generates requests for PersistentTopicsDeleteMaxUnackedMessagesOnConsumer
func NewPersistentTopicsDeleteMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMaxUnackedMessagesOnConsumerRequest generates requests for PersistentTopicsGetMaxUnackedMessagesOnConsumer
func NewPersistentTopicsGetMaxUnackedMessagesOnConsumerRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnConsumerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetMaxUnackedMessagesOnConsumerRequestWithBody generates requests for PersistentTopicsSetMaxUnackedMessagesOnConsumer with any type of body
func NewPersistentTopicsSetMaxUnackedMessagesOnConsumerRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnConsumer", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionRequest generates requests for PersistentTopicsDeleteMaxUnackedMessagesOnSubscription
func NewPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMaxUnackedMessagesOnSubscriptionRequest generates requests for PersistentTopicsGetMaxUnackedMessagesOnSubscription
func NewPersistentTopicsGetMaxUnackedMessagesOnSubscriptionRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetMaxUnackedMessagesOnSubscriptionRequestWithBody generates requests for PersistentTopicsSetMaxUnackedMessagesOnSubscription with any type of body
func NewPersistentTopicsSetMaxUnackedMessagesOnSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/maxUnackedMessagesOnSubscription", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveMessageTTLRequest generates requests for PersistentTopicsRemoveMessageTTL
func NewPersistentTopicsRemoveMessageTTLRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMessageTTLRequest generates requests for PersistentTopicsGetMessageTTL
func NewPersistentTopicsGetMessageTTLRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetMessageTTLRequest generates requests for PersistentTopicsSetMessageTTL
func NewPersistentTopicsSetMessageTTLRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetMessageTTLParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageTTL", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "messageTTL", runtime.ParamLocationQuery, params.MessageTTL); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetMessageIdByTimestampRequest generates requests for PersistentTopicsGetMessageIdByTimestamp
func NewPersistentTopicsGetMessageIdByTimestampRequest(server string, tenant string, namespace string, topic string, timestamp int64, params *PersistentTopicsGetMessageIdByTimestampParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/messageid/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsOffloadStatusRequest generates requests for PersistentTopicsOffloadStatus
func NewPersistentTopicsOffloadStatusRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsOffloadStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsTriggerOffloadRequest generates requests for PersistentTopicsTriggerOffload
func NewPersistentTopicsTriggerOffloadRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsTriggerOffloadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRemoveOffloadPoliciesRequest generates requests for PersistentTopicsRemoveOffloadPolicies
func NewPersistentTopicsRemoveOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetOffloadPoliciesRequest generates requests for PersistentTopicsGetOffloadPolicies
func NewPersistentTopicsGetOffloadPoliciesRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetOffloadPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetOffloadPoliciesRequestWithBody generates requests for PersistentTopicsSetOffloadPolicies with any type of body
func NewPersistentTopicsSetOffloadPoliciesRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/offloadPolicies", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetPartitionedStatsInternalRequest generates requests for PersistentTopicsGetPartitionedStatsInternal
func NewPersistentTopicsGetPartitionedStatsInternalRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsInternalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitioned-internalStats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetPartitionedStatsRequest generates requests for PersistentTopicsGetPartitionedStats
func NewPersistentTopicsGetPartitionedStatsRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitioned-stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PerPartition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPartition", runtime.ParamLocationQuery, *params.PerPartition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetPreciseBacklog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubscriptionBacklogSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetEarliestTimeInBacklog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsDeletePartitionedTopicRequest generates requests for PersistentTopicsDeletePartitionedTopic
func NewPersistentTopicsDeletePartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsDeletePartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetPartitionedMetadataRequest generates requests for PersistentTopicsGetPartitionedMetadata
func NewPersistentTopicsGetPartitionedMetadataRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CheckAllowAutoCreation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkAllowAutoCreation", runtime.ParamLocationQuery, *params.CheckAllowAutoCreation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsUpdatePartitionedTopicRequestWithBody generates requests for PersistentTopicsUpdatePartitionedTopic with any type of body
func NewPersistentTopicsUpdatePartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateLocalTopicOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateLocalTopicOnly", runtime.ParamLocationQuery, *params.UpdateLocalTopicOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsCreatePartitionedTopicRequestWithBody generates requests for PersistentTopicsCreatePartitionedTopic with any type of body
func NewPersistentTopicsCreatePartitionedTopicRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CreateLocalTopicOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createLocalTopicOnly", runtime.ParamLocationQuery, *params.CreateLocalTopicOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetPermissionsOnTopicRequest generates requests for PersistentTopicsGetPermissionsOnTopic
func NewPersistentTopicsGetPermissionsOnTopicRequest(server string, tenant string, namespace string, topic string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRevokePermissionsOnTopicRequest generates requests for PersistentTopicsRevokePermissionsOnTopic
func NewPersistentTopicsRevokePermissionsOnTopicRequest(server string, tenant string, namespace string, topic string, role string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGrantPermissionsOnTopicRequestWithBody generates requests for PersistentTopicsGrantPermissionsOnTopic with any type of body
func NewPersistentTopicsGrantPermissionsOnTopicRequestWithBody(server string, tenant string, namespace string, topic string, role string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "role", runtime.ParamLocationPath, role)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/permissions/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemovePersistenceRequest generates requests for PersistentTopicsRemovePersistence
func NewPersistentTopicsRemovePersistenceRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemovePersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetPersistenceRequest generates requests for PersistentTopicsGetPersistence
func NewPersistentTopicsGetPersistenceRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetPersistenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetPersistenceRequestWithBody generates requests for PersistentTopicsSetPersistence with any type of body
func NewPersistentTopicsSetPersistenceRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetPersistenceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/persistence", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemovePropertiesRequest generates requests for PersistentTopicsRemoveProperties
func NewPersistentTopicsRemovePropertiesRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemovePropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetPropertiesRequest generates requests for PersistentTopicsGetProperties
func NewPersistentTopicsGetPropertiesRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsUpdatePropertiesRequestWithBody generates requests for PersistentTopicsUpdateProperties with any type of body
func NewPersistentTopicsUpdatePropertiesRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/properties", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemovePublishRateRequest generates requests for PersistentTopicsRemovePublishRate
func NewPersistentTopicsRemovePublishRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemovePublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetPublishRateRequest generates requests for PersistentTopicsGetPublishRate
func NewPersistentTopicsGetPublishRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetPublishRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetPublishRateRequestWithBody generates requests for PersistentTopicsSetPublishRate with any type of body
func NewPersistentTopicsSetPublishRateRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetPublishRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/publishRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveReplicationClustersRequest generates requests for PersistentTopicsRemoveReplicationClusters
func NewPersistentTopicsRemoveReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BacklogQuotaType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "backlogQuotaType", runtime.ParamLocationQuery, *params.BacklogQuotaType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetReplicationClustersRequest generates requests for PersistentTopicsGetReplicationClusters
func NewPersistentTopicsGetReplicationClustersRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicationClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetReplicationClustersRequestWithBody generates requests for PersistentTopicsSetReplicationClusters with any type of body
func NewPersistentTopicsSetReplicationClustersRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replication", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveReplicatorDispatchRateRequest generates requests for PersistentTopicsRemoveReplicatorDispatchRate
func NewPersistentTopicsRemoveReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetReplicatorDispatchRateRequest generates requests for PersistentTopicsGetReplicatorDispatchRate
func NewPersistentTopicsGetReplicatorDispatchRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicatorDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetReplicatorDispatchRateRequestWithBody generates requests for PersistentTopicsSetReplicatorDispatchRate with any type of body
func NewPersistentTopicsSetReplicatorDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/replicatorDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveRetentionRequest generates requests for PersistentTopicsRemoveRetention
func NewPersistentTopicsRemoveRetentionRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetRetentionRequest generates requests for PersistentTopicsGetRetention
func NewPersistentTopicsGetRetentionRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetRetentionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetRetentionRequestWithBody generates requests for PersistentTopicsSetRetention with any type of body
func NewPersistentTopicsSetRetentionRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetRetentionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/retention", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveSchemaCompatibilityStrategyRequestWithBody generates requests for PersistentTopicsRemoveSchemaCompatibilityStrategy with any type of body
func NewPersistentTopicsRemoveSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetSchemaCompatibilityStrategyRequest generates requests for PersistentTopicsGetSchemaCompatibilityStrategy
func NewPersistentTopicsGetSchemaCompatibilityStrategyRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaCompatibilityStrategyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetSchemaCompatibilityStrategyRequestWithBody generates requests for PersistentTopicsSetSchemaCompatibilityStrategy with any type of body
func NewPersistentTopicsSetSchemaCompatibilityStrategyRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaCompatibilityStrategy", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetSchemaValidationEnforcedRequest generates requests for PersistentTopicsGetSchemaValidationEnforced
func NewPersistentTopicsGetSchemaValidationEnforcedRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaValidationEnforcedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetSchemaValidationEnforcedRequestWithBody generates requests for PersistentTopicsSetSchemaValidationEnforced with any type of body
func NewPersistentTopicsSetSchemaValidationEnforcedRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/schemaValidationEnforced", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsDeleteShadowTopicsRequest generates requests for PersistentTopicsDeleteShadowTopics
func NewPersistentTopicsDeleteShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsDeleteShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetShadowTopicsRequest generates requests for PersistentTopicsGetShadowTopics
func NewPersistentTopicsGetShadowTopicsRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetShadowTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetShadowTopicsRequestWithBody generates requests for PersistentTopicsSetShadowTopics with any type of body
func NewPersistentTopicsSetShadowTopicsRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/shadowTopics", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetStatsRequest generates requests for PersistentTopicsGetStats
func NewPersistentTopicsGetStatsRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetStatsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/stats", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetPreciseBacklog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getPreciseBacklog", runtime.ParamLocationQuery, *params.GetPreciseBacklog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubscriptionBacklogSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscriptionBacklogSize", runtime.ParamLocationQuery, *params.SubscriptionBacklogSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GetEarliestTimeInBacklog != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "getEarliestTimeInBacklog", runtime.ParamLocationQuery, *params.GetEarliestTimeInBacklog); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRemoveSubscribeRateRequestWithBody generates requests for PersistentTopicsRemoveSubscribeRate with any type of body
func NewPersistentTopicsRemoveSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetSubscribeRateRequest generates requests for PersistentTopicsGetSubscribeRate
func NewPersistentTopicsGetSubscribeRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscribeRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetSubscribeRateRequestWithBody generates requests for PersistentTopicsSetSubscribeRate with any type of body
func NewPersistentTopicsSetSubscribeRateRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscribeRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsDeleteSubscriptionRequest generates requests for PersistentTopicsDeleteSubscription
func NewPersistentTopicsDeleteSubscriptionRequest(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsDeleteSubscriptionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsAnalyzeSubscriptionBacklogRequestWithBody generates requests for PersistentTopicsAnalyzeSubscriptionBacklog with any type of body
func NewPersistentTopicsAnalyzeSubscriptionBacklogRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/analyzeBacklog", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsExpireTopicMessagesRequestWithBody generates requests for PersistentTopicsExpireTopicMessages with any type of body
func NewPersistentTopicsExpireTopicMessagesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/expireMessages", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsExpireTopicMessagesExpireTimeRequest generates requests for PersistentTopicsExpireTopicMessagesExpireTime
func NewPersistentTopicsExpireTopicMessagesExpireTimeRequest(server string, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *PersistentTopicsExpireTopicMessagesExpireTimeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "expireTimeInSeconds", runtime.ParamLocationPath, expireTimeInSeconds)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/expireMessages/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsPeekNthMessageRequest generates requests for PersistentTopicsPeekNthMessage
func NewPersistentTopicsPeekNthMessageRequest(server string, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PersistentTopicsPeekNthMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "messagePosition", runtime.ParamLocationPath, messagePosition)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/position/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetSubscriptionPropertiesRequest generates requests for PersistentTopicsGetSubscriptionProperties
func NewPersistentTopicsGetSubscriptionPropertiesRequest(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionPropertiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsUpdateSubscriptionPropertiesRequestWithBody generates requests for PersistentTopicsUpdateSubscriptionProperties with any type of body
func NewPersistentTopicsUpdateSubscriptionPropertiesRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/properties", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetReplicatedSubscriptionStatusRequest generates requests for PersistentTopicsGetReplicatedSubscriptionStatus
func NewPersistentTopicsGetReplicatedSubscriptionStatusRequest(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetReplicatedSubscriptionStatusParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetReplicatedSubscriptionStatusRequestWithBody generates requests for PersistentTopicsSetReplicatedSubscriptionStatus with any type of body
func NewPersistentTopicsSetReplicatedSubscriptionStatusRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/replicatedSubscriptionStatus", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsResetCursorOnPositionRequestWithBody generates requests for PersistentTopicsResetCursorOnPosition with any type of body
func NewPersistentTopicsResetCursorOnPositionRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/resetcursor", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsResetCursorRequest generates requests for PersistentTopicsResetCursor
func NewPersistentTopicsResetCursorRequest(server string, tenant string, namespace string, topic string, subName string, timestamp int64, params *PersistentTopicsResetCursorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "timestamp", runtime.ParamLocationPath, timestamp)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/resetcursor/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSkipMessagesRequest generates requests for PersistentTopicsSkipMessages
func NewPersistentTopicsSkipMessagesRequest(server string, tenant string, namespace string, topic string, subName string, numMessages int32, params *PersistentTopicsSkipMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	var pathParam4 string

	pathParam4, err = runtime.StyleParamWithLocation("simple", false, "numMessages", runtime.ParamLocationPath, numMessages)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/skip/%s", pathParam0, pathParam1, pathParam2, pathParam3, pathParam4)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSkipAllMessagesRequest generates requests for PersistentTopicsSkipAllMessages
func NewPersistentTopicsSkipAllMessagesRequest(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSkipAllMessagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s/skip_all", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsCreateSubscriptionRequestWithBody generates requests for PersistentTopicsCreateSubscription with any type of body
func NewPersistentTopicsCreateSubscriptionRequestWithBody(server string, tenant string, namespace string, topic string, subscriptionName string, params *PersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subscriptionName", runtime.ParamLocationPath, subscriptionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscription/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Replicated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "replicated", runtime.ParamLocationQuery, *params.Replicated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveSubscriptionDispatchRateRequest generates requests for PersistentTopicsRemoveSubscriptionDispatchRate
func NewPersistentTopicsRemoveSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetSubscriptionDispatchRateRequest generates requests for PersistentTopicsGetSubscriptionDispatchRate
func NewPersistentTopicsGetSubscriptionDispatchRateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetSubscriptionDispatchRateRequestWithBody generates requests for PersistentTopicsSetSubscriptionDispatchRate with any type of body
func NewPersistentTopicsSetSubscriptionDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionDispatchRate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsRemoveSubscriptionTypesEnabledRequest generates requests for PersistentTopicsRemoveSubscriptionTypesEnabled
func NewPersistentTopicsRemoveSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetSubscriptionTypesEnabledRequest generates requests for PersistentTopicsGetSubscriptionTypesEnabled
func NewPersistentTopicsGetSubscriptionTypesEnabledRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionTypesEnabledParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetSubscriptionTypesEnabledRequestWithBody generates requests for PersistentTopicsSetSubscriptionTypesEnabled with any type of body
func NewPersistentTopicsSetSubscriptionTypesEnabledRequestWithBody(server string, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptionTypesEnabled", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPersistentTopicsGetSubscriptionsRequest generates requests for PersistentTopicsGetSubscriptions
func NewPersistentTopicsGetSubscriptionsRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/subscriptions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsTerminateRequest generates requests for PersistentTopicsTerminate
func NewPersistentTopicsTerminateRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsTerminateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/terminate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsTerminatePartitionedTopicRequest generates requests for PersistentTopicsTerminatePartitionedTopic
func NewPersistentTopicsTerminatePartitionedTopicRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsTerminatePartitionedTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/terminate/partitions", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsTrimTopicRequest generates requests for PersistentTopicsTrimTopic
func NewPersistentTopicsTrimTopicRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsTrimTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/trim", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsTruncateTopicRequest generates requests for PersistentTopicsTruncateTopic
func NewPersistentTopicsTruncateTopicRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsTruncateTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/truncate", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsUnloadTopicRequest generates requests for PersistentTopicsUnloadTopic
func NewPersistentTopicsUnloadTopicRequest(server string, tenant string, namespace string, topic string, params *PersistentTopicsUnloadTopicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/unload", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsRemoveSubscriptionLevelDispatchRateRequest generates requests for PersistentTopicsRemoveSubscriptionLevelDispatchRate
func NewPersistentTopicsRemoveSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsRemoveSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsGetSubscriptionLevelDispatchRateRequest generates requests for PersistentTopicsGetSubscriptionLevelDispatchRate
func NewPersistentTopicsGetSubscriptionLevelDispatchRateRequest(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionLevelDispatchRateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Applied != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "applied", runtime.ParamLocationQuery, *params.Applied); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPersistentTopicsSetSubscriptionLevelDispatchRateRequestWithBody generates requests for PersistentTopicsSetSubscriptionLevelDispatchRate with any type of body
func NewPersistentTopicsSetSubscriptionLevelDispatchRateRequestWithBody(server string, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "subName", runtime.ParamLocationPath, subName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/persistent/%s/%s/%s/%s/dispatchRate", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsGlobal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isGlobal", runtime.ParamLocationQuery, *params.IsGlobal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResourceQuotasGetDefaultResourceQuotaRequest generates requests for ResourceQuotasGetDefaultResourceQuota
func NewResourceQuotasGetDefaultResourceQuotaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResourceQuotasSetDefaultResourceQuotaRequest calls the generic ResourceQuotasSetDefaultResourceQuota builder with application/json body
func NewResourceQuotasSetDefaultResourceQuotaRequest(server string, body ResourceQuotasSetDefaultResourceQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResourceQuotasSetDefaultResourceQuotaRequestWithBody(server, "application/json", bodyReader)
}

// NewResourceQuotasSetDefaultResourceQuotaRequestWithBody generates requests for ResourceQuotasSetDefaultResourceQuota with any type of body
func NewResourceQuotasSetDefaultResourceQuotaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResourceQuotasRemoveNamespaceBundleResourceQuotaRequest generates requests for ResourceQuotasRemoveNamespaceBundleResourceQuota
func NewResourceQuotasRemoveNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResourceQuotasGetNamespaceBundleResourceQuotaRequest generates requests for ResourceQuotasGetNamespaceBundleResourceQuota
func NewResourceQuotasGetNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResourceQuotasSetNamespaceBundleResourceQuotaRequest calls the generic ResourceQuotasSetNamespaceBundleResourceQuota builder with application/json body
func NewResourceQuotasSetNamespaceBundleResourceQuotaRequest(server string, tenant string, namespace string, bundle string, body ResourceQuotasSetNamespaceBundleResourceQuotaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResourceQuotasSetNamespaceBundleResourceQuotaRequestWithBody(server, tenant, namespace, bundle, "application/json", bodyReader)
}

// NewResourceQuotasSetNamespaceBundleResourceQuotaRequestWithBody generates requests for ResourceQuotasSetNamespaceBundleResourceQuota with any type of body
func NewResourceQuotasSetNamespaceBundleResourceQuotaRequestWithBody(server string, tenant string, namespace string, bundle string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bundle", runtime.ParamLocationPath, bundle)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resource-quotas/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResourceGroupsGetResourceGroupsRequest generates requests for ResourceGroupsGetResourceGroups
func NewResourceGroupsGetResourceGroupsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResourceGroupsDeleteResourceGroupRequest generates requests for ResourceGroupsDeleteResourceGroup
func NewResourceGroupsDeleteResourceGroupRequest(server string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResourceGroupsGetResourceGroupRequest generates requests for ResourceGroupsGetResourceGroup
func NewResourceGroupsGetResourceGroupRequest(server string, resourcegroup string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResourceGroupsCreateOrUpdateResourceGroupRequest calls the generic ResourceGroupsCreateOrUpdateResourceGroup builder with application/json body
func NewResourceGroupsCreateOrUpdateResourceGroupRequest(server string, resourcegroup string, body ResourceGroupsCreateOrUpdateResourceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResourceGroupsCreateOrUpdateResourceGroupRequestWithBody(server, resourcegroup, "application/json", bodyReader)
}

// NewResourceGroupsCreateOrUpdateResourceGroupRequestWithBody generates requests for ResourceGroupsCreateOrUpdateResourceGroup with any type of body
func NewResourceGroupsCreateOrUpdateResourceGroupRequestWithBody(server string, resourcegroup string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourcegroup", runtime.ParamLocationPath, resourcegroup)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resourcegroups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSchemasResourceTestCompatibilityRequest calls the generic SchemasResourceTestCompatibility builder with application/json body
func NewSchemasResourceTestCompatibilityRequest(server string, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, body SchemasResourceTestCompatibilityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSchemasResourceTestCompatibilityRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewSchemasResourceTestCompatibilityRequestWithBody generates requests for SchemasResourceTestCompatibility with any type of body
func NewSchemasResourceTestCompatibilityRequestWithBody(server string, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/compatibility", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSchemasResourceDeleteSchemaRequest generates requests for SchemasResourceDeleteSchema
func NewSchemasResourceDeleteSchemaRequest(server string, tenant string, namespace string, topic string, params *SchemasResourceDeleteSchemaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemasResourceGetSchemaRequest generates requests for SchemasResourceGetSchema
func NewSchemasResourceGetSchemaRequest(server string, tenant string, namespace string, topic string, params *SchemasResourceGetSchemaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemasResourcePostSchemaRequest calls the generic SchemasResourcePostSchema builder with application/json body
func NewSchemasResourcePostSchemaRequest(server string, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, body SchemasResourcePostSchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSchemasResourcePostSchemaRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewSchemasResourcePostSchemaRequestWithBody generates requests for SchemasResourcePostSchema with any type of body
func NewSchemasResourcePostSchemaRequestWithBody(server string, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSchemasResourceGetSchemaByVersionRequest generates requests for SchemasResourceGetSchemaByVersion
func NewSchemasResourceGetSchemaByVersionRequest(server string, tenant string, namespace string, topic string, version string, params *SchemasResourceGetSchemaByVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schema/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemasResourceGetAllSchemasRequest generates requests for SchemasResourceGetAllSchemas
func NewSchemasResourceGetAllSchemasRequest(server string, tenant string, namespace string, topic string, params *SchemasResourceGetAllSchemasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/schemas", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSchemasResourceGetVersionBySchemaRequest calls the generic SchemasResourceGetVersionBySchema builder with application/json body
func NewSchemasResourceGetVersionBySchemaRequest(server string, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, body SchemasResourceGetVersionBySchemaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSchemasResourceGetVersionBySchemaRequestWithBody(server, tenant, namespace, topic, params, "application/json", bodyReader)
}

// NewSchemasResourceGetVersionBySchemaRequestWithBody generates requests for SchemasResourceGetVersionBySchema with any type of body
func NewSchemasResourceGetVersionBySchemaRequestWithBody(server string, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespace", runtime.ParamLocationPath, namespace)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "topic", runtime.ParamLocationPath, topic)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schemas/%s/%s/%s/version", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Authoritative != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authoritative", runtime.ParamLocationQuery, *params.Authoritative); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantsBaseGetTenantsRequest generates requests for TenantsBaseGetTenants
func NewTenantsBaseGetTenantsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantsBaseDeleteTenantRequest generates requests for TenantsBaseDeleteTenant
func NewTenantsBaseDeleteTenantRequest(server string, tenant string, params *TenantsBaseDeleteTenantParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantsBaseGetTenantAdminRequest generates requests for TenantsBaseGetTenantAdmin
func NewTenantsBaseGetTenantAdminRequest(server string, tenant string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTenantsBaseUpdateTenantRequest calls the generic TenantsBaseUpdateTenant builder with application/json body
func NewTenantsBaseUpdateTenantRequest(server string, tenant string, body TenantsBaseUpdateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantsBaseUpdateTenantRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewTenantsBaseUpdateTenantRequestWithBody generates requests for TenantsBaseUpdateTenant with any type of body
func NewTenantsBaseUpdateTenantRequestWithBody(server string, tenant string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTenantsBaseCreateTenantRequest calls the generic TenantsBaseCreateTenant builder with application/json body
func NewTenantsBaseCreateTenantRequest(server string, tenant string, body TenantsBaseCreateTenantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTenantsBaseCreateTenantRequestWithBody(server, tenant, "application/json", bodyReader)
}

// NewTenantsBaseCreateTenantRequestWithBody generates requests for TenantsBaseCreateTenant with any type of body
func NewTenantsBaseCreateTenantRequestWithBody(server string, tenant string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tenant", runtime.ParamLocationPath, tenant)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tenants/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewWorkerStatsGetStatsRequest generates requests for WorkerStatsGetStats
func NewWorkerStatsGetStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker-stats/functionsmetrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerStatsGetMetricsRequest generates requests for WorkerStatsGetMetrics
func NewWorkerStatsGetMetricsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker-stats/metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerGetAssignmentsRequest generates requests for WorkerGetAssignments
func NewWorkerGetAssignmentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/assignments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerGetClusterRequest generates requests for WorkerGetCluster
func NewWorkerGetClusterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerGetClusterLeaderRequest generates requests for WorkerGetClusterLeader
func NewWorkerGetClusterLeaderRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster/leader")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerIsLeaderReadyRequest generates requests for WorkerIsLeaderReady
func NewWorkerIsLeaderReadyRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/cluster/leader/ready")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerGetConnectorsListRequest generates requests for WorkerGetConnectorsList
func NewWorkerGetConnectorsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/connectors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerGetDrainStatusRequest generates requests for WorkerGetDrainStatus
func NewWorkerGetDrainStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerDrainRequest generates requests for WorkerDrain
func NewWorkerDrainRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerGetDrainStatusFromLeaderRequest generates requests for WorkerGetDrainStatusFromLeader
func NewWorkerGetDrainStatusFromLeaderRequest(server string, params *WorkerGetDrainStatusFromLeaderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/leader/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WorkerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workerId", runtime.ParamLocationQuery, *params.WorkerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerDrainAtLeaderRequest generates requests for WorkerDrainAtLeader
func NewWorkerDrainAtLeaderRequest(server string, params *WorkerDrainAtLeaderParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/leader/drain")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WorkerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workerId", runtime.ParamLocationQuery, *params.WorkerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWorkerRebalanceRequest generates requests for WorkerRebalance
func NewWorkerRebalanceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/worker/rebalance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// BookiesGetAllBookiesWithResponse request
	BookiesGetAllBookiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BookiesGetAllBookiesResponse, error)

	// BookiesGetBookiesRackInfoWithResponse request
	BookiesGetBookiesRackInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BookiesGetBookiesRackInfoResponse, error)

	// BookiesDeleteBookieRackInfoWithResponse request
	BookiesDeleteBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*BookiesDeleteBookieRackInfoResponse, error)

	// BookiesGetBookieRackInfoWithResponse request
	BookiesGetBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*BookiesGetBookieRackInfoResponse, error)

	// BookiesUpdateBookieRackInfoWithResponse request
	BookiesUpdateBookieRackInfoWithResponse(ctx context.Context, bookie string, params *BookiesUpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*BookiesUpdateBookieRackInfoResponse, error)

	// BrokerStatsBaseGetAllocatorStatsWithResponse request
	BrokerStatsBaseGetAllocatorStatsWithResponse(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetAllocatorStatsResponse, error)

	// BrokerStatsBaseGetPendingBookieOpsStatsWithResponse request
	BrokerStatsBaseGetPendingBookieOpsStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetPendingBookieOpsStatsResponse, error)

	// BrokerStatsGetBrokerResourceAvailabilityWithResponse request
	BrokerStatsGetBrokerResourceAvailabilityWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*BrokerStatsGetBrokerResourceAvailabilityResponse, error)

	// BrokerStatsBaseGetLoadReportWithResponse request
	BrokerStatsBaseGetLoadReportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetLoadReportResponse, error)

	// BrokerStatsBaseGetMBeansWithResponse request
	BrokerStatsBaseGetMBeansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetMBeansResponse, error)

	// BrokerStatsBaseGetMetricsWithResponse request
	BrokerStatsBaseGetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetMetricsResponse, error)

	// BrokerStatsGetTopics2WithResponse request
	BrokerStatsGetTopics2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsGetTopics2Response, error)

	// BrokersBaseGetActiveBrokersWithResponse request
	BrokersBaseGetActiveBrokersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetActiveBrokersResponse, error)

	// BrokersBaseBacklogQuotaCheckWithResponse request
	BrokersBaseBacklogQuotaCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseBacklogQuotaCheckResponse, error)

	// BrokersBaseGetDynamicConfigurationNameWithResponse request
	BrokersBaseGetDynamicConfigurationNameWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetDynamicConfigurationNameResponse, error)

	// BrokersBaseGetRuntimeConfigurationWithResponse request
	BrokersBaseGetRuntimeConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetRuntimeConfigurationResponse, error)

	// BrokersBaseGetAllDynamicConfigurationsWithResponse request
	BrokersBaseGetAllDynamicConfigurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetAllDynamicConfigurationsResponse, error)

	// BrokersBaseDeleteDynamicConfigurationWithResponse request
	BrokersBaseDeleteDynamicConfigurationWithResponse(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*BrokersBaseDeleteDynamicConfigurationResponse, error)

	// BrokersBaseUpdateDynamicConfigurationWithResponse request
	BrokersBaseUpdateDynamicConfigurationWithResponse(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*BrokersBaseUpdateDynamicConfigurationResponse, error)

	// BrokersBaseHealthCheckWithResponse request
	BrokersBaseHealthCheckWithResponse(ctx context.Context, params *BrokersBaseHealthCheckParams, reqEditors ...RequestEditorFn) (*BrokersBaseHealthCheckResponse, error)

	// BrokersBaseGetInternalConfigurationDataWithResponse request
	BrokersBaseGetInternalConfigurationDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetInternalConfigurationDataResponse, error)

	// BrokersBaseGetLeaderBrokerWithResponse request
	BrokersBaseGetLeaderBrokerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetLeaderBrokerResponse, error)

	// BrokersBaseIsReadyWithResponse request
	BrokersBaseIsReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseIsReadyResponse, error)

	// BrokersBaseShutDownBrokerGracefullyWithResponse request
	BrokersBaseShutDownBrokerGracefullyWithResponse(ctx context.Context, params *BrokersBaseShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*BrokersBaseShutDownBrokerGracefullyResponse, error)

	// BrokersBaseVersionWithResponse request
	BrokersBaseVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseVersionResponse, error)

	// BrokersBaseGetOwnedNamespacesWithResponse request
	BrokersBaseGetOwnedNamespacesWithResponse(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*BrokersBaseGetOwnedNamespacesResponse, error)

	// BrokersBaseGetActiveBrokersByClusterWithResponse request
	BrokersBaseGetActiveBrokersByClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*BrokersBaseGetActiveBrokersByClusterResponse, error)

	// ClustersBaseGetClustersWithResponse request
	ClustersBaseGetClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClustersBaseGetClustersResponse, error)

	// ClustersBaseDeleteClusterWithResponse request
	ClustersBaseDeleteClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseDeleteClusterResponse, error)

	// ClustersBaseGetClusterWithResponse request
	ClustersBaseGetClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetClusterResponse, error)

	// ClustersBaseUpdateClusterWithBodyWithResponse request with any body
	ClustersBaseUpdateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseUpdateClusterResponse, error)

	// ClustersBaseCreateClusterWithBodyWithResponse request with any body
	ClustersBaseCreateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseCreateClusterResponse, error)

	// ClustersBaseGetFailureDomainsWithResponse request
	ClustersBaseGetFailureDomainsWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetFailureDomainsResponse, error)

	// ClustersBaseDeleteFailureDomainWithResponse request
	ClustersBaseDeleteFailureDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*ClustersBaseDeleteFailureDomainResponse, error)

	// ClustersBaseGetDomainWithResponse request
	ClustersBaseGetDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*ClustersBaseGetDomainResponse, error)

	// ClustersBaseSetFailureDomainWithBodyWithResponse request with any body
	ClustersBaseSetFailureDomainWithBodyWithResponse(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseSetFailureDomainResponse, error)

	// ClustersBaseUpdateClusterMigrationWithBodyWithResponse request with any body
	ClustersBaseUpdateClusterMigrationWithBodyWithResponse(ctx context.Context, cluster string, params *ClustersBaseUpdateClusterMigrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseUpdateClusterMigrationResponse, error)

	// ClustersBaseGetNamespaceIsolationPoliciesWithResponse request
	ClustersBaseGetNamespaceIsolationPoliciesWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetNamespaceIsolationPoliciesResponse, error)

	// ClustersBaseGetBrokersWithNamespaceIsolationPolicyWithResponse request
	ClustersBaseGetBrokersWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse, error)

	// ClustersBaseGetBrokerWithNamespaceIsolationPolicyWithResponse request
	ClustersBaseGetBrokerWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*ClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse, error)

	// ClustersBaseDeleteNamespaceIsolationPolicyWithResponse request
	ClustersBaseDeleteNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*ClustersBaseDeleteNamespaceIsolationPolicyResponse, error)

	// ClustersBaseGetNamespaceIsolationPolicyWithResponse request
	ClustersBaseGetNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*ClustersBaseGetNamespaceIsolationPolicyResponse, error)

	// ClustersBaseSetNamespaceIsolationPolicyWithBodyWithResponse request with any body
	ClustersBaseSetNamespaceIsolationPolicyWithBodyWithResponse(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseSetNamespaceIsolationPolicyResponse, error)

	// ClustersBaseGetPeerClusterWithResponse request
	ClustersBaseGetPeerClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetPeerClusterResponse, error)

	// ClustersBaseSetPeerClusterNamesWithBodyWithResponse request with any body
	ClustersBaseSetPeerClusterNamesWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseSetPeerClusterNamesResponse, error)

	// NamespacesGetAntiAffinityNamespacesWithResponse request
	NamespacesGetAntiAffinityNamespacesWithResponse(ctx context.Context, cluster string, group string, params *NamespacesGetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*NamespacesGetAntiAffinityNamespacesResponse, error)

	// NamespacesDeleteBookieAffinityGroupWithResponse request
	NamespacesDeleteBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteBookieAffinityGroupResponse, error)

	// NamespacesGetBookieAffinityGroupWithResponse request
	NamespacesGetBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetBookieAffinityGroupResponse, error)

	// NamespacesGetTenantNamespacesWithResponse request
	NamespacesGetTenantNamespacesWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*NamespacesGetTenantNamespacesResponse, error)

	// NamespacesDeleteNamespaceWithResponse request
	NamespacesDeleteNamespaceWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesDeleteNamespaceParams, reqEditors ...RequestEditorFn) (*NamespacesDeleteNamespaceResponse, error)

	// NamespacesGetPoliciesWithResponse request
	NamespacesGetPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPoliciesResponse, error)

	// NamespacesCreateNamespaceWithBodyWithResponse request with any body
	NamespacesCreateNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesCreateNamespaceResponse, error)

	NamespacesCreateNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesCreateNamespaceResponse, error)

	// NamespacesRemoveNamespaceAntiAffinityGroupWithResponse request
	NamespacesRemoveNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveNamespaceAntiAffinityGroupResponse, error)

	// NamespacesGetNamespaceAntiAffinityGroupWithResponse request
	NamespacesGetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetNamespaceAntiAffinityGroupResponse, error)

	// NamespacesSetNamespaceAntiAffinityGroupWithBodyWithResponse request with any body
	NamespacesSetNamespaceAntiAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceAntiAffinityGroupResponse, error)

	NamespacesSetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceAntiAffinityGroupResponse, error)

	// NamespacesRemoveAutoSubscriptionCreationWithResponse request
	NamespacesRemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveAutoSubscriptionCreationResponse, error)

	// NamespacesGetAutoSubscriptionCreationWithResponse request
	NamespacesGetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetAutoSubscriptionCreationResponse, error)

	// NamespacesSetAutoSubscriptionCreationWithBodyWithResponse request with any body
	NamespacesSetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetAutoSubscriptionCreationResponse, error)

	NamespacesSetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetAutoSubscriptionCreationResponse, error)

	// NamespacesRemoveAutoTopicCreationWithResponse request
	NamespacesRemoveAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveAutoTopicCreationResponse, error)

	// NamespacesGetAutoTopicCreationWithResponse request
	NamespacesGetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetAutoTopicCreationResponse, error)

	// NamespacesSetAutoTopicCreationWithBodyWithResponse request with any body
	NamespacesSetAutoTopicCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetAutoTopicCreationResponse, error)

	NamespacesSetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetAutoTopicCreationResponse, error)

	// NamespacesRemoveBacklogQuotaWithResponse request
	NamespacesRemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*NamespacesRemoveBacklogQuotaResponse, error)

	// NamespacesSetBacklogQuotaWithBodyWithResponse request with any body
	NamespacesSetBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetBacklogQuotaResponse, error)

	NamespacesSetBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, body NamespacesSetBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetBacklogQuotaResponse, error)

	// NamespacesGetBacklogQuotaMapWithResponse request
	NamespacesGetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetBacklogQuotaMapResponse, error)

	// NamespacesGetBundlesDataWithResponse request
	NamespacesGetBundlesDataWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetBundlesDataResponse, error)

	// NamespacesClearNamespaceBacklogWithResponse request
	NamespacesClearNamespaceBacklogWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*NamespacesClearNamespaceBacklogResponse, error)

	// NamespacesClearNamespaceBacklogForSubscriptionWithResponse request
	NamespacesClearNamespaceBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *NamespacesClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*NamespacesClearNamespaceBacklogForSubscriptionResponse, error)

	// NamespacesDeleteCompactionThresholdWithResponse request
	NamespacesDeleteCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteCompactionThresholdResponse, error)

	// NamespacesGetCompactionThresholdWithResponse request
	NamespacesGetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetCompactionThresholdResponse, error)

	// NamespacesSetCompactionThresholdWithBodyWithResponse request with any body
	NamespacesSetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetCompactionThresholdResponse, error)

	NamespacesSetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetCompactionThresholdResponse, error)

	// NamespacesRemoveDeduplicationWithResponse request
	NamespacesRemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveDeduplicationResponse, error)

	// NamespacesGetDeduplicationWithResponse request
	NamespacesGetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetDeduplicationResponse, error)

	// NamespacesModifyDeduplicationWithBodyWithResponse request with any body
	NamespacesModifyDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesModifyDeduplicationResponse, error)

	NamespacesModifyDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesModifyDeduplicationResponse, error)

	// NamespacesGetDeduplicationSnapshotIntervalWithResponse request
	NamespacesGetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetDeduplicationSnapshotIntervalResponse, error)

	// NamespacesSetDeduplicationSnapshotIntervalWithBodyWithResponse request with any body
	NamespacesSetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetDeduplicationSnapshotIntervalResponse, error)

	NamespacesSetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetDeduplicationSnapshotIntervalResponse, error)

	// NamespacesRemoveDelayedDeliveryPoliciesWithResponse request
	NamespacesRemoveDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveDelayedDeliveryPoliciesResponse, error)

	// NamespacesGetDelayedDeliveryPoliciesWithResponse request
	NamespacesGetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetDelayedDeliveryPoliciesResponse, error)

	// NamespacesSetDelayedDeliveryPoliciesWithBodyWithResponse request with any body
	NamespacesSetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetDelayedDeliveryPoliciesResponse, error)

	NamespacesSetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetDelayedDeliveryPoliciesResponse, error)

	// NamespacesDeleteDispatchRateWithResponse request
	NamespacesDeleteDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteDispatchRateResponse, error)

	// NamespacesGetDispatchRateWithResponse request
	NamespacesGetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetDispatchRateResponse, error)

	// NamespacesSetDispatchRateWithBodyWithResponse request with any body
	NamespacesSetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetDispatchRateResponse, error)

	NamespacesSetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetDispatchRateResponse, error)

	// NamespacesGetEncryptionRequiredWithResponse request
	NamespacesGetEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetEncryptionRequiredResponse, error)

	// NamespacesModifyEncryptionRequiredWithBodyWithResponse request with any body
	NamespacesModifyEncryptionRequiredWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesModifyEncryptionRequiredResponse, error)

	NamespacesModifyEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesModifyEncryptionRequiredResponse, error)

	// NamespacesRemoveNamespaceEntryFiltersWithResponse request
	NamespacesRemoveNamespaceEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveNamespaceEntryFiltersResponse, error)

	// NamespacesGetEntryFiltersPerTopicWithResponse request
	NamespacesGetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetEntryFiltersPerTopicResponse, error)

	// NamespacesSetEntryFiltersPerTopicWithBodyWithResponse request with any body
	NamespacesSetEntryFiltersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetEntryFiltersPerTopicResponse, error)

	NamespacesSetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetEntryFiltersPerTopicResponse, error)

	// NamespacesRemoveInactiveTopicPoliciesWithResponse request
	NamespacesRemoveInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveInactiveTopicPoliciesResponse, error)

	// NamespacesGetInactiveTopicPoliciesWithResponse request
	NamespacesGetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetInactiveTopicPoliciesResponse, error)

	// NamespacesSetInactiveTopicPoliciesWithBodyWithResponse request with any body
	NamespacesSetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetInactiveTopicPoliciesResponse, error)

	NamespacesSetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetInactiveTopicPoliciesResponse, error)

	// NamespacesGetIsAllowAutoUpdateSchemaWithResponse request
	NamespacesGetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetIsAllowAutoUpdateSchemaResponse, error)

	// NamespacesSetIsAllowAutoUpdateSchemaWithBodyWithResponse request with any body
	NamespacesSetIsAllowAutoUpdateSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetIsAllowAutoUpdateSchemaResponse, error)

	NamespacesSetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetIsAllowAutoUpdateSchemaResponse, error)

	// NamespacesRemoveMaxConsumersPerSubscriptionWithResponse request
	NamespacesRemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxConsumersPerSubscriptionResponse, error)

	// NamespacesGetMaxConsumersPerSubscriptionWithResponse request
	NamespacesGetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxConsumersPerSubscriptionResponse, error)

	// NamespacesSetMaxConsumersPerSubscriptionWithBodyWithResponse request with any body
	NamespacesSetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxConsumersPerSubscriptionResponse, error)

	NamespacesSetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxConsumersPerSubscriptionResponse, error)

	// NamespacesRemoveMaxConsumersPerTopicWithResponse request
	NamespacesRemoveMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxConsumersPerTopicResponse, error)

	// NamespacesGetMaxConsumersPerTopicWithResponse request
	NamespacesGetMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxConsumersPerTopicResponse, error)

	// NamespacesSetMaxConsumersPerTopicWithBodyWithResponse request with any body
	NamespacesSetMaxConsumersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxConsumersPerTopicResponse, error)

	NamespacesSetMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxConsumersPerTopicResponse, error)

	// NamespacesRemoveMaxProducersPerTopicWithResponse request
	NamespacesRemoveMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxProducersPerTopicResponse, error)

	// NamespacesGetMaxProducersPerTopicWithResponse request
	NamespacesGetMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxProducersPerTopicResponse, error)

	// NamespacesSetMaxProducersPerTopicWithBodyWithResponse request with any body
	NamespacesSetMaxProducersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxProducersPerTopicResponse, error)

	NamespacesSetMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxProducersPerTopicResponse, error)

	// NamespacesRemoveMaxSubscriptionsPerTopicWithResponse request
	NamespacesRemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxSubscriptionsPerTopicResponse, error)

	// NamespacesGetMaxSubscriptionsPerTopicWithResponse request
	NamespacesGetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxSubscriptionsPerTopicResponse, error)

	// NamespacesSetMaxSubscriptionsPerTopicWithBodyWithResponse request with any body
	NamespacesSetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxSubscriptionsPerTopicResponse, error)

	NamespacesSetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxSubscriptionsPerTopicResponse, error)

	// NamespacesRemoveMaxTopicsPerNamespaceWithResponse request
	NamespacesRemoveMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxTopicsPerNamespaceResponse, error)

	// NamespacesGetMaxTopicsPerNamespaceWithResponse request
	NamespacesGetMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxTopicsPerNamespaceResponse, error)

	// NamespacesSetMaxTopicsPerNamespaceWithBodyWithResponse request with any body
	NamespacesSetMaxTopicsPerNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxTopicsPerNamespaceResponse, error)

	NamespacesSetMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxTopicsPerNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxTopicsPerNamespaceResponse, error)

	// NamespacesRemoveMaxUnackedmessagesPerConsumerWithResponse request
	NamespacesRemoveMaxUnackedmessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxUnackedmessagesPerConsumerResponse, error)

	// NamespacesGetMaxUnackedMessagesPerConsumerWithResponse request
	NamespacesGetMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxUnackedMessagesPerConsumerResponse, error)

	// NamespacesSetMaxUnackedMessagesPerConsumerWithBodyWithResponse request with any body
	NamespacesSetMaxUnackedMessagesPerConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxUnackedMessagesPerConsumerResponse, error)

	NamespacesSetMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxUnackedMessagesPerConsumerResponse, error)

	// NamespacesRemoveMaxUnackedmessagesPerSubscriptionWithResponse request
	NamespacesRemoveMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse, error)

	// NamespacesGetMaxUnackedmessagesPerSubscriptionWithResponse request
	NamespacesGetMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxUnackedmessagesPerSubscriptionResponse, error)

	// NamespacesSetMaxUnackedMessagesPerSubscriptionWithBodyWithResponse request with any body
	NamespacesSetMaxUnackedMessagesPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxUnackedMessagesPerSubscriptionResponse, error)

	NamespacesSetMaxUnackedMessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxUnackedMessagesPerSubscriptionResponse, error)

	// NamespacesRemoveNamespaceMessageTTLWithResponse request
	NamespacesRemoveNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveNamespaceMessageTTLResponse, error)

	// NamespacesGetNamespaceMessageTTLWithResponse request
	NamespacesGetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetNamespaceMessageTTLResponse, error)

	// NamespacesSetNamespaceMessageTTLWithBodyWithResponse request with any body
	NamespacesSetNamespaceMessageTTLWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceMessageTTLResponse, error)

	NamespacesSetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceMessageTTLResponse, error)

	// NamespacesClearOffloadDeletionLagWithResponse request
	NamespacesClearOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesClearOffloadDeletionLagResponse, error)

	// NamespacesGetOffloadDeletionLagWithResponse request
	NamespacesGetOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetOffloadDeletionLagResponse, error)

	// NamespacesSetOffloadDeletionLagWithBodyWithResponse request with any body
	NamespacesSetOffloadDeletionLagWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadDeletionLagResponse, error)

	NamespacesSetOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadDeletionLagResponse, error)

	// NamespacesGetOffloadPoliciesWithResponse request
	NamespacesGetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetOffloadPoliciesResponse, error)

	// NamespacesSetOffloadPoliciesWithBodyWithResponse request with any body
	NamespacesSetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadPoliciesResponse, error)

	NamespacesSetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadPoliciesResponse, error)

	// NamespacesGetOffloadThresholdWithResponse request
	NamespacesGetOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetOffloadThresholdResponse, error)

	// NamespacesSetOffloadThresholdWithBodyWithResponse request with any body
	NamespacesSetOffloadThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadThresholdResponse, error)

	NamespacesSetOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadThresholdResponse, error)

	// NamespacesGetOffloadThresholdInSecondsWithResponse request
	NamespacesGetOffloadThresholdInSecondsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetOffloadThresholdInSecondsResponse, error)

	// NamespacesSetOffloadThresholdInSecondsWithResponse request
	NamespacesSetOffloadThresholdInSecondsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadThresholdInSecondsResponse, error)

	// NamespacesGetPermissionsWithResponse request
	NamespacesGetPermissionsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPermissionsResponse, error)

	// NamespacesGetPermissionOnSubscriptionWithResponse request
	NamespacesGetPermissionOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPermissionOnSubscriptionResponse, error)

	// NamespacesRevokePermissionsOnNamespaceWithResponse request
	NamespacesRevokePermissionsOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*NamespacesRevokePermissionsOnNamespaceResponse, error)

	// NamespacesGrantPermissionOnNamespaceWithBodyWithResponse request with any body
	NamespacesGrantPermissionOnNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesGrantPermissionOnNamespaceResponse, error)

	NamespacesGrantPermissionOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, body NamespacesGrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesGrantPermissionOnNamespaceResponse, error)

	// NamespacesDeletePersistenceWithResponse request
	NamespacesDeletePersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeletePersistenceResponse, error)

	// NamespacesGetPersistenceWithResponse request
	NamespacesGetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPersistenceResponse, error)

	// NamespacesSetPersistenceWithBodyWithResponse request with any body
	NamespacesSetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetPersistenceResponse, error)

	NamespacesSetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetPersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetPersistenceResponse, error)

	// NamespacesSetBookieAffinityGroupWithBodyWithResponse request with any body
	NamespacesSetBookieAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetBookieAffinityGroupResponse, error)

	NamespacesSetBookieAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetBookieAffinityGroupResponse, error)

	// NamespacesClearPropertiesWithResponse request
	NamespacesClearPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesClearPropertiesResponse, error)

	// NamespacesGetPropertiesWithResponse request
	NamespacesGetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPropertiesResponse, error)

	// NamespacesSetPropertiesWithBodyWithResponse request with any body
	NamespacesSetPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetPropertiesResponse, error)

	NamespacesSetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetPropertiesResponse, error)

	// NamespacesRemovePropertyWithResponse request
	NamespacesRemovePropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*NamespacesRemovePropertyResponse, error)

	// NamespacesGetPropertyWithResponse request
	NamespacesGetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*NamespacesGetPropertyResponse, error)

	// NamespacesSetPropertyWithResponse request
	NamespacesSetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*NamespacesSetPropertyResponse, error)

	// NamespacesRemoveOffloadPoliciesWithResponse request
	NamespacesRemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveOffloadPoliciesResponse, error)

	// NamespacesGetNamespaceReplicationClustersWithResponse request
	NamespacesGetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetNamespaceReplicationClustersResponse, error)

	// NamespacesSetNamespaceReplicationClustersWithBodyWithResponse request with any body
	NamespacesSetNamespaceReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceReplicationClustersResponse, error)

	NamespacesSetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceReplicationClustersResponse, error)

	// NamespacesRemoveReplicatorDispatchRateWithResponse request
	NamespacesRemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveReplicatorDispatchRateResponse, error)

	// NamespacesGetReplicatorDispatchRateWithResponse request
	NamespacesGetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetReplicatorDispatchRateResponse, error)

	// NamespacesSetReplicatorDispatchRateWithBodyWithResponse request with any body
	NamespacesSetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetReplicatorDispatchRateResponse, error)

	NamespacesSetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetReplicatorDispatchRateResponse, error)

	// NamespacesRemoveNamespaceResourceGroupWithResponse request
	NamespacesRemoveNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveNamespaceResourceGroupResponse, error)

	// NamespacesGetNamespaceResourceGroupWithResponse request
	NamespacesGetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetNamespaceResourceGroupResponse, error)

	// NamespacesSetNamespaceResourceGroupWithResponse request
	NamespacesSetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceResourceGroupResponse, error)

	// NamespacesRemoveRetentionWithBodyWithResponse request with any body
	NamespacesRemoveRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesRemoveRetentionResponse, error)

	NamespacesRemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesRemoveRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesRemoveRetentionResponse, error)

	// NamespacesGetRetentionWithResponse request
	NamespacesGetRetentionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetRetentionResponse, error)

	// NamespacesSetRetentionWithBodyWithResponse request with any body
	NamespacesSetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetRetentionResponse, error)

	NamespacesSetRetentionWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetRetentionResponse, error)

	// NamespacesScanOffloadedLedgersWithResponse request
	NamespacesScanOffloadedLedgersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesScanOffloadedLedgersResponse, error)

	// NamespacesGetSchemaAutoUpdateCompatibilityStrategyWithResponse request
	NamespacesGetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	// NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse request with any body
	NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse, error)

	// NamespacesGetSchemaCompatibilityStrategyWithResponse request
	NamespacesGetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSchemaCompatibilityStrategyResponse, error)

	// NamespacesSetSchemaCompatibilityStrategyWithBodyWithResponse request with any body
	NamespacesSetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaCompatibilityStrategyResponse, error)

	NamespacesSetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaCompatibilityStrategyResponse, error)

	// NamespacesGetSchemaValidtionEnforcedWithResponse request
	NamespacesGetSchemaValidtionEnforcedWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesGetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*NamespacesGetSchemaValidtionEnforcedResponse, error)

	// NamespacesSetSchemaValidationEnforcedWithBodyWithResponse request with any body
	NamespacesSetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaValidationEnforcedResponse, error)

	NamespacesSetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaValidationEnforcedResponse, error)

	// NamespacesDeleteSubscribeRateWithResponse request
	NamespacesDeleteSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteSubscribeRateResponse, error)

	// NamespacesGetSubscribeRateWithResponse request
	NamespacesGetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscribeRateResponse, error)

	// NamespacesSetSubscribeRateWithBodyWithResponse request with any body
	NamespacesSetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscribeRateResponse, error)

	NamespacesSetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscribeRateResponse, error)

	// NamespacesGetSubscriptionAuthModeWithResponse request
	NamespacesGetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscriptionAuthModeResponse, error)

	// NamespacesSetSubscriptionAuthModeWithBodyWithResponse request with any body
	NamespacesSetSubscriptionAuthModeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionAuthModeResponse, error)

	NamespacesSetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionAuthModeResponse, error)

	// NamespacesDeleteSubscriptionDispatchRateWithResponse request
	NamespacesDeleteSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteSubscriptionDispatchRateResponse, error)

	// NamespacesGetSubscriptionDispatchRateWithResponse request
	NamespacesGetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscriptionDispatchRateResponse, error)

	// NamespacesSetSubscriptionDispatchRateWithBodyWithResponse request with any body
	NamespacesSetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionDispatchRateResponse, error)

	NamespacesSetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionDispatchRateResponse, error)

	// NamespacesRemoveSubscriptionExpirationTimeWithResponse request
	NamespacesRemoveSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveSubscriptionExpirationTimeResponse, error)

	// NamespacesGetSubscriptionExpirationTimeWithResponse request
	NamespacesGetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscriptionExpirationTimeResponse, error)

	// NamespacesSetSubscriptionExpirationTimeWithBodyWithResponse request with any body
	NamespacesSetSubscriptionExpirationTimeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionExpirationTimeResponse, error)

	NamespacesSetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionExpirationTimeResponse, error)

	// NamespacesRemoveSubscriptionTypesEnabledWithResponse request
	NamespacesRemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveSubscriptionTypesEnabledResponse, error)

	// NamespacesGetSubscriptionTypesEnabledWithResponse request
	NamespacesGetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscriptionTypesEnabledResponse, error)

	// NamespacesSetSubscriptionTypesEnabledWithBodyWithResponse request with any body
	NamespacesSetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionTypesEnabledResponse, error)

	NamespacesSetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionTypesEnabledResponse, error)

	// NamespacesGetTopicsWithResponse request
	NamespacesGetTopicsWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesGetTopicsParams, reqEditors ...RequestEditorFn) (*NamespacesGetTopicsResponse, error)

	// NamespacesUnloadNamespaceWithResponse request
	NamespacesUnloadNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesUnloadNamespaceResponse, error)

	// NamespacesUnsubscribeNamespaceWithResponse request
	NamespacesUnsubscribeNamespaceWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *NamespacesUnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*NamespacesUnsubscribeNamespaceResponse, error)

	// NamespacesDeleteNamespaceBundleWithResponse request
	NamespacesDeleteNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesDeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*NamespacesDeleteNamespaceBundleResponse, error)

	// NamespacesClearNamespaceBundleBacklogWithResponse request
	NamespacesClearNamespaceBundleBacklogWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*NamespacesClearNamespaceBundleBacklogResponse, error)

	// NamespacesClearNamespaceBundleBacklogForSubscriptionWithResponse request
	NamespacesClearNamespaceBundleBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *NamespacesClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*NamespacesClearNamespaceBundleBacklogForSubscriptionResponse, error)

	// NamespacesSplitNamespaceBundleWithBodyWithResponse request with any body
	NamespacesSplitNamespaceBundleWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSplitNamespaceBundleResponse, error)

	NamespacesSplitNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, body NamespacesSplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSplitNamespaceBundleResponse, error)

	// NamespacesGetTopicHashPositionsWithResponse request
	NamespacesGetTopicHashPositionsWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesGetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*NamespacesGetTopicHashPositionsResponse, error)

	// NamespacesUnloadNamespaceBundleWithResponse request
	NamespacesUnloadNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesUnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*NamespacesUnloadNamespaceBundleResponse, error)

	// NamespacesUnsubscribeNamespaceBundleWithResponse request
	NamespacesUnsubscribeNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *NamespacesUnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*NamespacesUnsubscribeNamespaceBundleResponse, error)

	// NonPersistentTopicsGetListWithResponse request
	NonPersistentTopicsGetListWithResponse(ctx context.Context, tenant string, namespace string, params *NonPersistentTopicsGetListParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetListResponse, error)

	// NonPersistentTopicsGetPartitionedTopicListWithResponse request
	NonPersistentTopicsGetPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *NonPersistentTopicsGetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPartitionedTopicListResponse, error)

	// NonPersistentTopicsGetListFromBundleWithResponse request
	NonPersistentTopicsGetListFromBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetListFromBundleResponse, error)

	// NonPersistentTopicsDeleteTopicWithResponse request
	NonPersistentTopicsDeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteTopicResponse, error)

	// NonPersistentTopicsCreateNonPartitionedTopicWithBodyWithResponse request with any body
	NonPersistentTopicsCreateNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCreateNonPartitionedTopicResponse, error)

	// NonPersistentTopicsExpireMessagesForAllSubscriptionsWithResponse request
	NonPersistentTopicsExpireMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsExpireMessagesForAllSubscriptionsResponse, error)

	// NonPersistentTopicsRemoveAutoSubscriptionCreationWithResponse request
	NonPersistentTopicsRemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveAutoSubscriptionCreationResponse, error)

	// NonPersistentTopicsGetAutoSubscriptionCreationWithResponse request
	NonPersistentTopicsGetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetAutoSubscriptionCreationResponse, error)

	// NonPersistentTopicsSetAutoSubscriptionCreationWithBodyWithResponse request with any body
	NonPersistentTopicsSetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetAutoSubscriptionCreationResponse, error)

	// NonPersistentTopicsGetBacklogWithResponse request
	NonPersistentTopicsGetBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetBacklogResponse, error)

	// NonPersistentTopicsRemoveBacklogQuotaWithResponse request
	NonPersistentTopicsRemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveBacklogQuotaResponse, error)

	// NonPersistentTopicsSetBacklogQuotaWithBodyWithResponse request with any body
	NonPersistentTopicsSetBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetBacklogQuotaResponse, error)

	// NonPersistentTopicsGetBacklogQuotaMapWithResponse request
	NonPersistentTopicsGetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetBacklogQuotaMapResponse, error)

	// NonPersistentTopicsGetBacklogSizeByMessageIdWithResponse request
	NonPersistentTopicsGetBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetBacklogSizeByMessageIdResponse, error)

	// NonPersistentTopicsCompactionStatusWithResponse request
	NonPersistentTopicsCompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactionStatusParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCompactionStatusResponse, error)

	// NonPersistentTopicsCompactWithResponse request
	NonPersistentTopicsCompactWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCompactResponse, error)

	// NonPersistentTopicsRemoveCompactionThresholdWithResponse request
	NonPersistentTopicsRemoveCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveCompactionThresholdResponse, error)

	// NonPersistentTopicsGetCompactionThresholdWithResponse request
	NonPersistentTopicsGetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetCompactionThresholdResponse, error)

	// NonPersistentTopicsSetCompactionThresholdWithBodyWithResponse request with any body
	NonPersistentTopicsSetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetCompactionThresholdResponse, error)

	// NonPersistentTopicsCreateMissedPartitionsWithResponse request
	NonPersistentTopicsCreateMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCreateMissedPartitionsResponse, error)

	// NonPersistentTopicsRemoveDeduplicationWithResponse request
	NonPersistentTopicsRemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveDeduplicationResponse, error)

	// NonPersistentTopicsGetDeduplicationWithResponse request
	NonPersistentTopicsGetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetDeduplicationResponse, error)

	// NonPersistentTopicsSetDeduplicationWithBodyWithResponse request with any body
	NonPersistentTopicsSetDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetDeduplicationResponse, error)

	// NonPersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse request
	NonPersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse, error)

	// NonPersistentTopicsGetDeduplicationSnapshotIntervalWithResponse request
	NonPersistentTopicsGetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetDeduplicationSnapshotIntervalResponse, error)

	// NonPersistentTopicsSetDeduplicationSnapshotIntervalWithBodyWithResponse request with any body
	NonPersistentTopicsSetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetDeduplicationSnapshotIntervalResponse, error)

	// NonPersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse request
	NonPersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse, error)

	// NonPersistentTopicsGetDelayedDeliveryPoliciesWithResponse request
	NonPersistentTopicsGetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetDelayedDeliveryPoliciesResponse, error)

	// NonPersistentTopicsSetDelayedDeliveryPoliciesWithBodyWithResponse request with any body
	NonPersistentTopicsSetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetDelayedDeliveryPoliciesResponse, error)

	// NonPersistentTopicsRemoveDispatchRateWithResponse request
	NonPersistentTopicsRemoveDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveDispatchRateResponse, error)

	// NonPersistentTopicsGetDispatchRateWithResponse request
	NonPersistentTopicsGetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetDispatchRateResponse, error)

	// NonPersistentTopicsSetDispatchRateWithBodyWithResponse request with any body
	NonPersistentTopicsSetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetDispatchRateResponse, error)

	// NonPersistentTopicsRemoveEntryFiltersWithResponse request
	NonPersistentTopicsRemoveEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveEntryFiltersResponse, error)

	// NonPersistentTopicsGetEntryFiltersWithResponse request
	NonPersistentTopicsGetEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetEntryFiltersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetEntryFiltersResponse, error)

	// NonPersistentTopicsSetEntryFiltersWithBodyWithResponse request with any body
	NonPersistentTopicsSetEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetEntryFiltersResponse, error)

	// NonPersistentTopicsExamineMessageWithResponse request
	NonPersistentTopicsExamineMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsExamineMessageParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsExamineMessageResponse, error)

	// NonPersistentTopicsDeleteInactiveTopicPoliciesWithResponse request
	NonPersistentTopicsDeleteInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteInactiveTopicPoliciesResponse, error)

	// NonPersistentTopicsGetInactiveTopicPoliciesWithResponse request
	NonPersistentTopicsGetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetInactiveTopicPoliciesResponse, error)

	// NonPersistentTopicsSetInactiveTopicPoliciesWithBodyWithResponse request with any body
	NonPersistentTopicsSetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetInactiveTopicPoliciesResponse, error)

	// NonPersistentTopicsGetManagedLedgerInfoWithResponse request
	NonPersistentTopicsGetManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetManagedLedgerInfoResponse, error)

	// NonPersistentTopicsGetInternalStatsWithResponse request
	NonPersistentTopicsGetInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInternalStatsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetInternalStatsResponse, error)

	// NonPersistentTopicsGetLastMessageIdWithResponse request
	NonPersistentTopicsGetLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetLastMessageIdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetLastMessageIdResponse, error)

	// NonPersistentTopicsGetMessageByIdWithResponse request
	NonPersistentTopicsGetMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *NonPersistentTopicsGetMessageByIdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMessageByIdResponse, error)

	// NonPersistentTopicsRemoveMaxConsumersWithResponse request
	NonPersistentTopicsRemoveMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxConsumersResponse, error)

	// NonPersistentTopicsGetMaxConsumersWithResponse request
	NonPersistentTopicsGetMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxConsumersResponse, error)

	// NonPersistentTopicsSetMaxConsumersWithBodyWithResponse request with any body
	NonPersistentTopicsSetMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxConsumersResponse, error)

	// NonPersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse request
	NonPersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse, error)

	// NonPersistentTopicsGetMaxConsumersPerSubscriptionWithResponse request
	NonPersistentTopicsGetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxConsumersPerSubscriptionResponse, error)

	// NonPersistentTopicsSetMaxConsumersPerSubscriptionWithBodyWithResponse request with any body
	NonPersistentTopicsSetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxConsumersPerSubscriptionResponse, error)

	// NonPersistentTopicsRemoveMaxMessageSizeWithResponse request
	NonPersistentTopicsRemoveMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxMessageSizeResponse, error)

	// NonPersistentTopicsGetMaxMessageSizeWithResponse request
	NonPersistentTopicsGetMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxMessageSizeResponse, error)

	// NonPersistentTopicsSetMaxMessageSizeWithBodyWithResponse request with any body
	NonPersistentTopicsSetMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxMessageSizeResponse, error)

	// NonPersistentTopicsRemoveMaxProducersWithResponse request
	NonPersistentTopicsRemoveMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxProducersResponse, error)

	// NonPersistentTopicsGetMaxProducersWithResponse request
	NonPersistentTopicsGetMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxProducersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxProducersResponse, error)

	// NonPersistentTopicsSetMaxProducersWithBodyWithResponse request with any body
	NonPersistentTopicsSetMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxProducersResponse, error)

	// NonPersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse request
	NonPersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse, error)

	// NonPersistentTopicsGetMaxSubscriptionsPerTopicWithResponse request
	NonPersistentTopicsGetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxSubscriptionsPerTopicResponse, error)

	// NonPersistentTopicsSetMaxSubscriptionsPerTopicWithBodyWithResponse request with any body
	NonPersistentTopicsSetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxSubscriptionsPerTopicResponse, error)

	// NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse request
	NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse, error)

	// NonPersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse request
	NonPersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse, error)

	// NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithBodyWithResponse request with any body
	NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse, error)

	// NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse request
	NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse, error)

	// NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse request
	NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse, error)

	// NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse request with any body
	NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse, error)

	// NonPersistentTopicsRemoveMessageTTLWithResponse request
	NonPersistentTopicsRemoveMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMessageTTLResponse, error)

	// NonPersistentTopicsGetMessageTTLWithResponse request
	NonPersistentTopicsGetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMessageTTLParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMessageTTLResponse, error)

	// NonPersistentTopicsSetMessageTTLWithResponse request
	NonPersistentTopicsSetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMessageTTLParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMessageTTLResponse, error)

	// NonPersistentTopicsGetMessageIdByTimestampWithResponse request
	NonPersistentTopicsGetMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *NonPersistentTopicsGetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMessageIdByTimestampResponse, error)

	// NonPersistentTopicsOffloadStatusWithResponse request
	NonPersistentTopicsOffloadStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsOffloadStatusParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsOffloadStatusResponse, error)

	// NonPersistentTopicsTriggerOffloadWithResponse request
	NonPersistentTopicsTriggerOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTriggerOffloadParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTriggerOffloadResponse, error)

	// NonPersistentTopicsRemoveOffloadPoliciesWithResponse request
	NonPersistentTopicsRemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveOffloadPoliciesResponse, error)

	// NonPersistentTopicsGetOffloadPoliciesWithResponse request
	NonPersistentTopicsGetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetOffloadPoliciesResponse, error)

	// NonPersistentTopicsSetOffloadPoliciesWithBodyWithResponse request with any body
	NonPersistentTopicsSetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetOffloadPoliciesResponse, error)

	// NonPersistentTopicsGetPartitionedStatsInternalWithResponse request
	NonPersistentTopicsGetPartitionedStatsInternalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsInternalParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPartitionedStatsInternalResponse, error)

	// NonPersistentTopicsGetPartitionedStatsWithResponse request
	NonPersistentTopicsGetPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPartitionedStatsResponse, error)

	// NonPersistentTopicsDeletePartitionedTopicWithResponse request
	NonPersistentTopicsDeletePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeletePartitionedTopicResponse, error)

	// NonPersistentTopicsGetPartitionedMetadataWithResponse request
	NonPersistentTopicsGetPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPartitionedMetadataResponse, error)

	// NonPersistentTopicsUpdatePartitionedTopicWithBodyWithResponse request with any body
	NonPersistentTopicsUpdatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsUpdatePartitionedTopicResponse, error)

	// NonPersistentTopicsCreatePartitionedTopicWithBodyWithResponse request with any body
	NonPersistentTopicsCreatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCreatePartitionedTopicResponse, error)

	// NonPersistentTopicsGetPermissionsOnTopicWithResponse request
	NonPersistentTopicsGetPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPermissionsOnTopicResponse, error)

	// NonPersistentTopicsRevokePermissionsOnTopicWithResponse request
	NonPersistentTopicsRevokePermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRevokePermissionsOnTopicResponse, error)

	// NonPersistentTopicsGrantPermissionsOnTopicWithBodyWithResponse request with any body
	NonPersistentTopicsGrantPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGrantPermissionsOnTopicResponse, error)

	// NonPersistentTopicsRemovePersistenceWithResponse request
	NonPersistentTopicsRemovePersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePersistenceParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemovePersistenceResponse, error)

	// NonPersistentTopicsGetPersistenceWithResponse request
	NonPersistentTopicsGetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPersistenceParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPersistenceResponse, error)

	// NonPersistentTopicsSetPersistenceWithBodyWithResponse request with any body
	NonPersistentTopicsSetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetPersistenceResponse, error)

	// NonPersistentTopicsRemovePropertiesWithResponse request
	NonPersistentTopicsRemovePropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePropertiesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemovePropertiesResponse, error)

	// NonPersistentTopicsGetPropertiesWithResponse request
	NonPersistentTopicsGetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPropertiesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPropertiesResponse, error)

	// NonPersistentTopicsUpdatePropertiesWithBodyWithResponse request with any body
	NonPersistentTopicsUpdatePropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsUpdatePropertiesResponse, error)

	// NonPersistentTopicsRemovePublishRateWithResponse request
	NonPersistentTopicsRemovePublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePublishRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemovePublishRateResponse, error)

	// NonPersistentTopicsGetPublishRateWithResponse request
	NonPersistentTopicsGetPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPublishRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPublishRateResponse, error)

	// NonPersistentTopicsSetPublishRateWithBodyWithResponse request with any body
	NonPersistentTopicsSetPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetPublishRateResponse, error)

	// NonPersistentTopicsRemoveReplicationClustersWithResponse request
	NonPersistentTopicsRemoveReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveReplicationClustersResponse, error)

	// NonPersistentTopicsGetReplicationClustersWithResponse request
	NonPersistentTopicsGetReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicationClustersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetReplicationClustersResponse, error)

	// NonPersistentTopicsSetReplicationClustersWithBodyWithResponse request with any body
	NonPersistentTopicsSetReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetReplicationClustersResponse, error)

	// NonPersistentTopicsRemoveReplicatorDispatchRateWithResponse request
	NonPersistentTopicsRemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveReplicatorDispatchRateResponse, error)

	// NonPersistentTopicsGetReplicatorDispatchRateWithResponse request
	NonPersistentTopicsGetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetReplicatorDispatchRateResponse, error)

	// NonPersistentTopicsSetReplicatorDispatchRateWithBodyWithResponse request with any body
	NonPersistentTopicsSetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetReplicatorDispatchRateResponse, error)

	// NonPersistentTopicsRemoveRetentionWithResponse request
	NonPersistentTopicsRemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveRetentionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveRetentionResponse, error)

	// NonPersistentTopicsGetRetentionWithResponse request
	NonPersistentTopicsGetRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetRetentionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetRetentionResponse, error)

	// NonPersistentTopicsSetRetentionWithBodyWithResponse request with any body
	NonPersistentTopicsSetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetRetentionResponse, error)

	// NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithBodyWithResponse request with any body
	NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse, error)

	// NonPersistentTopicsGetSchemaCompatibilityStrategyWithResponse request
	NonPersistentTopicsGetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSchemaCompatibilityStrategyResponse, error)

	// NonPersistentTopicsSetSchemaCompatibilityStrategyWithBodyWithResponse request with any body
	NonPersistentTopicsSetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSchemaCompatibilityStrategyResponse, error)

	// NonPersistentTopicsGetSchemaValidationEnforcedWithResponse request
	NonPersistentTopicsGetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSchemaValidationEnforcedResponse, error)

	// NonPersistentTopicsSetSchemaValidationEnforcedWithBodyWithResponse request with any body
	NonPersistentTopicsSetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSchemaValidationEnforcedResponse, error)

	// NonPersistentTopicsDeleteShadowTopicsWithResponse request
	NonPersistentTopicsDeleteShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteShadowTopicsResponse, error)

	// NonPersistentTopicsGetShadowTopicsWithResponse request
	NonPersistentTopicsGetShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetShadowTopicsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetShadowTopicsResponse, error)

	// NonPersistentTopicsSetShadowTopicsWithBodyWithResponse request with any body
	NonPersistentTopicsSetShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetShadowTopicsResponse, error)

	// NonPersistentTopicsGetStatsWithResponse request
	NonPersistentTopicsGetStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetStatsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetStatsResponse, error)

	// NonPersistentTopicsRemoveSubscribeRateWithBodyWithResponse request with any body
	NonPersistentTopicsRemoveSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSubscribeRateResponse, error)

	// NonPersistentTopicsGetSubscribeRateWithResponse request
	NonPersistentTopicsGetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscribeRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscribeRateResponse, error)

	// NonPersistentTopicsSetSubscribeRateWithBodyWithResponse request with any body
	NonPersistentTopicsSetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSubscribeRateResponse, error)

	// NonPersistentTopicsDeleteSubscriptionWithResponse request
	NonPersistentTopicsDeleteSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteSubscriptionResponse, error)

	// NonPersistentTopicsAnalyzeSubscriptionBacklogWithBodyWithResponse request with any body
	NonPersistentTopicsAnalyzeSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsAnalyzeSubscriptionBacklogResponse, error)

	// NonPersistentTopicsExpireTopicMessagesWithBodyWithResponse request with any body
	NonPersistentTopicsExpireTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsExpireTopicMessagesResponse, error)

	// NonPersistentTopicsExpireTopicMessagesExpireTimeWithResponse request
	NonPersistentTopicsExpireTopicMessagesExpireTimeWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireTopicMessagesExpireTimeParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsExpireTopicMessagesExpireTimeResponse, error)

	// NonPersistentTopicsPeekNthMessageWithResponse request
	NonPersistentTopicsPeekNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *NonPersistentTopicsPeekNthMessageParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsPeekNthMessageResponse, error)

	// NonPersistentTopicsGetSubscriptionPropertiesWithResponse request
	NonPersistentTopicsGetSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionPropertiesResponse, error)

	// NonPersistentTopicsUpdateSubscriptionPropertiesWithBodyWithResponse request with any body
	NonPersistentTopicsUpdateSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsUpdateSubscriptionPropertiesResponse, error)

	// NonPersistentTopicsGetReplicatedSubscriptionStatusWithResponse request
	NonPersistentTopicsGetReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetReplicatedSubscriptionStatusResponse, error)

	// NonPersistentTopicsSetReplicatedSubscriptionStatusWithBodyWithResponse request with any body
	NonPersistentTopicsSetReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetReplicatedSubscriptionStatusResponse, error)

	// NonPersistentTopicsResetCursorOnPositionWithBodyWithResponse request with any body
	NonPersistentTopicsResetCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsResetCursorOnPositionResponse, error)

	// NonPersistentTopicsResetCursorWithResponse request
	NonPersistentTopicsResetCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *NonPersistentTopicsResetCursorParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsResetCursorResponse, error)

	// NonPersistentTopicsSkipMessagesWithResponse request
	NonPersistentTopicsSkipMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *NonPersistentTopicsSkipMessagesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSkipMessagesResponse, error)

	// NonPersistentTopicsSkipAllMessagesWithResponse request
	NonPersistentTopicsSkipAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSkipAllMessagesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSkipAllMessagesResponse, error)

	// NonPersistentTopicsCreateSubscriptionWithBodyWithResponse request with any body
	NonPersistentTopicsCreateSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *NonPersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCreateSubscriptionResponse, error)

	// NonPersistentTopicsRemoveSubscriptionDispatchRateWithResponse request
	NonPersistentTopicsRemoveSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSubscriptionDispatchRateResponse, error)

	// NonPersistentTopicsGetSubscriptionDispatchRateWithResponse request
	NonPersistentTopicsGetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionDispatchRateResponse, error)

	// NonPersistentTopicsSetSubscriptionDispatchRateWithBodyWithResponse request with any body
	NonPersistentTopicsSetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSubscriptionDispatchRateResponse, error)

	// NonPersistentTopicsRemoveSubscriptionTypesEnabledWithResponse request
	NonPersistentTopicsRemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSubscriptionTypesEnabledResponse, error)

	// NonPersistentTopicsGetSubscriptionTypesEnabledWithResponse request
	NonPersistentTopicsGetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionTypesEnabledResponse, error)

	// NonPersistentTopicsSetSubscriptionTypesEnabledWithBodyWithResponse request with any body
	NonPersistentTopicsSetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSubscriptionTypesEnabledResponse, error)

	// NonPersistentTopicsGetSubscriptionsWithResponse request
	NonPersistentTopicsGetSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionsResponse, error)

	// NonPersistentTopicsTerminateWithResponse request
	NonPersistentTopicsTerminateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTerminateResponse, error)

	// NonPersistentTopicsTerminatePartitionedTopicWithResponse request
	NonPersistentTopicsTerminatePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTerminatePartitionedTopicResponse, error)

	// NonPersistentTopicsTrimTopicWithResponse request
	NonPersistentTopicsTrimTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTrimTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTrimTopicResponse, error)

	// NonPersistentTopicsTruncateTopicWithResponse request
	NonPersistentTopicsTruncateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTruncateTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTruncateTopicResponse, error)

	// NonPersistentTopicsUnloadTopicWithResponse request
	NonPersistentTopicsUnloadTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUnloadTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsUnloadTopicResponse, error)

	// NonPersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse request
	NonPersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsRemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse, error)

	// NonPersistentTopicsGetSubscriptionLevelDispatchRateWithResponse request
	NonPersistentTopicsGetSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionLevelDispatchRateResponse, error)

	// NonPersistentTopicsSetSubscriptionLevelDispatchRateWithBodyWithResponse request with any body
	NonPersistentTopicsSetSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSubscriptionLevelDispatchRateResponse, error)

	// PersistentTopicsGetListWithResponse request
	PersistentTopicsGetListWithResponse(ctx context.Context, tenant string, namespace string, params *PersistentTopicsGetListParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetListResponse, error)

	// PersistentTopicsGetPartitionedTopicListWithResponse request
	PersistentTopicsGetPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *PersistentTopicsGetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPartitionedTopicListResponse, error)

	// PersistentTopicsDeleteTopicWithResponse request
	PersistentTopicsDeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteTopicResponse, error)

	// PersistentTopicsCreateNonPartitionedTopicWithBodyWithResponse request with any body
	PersistentTopicsCreateNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsCreateNonPartitionedTopicResponse, error)

	// PersistentTopicsExpireMessagesForAllSubscriptionsWithResponse request
	PersistentTopicsExpireMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *PersistentTopicsExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsExpireMessagesForAllSubscriptionsResponse, error)

	// PersistentTopicsRemoveAutoSubscriptionCreationWithResponse request
	PersistentTopicsRemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveAutoSubscriptionCreationResponse, error)

	// PersistentTopicsGetAutoSubscriptionCreationWithResponse request
	PersistentTopicsGetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetAutoSubscriptionCreationResponse, error)

	// PersistentTopicsSetAutoSubscriptionCreationWithBodyWithResponse request with any body
	PersistentTopicsSetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetAutoSubscriptionCreationResponse, error)

	// PersistentTopicsGetBacklogWithResponse request
	PersistentTopicsGetBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetBacklogResponse, error)

	// PersistentTopicsRemoveBacklogQuotaWithResponse request
	PersistentTopicsRemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveBacklogQuotaResponse, error)

	// PersistentTopicsSetBacklogQuotaWithBodyWithResponse request with any body
	PersistentTopicsSetBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetBacklogQuotaResponse, error)

	// PersistentTopicsGetBacklogQuotaMapWithResponse request
	PersistentTopicsGetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetBacklogQuotaMapResponse, error)

	// PersistentTopicsGetBacklogSizeByMessageIdWithResponse request
	PersistentTopicsGetBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetBacklogSizeByMessageIdResponse, error)

	// PersistentTopicsCompactionStatusWithResponse request
	PersistentTopicsCompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCompactionStatusParams, reqEditors ...RequestEditorFn) (*PersistentTopicsCompactionStatusResponse, error)

	// PersistentTopicsCompactWithResponse request
	PersistentTopicsCompactWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCompactParams, reqEditors ...RequestEditorFn) (*PersistentTopicsCompactResponse, error)

	// PersistentTopicsRemoveCompactionThresholdWithResponse request
	PersistentTopicsRemoveCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveCompactionThresholdResponse, error)

	// PersistentTopicsGetCompactionThresholdWithResponse request
	PersistentTopicsGetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetCompactionThresholdResponse, error)

	// PersistentTopicsSetCompactionThresholdWithBodyWithResponse request with any body
	PersistentTopicsSetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetCompactionThresholdResponse, error)

	// PersistentTopicsCreateMissedPartitionsWithResponse request
	PersistentTopicsCreateMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*PersistentTopicsCreateMissedPartitionsResponse, error)

	// PersistentTopicsRemoveDeduplicationWithResponse request
	PersistentTopicsRemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveDeduplicationResponse, error)

	// PersistentTopicsGetDeduplicationWithResponse request
	PersistentTopicsGetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetDeduplicationResponse, error)

	// PersistentTopicsSetDeduplicationWithBodyWithResponse request with any body
	PersistentTopicsSetDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetDeduplicationResponse, error)

	// PersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse request
	PersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteDeduplicationSnapshotIntervalResponse, error)

	// PersistentTopicsGetDeduplicationSnapshotIntervalWithResponse request
	PersistentTopicsGetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetDeduplicationSnapshotIntervalResponse, error)

	// PersistentTopicsSetDeduplicationSnapshotIntervalWithBodyWithResponse request with any body
	PersistentTopicsSetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetDeduplicationSnapshotIntervalResponse, error)

	// PersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse request
	PersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteDelayedDeliveryPoliciesResponse, error)

	// PersistentTopicsGetDelayedDeliveryPoliciesWithResponse request
	PersistentTopicsGetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetDelayedDeliveryPoliciesResponse, error)

	// PersistentTopicsSetDelayedDeliveryPoliciesWithBodyWithResponse request with any body
	PersistentTopicsSetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetDelayedDeliveryPoliciesResponse, error)

	// PersistentTopicsRemoveDispatchRateWithResponse request
	PersistentTopicsRemoveDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveDispatchRateResponse, error)

	// PersistentTopicsGetDispatchRateWithResponse request
	PersistentTopicsGetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetDispatchRateResponse, error)

	// PersistentTopicsSetDispatchRateWithBodyWithResponse request with any body
	PersistentTopicsSetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetDispatchRateResponse, error)

	// PersistentTopicsRemoveEntryFiltersWithResponse request
	PersistentTopicsRemoveEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveEntryFiltersResponse, error)

	// PersistentTopicsGetEntryFiltersWithResponse request
	PersistentTopicsGetEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetEntryFiltersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetEntryFiltersResponse, error)

	// PersistentTopicsSetEntryFiltersWithBodyWithResponse request with any body
	PersistentTopicsSetEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetEntryFiltersResponse, error)

	// PersistentTopicsExamineMessageWithResponse request
	PersistentTopicsExamineMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsExamineMessageParams, reqEditors ...RequestEditorFn) (*PersistentTopicsExamineMessageResponse, error)

	// PersistentTopicsDeleteInactiveTopicPoliciesWithResponse request
	PersistentTopicsDeleteInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteInactiveTopicPoliciesResponse, error)

	// PersistentTopicsGetInactiveTopicPoliciesWithResponse request
	PersistentTopicsGetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetInactiveTopicPoliciesResponse, error)

	// PersistentTopicsSetInactiveTopicPoliciesWithBodyWithResponse request with any body
	PersistentTopicsSetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetInactiveTopicPoliciesResponse, error)

	// PersistentTopicsGetManagedLedgerInfoWithResponse request
	PersistentTopicsGetManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetManagedLedgerInfoResponse, error)

	// PersistentTopicsGetInternalStatsWithResponse request
	PersistentTopicsGetInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetInternalStatsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetInternalStatsResponse, error)

	// PersistentTopicsGetLastMessageIdWithResponse request
	PersistentTopicsGetLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetLastMessageIdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetLastMessageIdResponse, error)

	// PersistentTopicsGetMessageByIdWithResponse request
	PersistentTopicsGetMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *PersistentTopicsGetMessageByIdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMessageByIdResponse, error)

	// PersistentTopicsRemoveMaxConsumersWithResponse request
	PersistentTopicsRemoveMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxConsumersResponse, error)

	// PersistentTopicsGetMaxConsumersWithResponse request
	PersistentTopicsGetMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxConsumersResponse, error)

	// PersistentTopicsSetMaxConsumersWithBodyWithResponse request with any body
	PersistentTopicsSetMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxConsumersResponse, error)

	// PersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse request
	PersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxConsumersPerSubscriptionResponse, error)

	// PersistentTopicsGetMaxConsumersPerSubscriptionWithResponse request
	PersistentTopicsGetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxConsumersPerSubscriptionResponse, error)

	// PersistentTopicsSetMaxConsumersPerSubscriptionWithBodyWithResponse request with any body
	PersistentTopicsSetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxConsumersPerSubscriptionResponse, error)

	// PersistentTopicsRemoveMaxMessageSizeWithResponse request
	PersistentTopicsRemoveMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxMessageSizeResponse, error)

	// PersistentTopicsGetMaxMessageSizeWithResponse request
	PersistentTopicsGetMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxMessageSizeResponse, error)

	// PersistentTopicsSetMaxMessageSizeWithBodyWithResponse request with any body
	PersistentTopicsSetMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxMessageSizeResponse, error)

	// PersistentTopicsRemoveMaxProducersWithResponse request
	PersistentTopicsRemoveMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxProducersResponse, error)

	// PersistentTopicsGetMaxProducersWithResponse request
	PersistentTopicsGetMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxProducersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxProducersResponse, error)

	// PersistentTopicsSetMaxProducersWithBodyWithResponse request with any body
	PersistentTopicsSetMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxProducersResponse, error)

	// PersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse request
	PersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxSubscriptionsPerTopicResponse, error)

	// PersistentTopicsGetMaxSubscriptionsPerTopicWithResponse request
	PersistentTopicsGetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxSubscriptionsPerTopicResponse, error)

	// PersistentTopicsSetMaxSubscriptionsPerTopicWithBodyWithResponse request with any body
	PersistentTopicsSetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxSubscriptionsPerTopicResponse, error)

	// PersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse request
	PersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse, error)

	// PersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse request
	PersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxUnackedMessagesOnConsumerResponse, error)

	// PersistentTopicsSetMaxUnackedMessagesOnConsumerWithBodyWithResponse request with any body
	PersistentTopicsSetMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxUnackedMessagesOnConsumerResponse, error)

	// PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse request
	PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse, error)

	// PersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse request
	PersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse, error)

	// PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse request with any body
	PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse, error)

	// PersistentTopicsRemoveMessageTTLWithResponse request
	PersistentTopicsRemoveMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMessageTTLResponse, error)

	// PersistentTopicsGetMessageTTLWithResponse request
	PersistentTopicsGetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMessageTTLParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMessageTTLResponse, error)

	// PersistentTopicsSetMessageTTLWithResponse request
	PersistentTopicsSetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMessageTTLParams, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMessageTTLResponse, error)

	// PersistentTopicsGetMessageIdByTimestampWithResponse request
	PersistentTopicsGetMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *PersistentTopicsGetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMessageIdByTimestampResponse, error)

	// PersistentTopicsOffloadStatusWithResponse request
	PersistentTopicsOffloadStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsOffloadStatusParams, reqEditors ...RequestEditorFn) (*PersistentTopicsOffloadStatusResponse, error)

	// PersistentTopicsTriggerOffloadWithResponse request
	PersistentTopicsTriggerOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTriggerOffloadParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTriggerOffloadResponse, error)

	// PersistentTopicsRemoveOffloadPoliciesWithResponse request
	PersistentTopicsRemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveOffloadPoliciesResponse, error)

	// PersistentTopicsGetOffloadPoliciesWithResponse request
	PersistentTopicsGetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetOffloadPoliciesResponse, error)

	// PersistentTopicsSetOffloadPoliciesWithBodyWithResponse request with any body
	PersistentTopicsSetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetOffloadPoliciesResponse, error)

	// PersistentTopicsGetPartitionedStatsInternalWithResponse request
	PersistentTopicsGetPartitionedStatsInternalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsInternalParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPartitionedStatsInternalResponse, error)

	// PersistentTopicsGetPartitionedStatsWithResponse request
	PersistentTopicsGetPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPartitionedStatsResponse, error)

	// PersistentTopicsDeletePartitionedTopicWithResponse request
	PersistentTopicsDeletePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeletePartitionedTopicResponse, error)

	// PersistentTopicsGetPartitionedMetadataWithResponse request
	PersistentTopicsGetPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPartitionedMetadataResponse, error)

	// PersistentTopicsUpdatePartitionedTopicWithBodyWithResponse request with any body
	PersistentTopicsUpdatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsUpdatePartitionedTopicResponse, error)

	// PersistentTopicsCreatePartitionedTopicWithBodyWithResponse request with any body
	PersistentTopicsCreatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsCreatePartitionedTopicResponse, error)

	// PersistentTopicsGetPermissionsOnTopicWithResponse request
	PersistentTopicsGetPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPermissionsOnTopicResponse, error)

	// PersistentTopicsRevokePermissionsOnTopicWithResponse request
	PersistentTopicsRevokePermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*PersistentTopicsRevokePermissionsOnTopicResponse, error)

	// PersistentTopicsGrantPermissionsOnTopicWithBodyWithResponse request with any body
	PersistentTopicsGrantPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsGrantPermissionsOnTopicResponse, error)

	// PersistentTopicsRemovePersistenceWithResponse request
	PersistentTopicsRemovePersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePersistenceParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemovePersistenceResponse, error)

	// PersistentTopicsGetPersistenceWithResponse request
	PersistentTopicsGetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPersistenceParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPersistenceResponse, error)

	// PersistentTopicsSetPersistenceWithBodyWithResponse request with any body
	PersistentTopicsSetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetPersistenceResponse, error)

	// PersistentTopicsRemovePropertiesWithResponse request
	PersistentTopicsRemovePropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePropertiesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemovePropertiesResponse, error)

	// PersistentTopicsGetPropertiesWithResponse request
	PersistentTopicsGetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPropertiesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPropertiesResponse, error)

	// PersistentTopicsUpdatePropertiesWithBodyWithResponse request with any body
	PersistentTopicsUpdatePropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsUpdatePropertiesResponse, error)

	// PersistentTopicsRemovePublishRateWithResponse request
	PersistentTopicsRemovePublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePublishRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemovePublishRateResponse, error)

	// PersistentTopicsGetPublishRateWithResponse request
	PersistentTopicsGetPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPublishRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPublishRateResponse, error)

	// PersistentTopicsSetPublishRateWithBodyWithResponse request with any body
	PersistentTopicsSetPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetPublishRateResponse, error)

	// PersistentTopicsRemoveReplicationClustersWithResponse request
	PersistentTopicsRemoveReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveReplicationClustersResponse, error)

	// PersistentTopicsGetReplicationClustersWithResponse request
	PersistentTopicsGetReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicationClustersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetReplicationClustersResponse, error)

	// PersistentTopicsSetReplicationClustersWithBodyWithResponse request with any body
	PersistentTopicsSetReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetReplicationClustersResponse, error)

	// PersistentTopicsRemoveReplicatorDispatchRateWithResponse request
	PersistentTopicsRemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveReplicatorDispatchRateResponse, error)

	// PersistentTopicsGetReplicatorDispatchRateWithResponse request
	PersistentTopicsGetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetReplicatorDispatchRateResponse, error)

	// PersistentTopicsSetReplicatorDispatchRateWithBodyWithResponse request with any body
	PersistentTopicsSetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetReplicatorDispatchRateResponse, error)

	// PersistentTopicsRemoveRetentionWithResponse request
	PersistentTopicsRemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveRetentionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveRetentionResponse, error)

	// PersistentTopicsGetRetentionWithResponse request
	PersistentTopicsGetRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetRetentionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetRetentionResponse, error)

	// PersistentTopicsSetRetentionWithBodyWithResponse request with any body
	PersistentTopicsSetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetRetentionResponse, error)

	// PersistentTopicsRemoveSchemaCompatibilityStrategyWithBodyWithResponse request with any body
	PersistentTopicsRemoveSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSchemaCompatibilityStrategyResponse, error)

	// PersistentTopicsGetSchemaCompatibilityStrategyWithResponse request
	PersistentTopicsGetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSchemaCompatibilityStrategyResponse, error)

	// PersistentTopicsSetSchemaCompatibilityStrategyWithBodyWithResponse request with any body
	PersistentTopicsSetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSchemaCompatibilityStrategyResponse, error)

	// PersistentTopicsGetSchemaValidationEnforcedWithResponse request
	PersistentTopicsGetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSchemaValidationEnforcedResponse, error)

	// PersistentTopicsSetSchemaValidationEnforcedWithBodyWithResponse request with any body
	PersistentTopicsSetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSchemaValidationEnforcedResponse, error)

	// PersistentTopicsDeleteShadowTopicsWithResponse request
	PersistentTopicsDeleteShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteShadowTopicsResponse, error)

	// PersistentTopicsGetShadowTopicsWithResponse request
	PersistentTopicsGetShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetShadowTopicsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetShadowTopicsResponse, error)

	// PersistentTopicsSetShadowTopicsWithBodyWithResponse request with any body
	PersistentTopicsSetShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetShadowTopicsResponse, error)

	// PersistentTopicsGetStatsWithResponse request
	PersistentTopicsGetStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetStatsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetStatsResponse, error)

	// PersistentTopicsRemoveSubscribeRateWithBodyWithResponse request with any body
	PersistentTopicsRemoveSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSubscribeRateResponse, error)

	// PersistentTopicsGetSubscribeRateWithResponse request
	PersistentTopicsGetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscribeRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscribeRateResponse, error)

	// PersistentTopicsSetSubscribeRateWithBodyWithResponse request with any body
	PersistentTopicsSetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSubscribeRateResponse, error)

	// PersistentTopicsDeleteSubscriptionWithResponse request
	PersistentTopicsDeleteSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteSubscriptionResponse, error)

	// PersistentTopicsAnalyzeSubscriptionBacklogWithBodyWithResponse request with any body
	PersistentTopicsAnalyzeSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsAnalyzeSubscriptionBacklogResponse, error)

	// PersistentTopicsExpireTopicMessagesWithBodyWithResponse request with any body
	PersistentTopicsExpireTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsExpireTopicMessagesResponse, error)

	// PersistentTopicsExpireTopicMessagesExpireTimeWithResponse request
	PersistentTopicsExpireTopicMessagesExpireTimeWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *PersistentTopicsExpireTopicMessagesExpireTimeParams, reqEditors ...RequestEditorFn) (*PersistentTopicsExpireTopicMessagesExpireTimeResponse, error)

	// PersistentTopicsPeekNthMessageWithResponse request
	PersistentTopicsPeekNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PersistentTopicsPeekNthMessageParams, reqEditors ...RequestEditorFn) (*PersistentTopicsPeekNthMessageResponse, error)

	// PersistentTopicsGetSubscriptionPropertiesWithResponse request
	PersistentTopicsGetSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionPropertiesResponse, error)

	// PersistentTopicsUpdateSubscriptionPropertiesWithBodyWithResponse request with any body
	PersistentTopicsUpdateSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsUpdateSubscriptionPropertiesResponse, error)

	// PersistentTopicsGetReplicatedSubscriptionStatusWithResponse request
	PersistentTopicsGetReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetReplicatedSubscriptionStatusResponse, error)

	// PersistentTopicsSetReplicatedSubscriptionStatusWithBodyWithResponse request with any body
	PersistentTopicsSetReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetReplicatedSubscriptionStatusResponse, error)

	// PersistentTopicsResetCursorOnPositionWithBodyWithResponse request with any body
	PersistentTopicsResetCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsResetCursorOnPositionResponse, error)

	// PersistentTopicsResetCursorWithResponse request
	PersistentTopicsResetCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *PersistentTopicsResetCursorParams, reqEditors ...RequestEditorFn) (*PersistentTopicsResetCursorResponse, error)

	// PersistentTopicsSkipMessagesWithResponse request
	PersistentTopicsSkipMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *PersistentTopicsSkipMessagesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsSkipMessagesResponse, error)

	// PersistentTopicsSkipAllMessagesWithResponse request
	PersistentTopicsSkipAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSkipAllMessagesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsSkipAllMessagesResponse, error)

	// PersistentTopicsCreateSubscriptionWithBodyWithResponse request with any body
	PersistentTopicsCreateSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *PersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsCreateSubscriptionResponse, error)

	// PersistentTopicsRemoveSubscriptionDispatchRateWithResponse request
	PersistentTopicsRemoveSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSubscriptionDispatchRateResponse, error)

	// PersistentTopicsGetSubscriptionDispatchRateWithResponse request
	PersistentTopicsGetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionDispatchRateResponse, error)

	// PersistentTopicsSetSubscriptionDispatchRateWithBodyWithResponse request with any body
	PersistentTopicsSetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSubscriptionDispatchRateResponse, error)

	// PersistentTopicsRemoveSubscriptionTypesEnabledWithResponse request
	PersistentTopicsRemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSubscriptionTypesEnabledResponse, error)

	// PersistentTopicsGetSubscriptionTypesEnabledWithResponse request
	PersistentTopicsGetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionTypesEnabledResponse, error)

	// PersistentTopicsSetSubscriptionTypesEnabledWithBodyWithResponse request with any body
	PersistentTopicsSetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSubscriptionTypesEnabledResponse, error)

	// PersistentTopicsGetSubscriptionsWithResponse request
	PersistentTopicsGetSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionsResponse, error)

	// PersistentTopicsTerminateWithResponse request
	PersistentTopicsTerminateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTerminateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTerminateResponse, error)

	// PersistentTopicsTerminatePartitionedTopicWithResponse request
	PersistentTopicsTerminatePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTerminatePartitionedTopicResponse, error)

	// PersistentTopicsTrimTopicWithResponse request
	PersistentTopicsTrimTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTrimTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTrimTopicResponse, error)

	// PersistentTopicsTruncateTopicWithResponse request
	PersistentTopicsTruncateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTruncateTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTruncateTopicResponse, error)

	// PersistentTopicsUnloadTopicWithResponse request
	PersistentTopicsUnloadTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUnloadTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsUnloadTopicResponse, error)

	// PersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse request
	PersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsRemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSubscriptionLevelDispatchRateResponse, error)

	// PersistentTopicsGetSubscriptionLevelDispatchRateWithResponse request
	PersistentTopicsGetSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionLevelDispatchRateResponse, error)

	// PersistentTopicsSetSubscriptionLevelDispatchRateWithBodyWithResponse request with any body
	PersistentTopicsSetSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSubscriptionLevelDispatchRateResponse, error)

	// ResourceQuotasGetDefaultResourceQuotaWithResponse request
	ResourceQuotasGetDefaultResourceQuotaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResourceQuotasGetDefaultResourceQuotaResponse, error)

	// ResourceQuotasSetDefaultResourceQuotaWithBodyWithResponse request with any body
	ResourceQuotasSetDefaultResourceQuotaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResourceQuotasSetDefaultResourceQuotaResponse, error)

	ResourceQuotasSetDefaultResourceQuotaWithResponse(ctx context.Context, body ResourceQuotasSetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*ResourceQuotasSetDefaultResourceQuotaResponse, error)

	// ResourceQuotasRemoveNamespaceBundleResourceQuotaWithResponse request
	ResourceQuotasRemoveNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*ResourceQuotasRemoveNamespaceBundleResourceQuotaResponse, error)

	// ResourceQuotasGetNamespaceBundleResourceQuotaWithResponse request
	ResourceQuotasGetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*ResourceQuotasGetNamespaceBundleResourceQuotaResponse, error)

	// ResourceQuotasSetNamespaceBundleResourceQuotaWithBodyWithResponse request with any body
	ResourceQuotasSetNamespaceBundleResourceQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResourceQuotasSetNamespaceBundleResourceQuotaResponse, error)

	ResourceQuotasSetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, body ResourceQuotasSetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*ResourceQuotasSetNamespaceBundleResourceQuotaResponse, error)

	// ResourceGroupsGetResourceGroupsWithResponse request
	ResourceGroupsGetResourceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResourceGroupsGetResourceGroupsResponse, error)

	// ResourceGroupsDeleteResourceGroupWithResponse request
	ResourceGroupsDeleteResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*ResourceGroupsDeleteResourceGroupResponse, error)

	// ResourceGroupsGetResourceGroupWithResponse request
	ResourceGroupsGetResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*ResourceGroupsGetResourceGroupResponse, error)

	// ResourceGroupsCreateOrUpdateResourceGroupWithBodyWithResponse request with any body
	ResourceGroupsCreateOrUpdateResourceGroupWithBodyWithResponse(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResourceGroupsCreateOrUpdateResourceGroupResponse, error)

	ResourceGroupsCreateOrUpdateResourceGroupWithResponse(ctx context.Context, resourcegroup string, body ResourceGroupsCreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ResourceGroupsCreateOrUpdateResourceGroupResponse, error)

	// SchemasResourceTestCompatibilityWithBodyWithResponse request with any body
	SchemasResourceTestCompatibilityWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasResourceTestCompatibilityResponse, error)

	SchemasResourceTestCompatibilityWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, body SchemasResourceTestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasResourceTestCompatibilityResponse, error)

	// SchemasResourceDeleteSchemaWithResponse request
	SchemasResourceDeleteSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceDeleteSchemaParams, reqEditors ...RequestEditorFn) (*SchemasResourceDeleteSchemaResponse, error)

	// SchemasResourceGetSchemaWithResponse request
	SchemasResourceGetSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetSchemaParams, reqEditors ...RequestEditorFn) (*SchemasResourceGetSchemaResponse, error)

	// SchemasResourcePostSchemaWithBodyWithResponse request with any body
	SchemasResourcePostSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasResourcePostSchemaResponse, error)

	SchemasResourcePostSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, body SchemasResourcePostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasResourcePostSchemaResponse, error)

	// SchemasResourceGetSchemaByVersionWithResponse request
	SchemasResourceGetSchemaByVersionWithResponse(ctx context.Context, tenant string, namespace string, topic string, version string, params *SchemasResourceGetSchemaByVersionParams, reqEditors ...RequestEditorFn) (*SchemasResourceGetSchemaByVersionResponse, error)

	// SchemasResourceGetAllSchemasWithResponse request
	SchemasResourceGetAllSchemasWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetAllSchemasParams, reqEditors ...RequestEditorFn) (*SchemasResourceGetAllSchemasResponse, error)

	// SchemasResourceGetVersionBySchemaWithBodyWithResponse request with any body
	SchemasResourceGetVersionBySchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasResourceGetVersionBySchemaResponse, error)

	SchemasResourceGetVersionBySchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, body SchemasResourceGetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasResourceGetVersionBySchemaResponse, error)

	// TenantsBaseGetTenantsWithResponse request
	TenantsBaseGetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TenantsBaseGetTenantsResponse, error)

	// TenantsBaseDeleteTenantWithResponse request
	TenantsBaseDeleteTenantWithResponse(ctx context.Context, tenant string, params *TenantsBaseDeleteTenantParams, reqEditors ...RequestEditorFn) (*TenantsBaseDeleteTenantResponse, error)

	// TenantsBaseGetTenantAdminWithResponse request
	TenantsBaseGetTenantAdminWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*TenantsBaseGetTenantAdminResponse, error)

	// TenantsBaseUpdateTenantWithBodyWithResponse request with any body
	TenantsBaseUpdateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantsBaseUpdateTenantResponse, error)

	TenantsBaseUpdateTenantWithResponse(ctx context.Context, tenant string, body TenantsBaseUpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantsBaseUpdateTenantResponse, error)

	// TenantsBaseCreateTenantWithBodyWithResponse request with any body
	TenantsBaseCreateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantsBaseCreateTenantResponse, error)

	TenantsBaseCreateTenantWithResponse(ctx context.Context, tenant string, body TenantsBaseCreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantsBaseCreateTenantResponse, error)

	// WorkerStatsGetStatsWithResponse request
	WorkerStatsGetStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerStatsGetStatsResponse, error)

	// WorkerStatsGetMetricsWithResponse request
	WorkerStatsGetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerStatsGetMetricsResponse, error)

	// WorkerGetAssignmentsWithResponse request
	WorkerGetAssignmentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetAssignmentsResponse, error)

	// WorkerGetClusterWithResponse request
	WorkerGetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetClusterResponse, error)

	// WorkerGetClusterLeaderWithResponse request
	WorkerGetClusterLeaderWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetClusterLeaderResponse, error)

	// WorkerIsLeaderReadyWithResponse request
	WorkerIsLeaderReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerIsLeaderReadyResponse, error)

	// WorkerGetConnectorsListWithResponse request
	WorkerGetConnectorsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetConnectorsListResponse, error)

	// WorkerGetDrainStatusWithResponse request
	WorkerGetDrainStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetDrainStatusResponse, error)

	// WorkerDrainWithResponse request
	WorkerDrainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerDrainResponse, error)

	// WorkerGetDrainStatusFromLeaderWithResponse request
	WorkerGetDrainStatusFromLeaderWithResponse(ctx context.Context, params *WorkerGetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*WorkerGetDrainStatusFromLeaderResponse, error)

	// WorkerDrainAtLeaderWithResponse request
	WorkerDrainAtLeaderWithResponse(ctx context.Context, params *WorkerDrainAtLeaderParams, reqEditors ...RequestEditorFn) (*WorkerDrainAtLeaderResponse, error)

	// WorkerRebalanceWithResponse request
	WorkerRebalanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerRebalanceResponse, error)
}

type BookiesGetAllBookiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookiesClusterInfo
}

// Status returns HTTPResponse.Status
func (r BookiesGetAllBookiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BookiesGetAllBookiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BookiesGetBookiesRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]map[string]BookieInfo
}

// Status returns HTTPResponse.Status
func (r BookiesGetBookiesRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BookiesGetBookiesRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BookiesDeleteBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BookiesDeleteBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BookiesDeleteBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BookiesGetBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookieInfo
}

// Status returns HTTPResponse.Status
func (r BookiesGetBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BookiesGetBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BookiesUpdateBookieRackInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BookiesUpdateBookieRackInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BookiesUpdateBookieRackInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokerStatsBaseGetAllocatorStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllocatorStats
}

// Status returns HTTPResponse.Status
func (r BrokerStatsBaseGetAllocatorStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokerStatsBaseGetAllocatorStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokerStatsBaseGetPendingBookieOpsStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]PendingBookieOpsStats
}

// Status returns HTTPResponse.Status
func (r BrokerStatsBaseGetPendingBookieOpsStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokerStatsBaseGetPendingBookieOpsStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokerStatsGetBrokerResourceAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]ResourceUnit
}

// Status returns HTTPResponse.Status
func (r BrokerStatsGetBrokerResourceAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokerStatsGetBrokerResourceAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokerStatsBaseGetLoadReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoadReport
}

// Status returns HTTPResponse.Status
func (r BrokerStatsBaseGetLoadReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokerStatsBaseGetLoadReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokerStatsBaseGetMBeansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r BrokerStatsBaseGetMBeansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokerStatsBaseGetMBeansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokerStatsBaseGetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r BrokerStatsBaseGetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokerStatsBaseGetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokerStatsGetTopics2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OutputStream
}

// Status returns HTTPResponse.Status
func (r BrokerStatsGetTopics2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokerStatsGetTopics2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseGetActiveBrokersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r BrokersBaseGetActiveBrokersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseGetActiveBrokersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseBacklogQuotaCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseBacklogQuotaCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseBacklogQuotaCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseGetDynamicConfigurationNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseGetDynamicConfigurationNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseGetDynamicConfigurationNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseGetRuntimeConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseGetRuntimeConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseGetRuntimeConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseGetAllDynamicConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseGetAllDynamicConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseGetAllDynamicConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseDeleteDynamicConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseDeleteDynamicConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseDeleteDynamicConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseUpdateDynamicConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseUpdateDynamicConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseUpdateDynamicConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseHealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseHealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseHealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseGetInternalConfigurationDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InternalConfigurationData
}

// Status returns HTTPResponse.Status
func (r BrokersBaseGetInternalConfigurationDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseGetInternalConfigurationDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseGetLeaderBrokerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrokerInfo
}

// Status returns HTTPResponse.Status
func (r BrokersBaseGetLeaderBrokerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseGetLeaderBrokerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseIsReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseIsReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseIsReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseShutDownBrokerGracefullyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BrokersBaseShutDownBrokerGracefullyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseShutDownBrokerGracefullyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r BrokersBaseVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseGetOwnedNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]NamespaceOwnershipStatus
}

// Status returns HTTPResponse.Status
func (r BrokersBaseGetOwnedNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseGetOwnedNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BrokersBaseGetActiveBrokersByClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r BrokersBaseGetActiveBrokersByClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BrokersBaseGetActiveBrokersByClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseDeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseDeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseDeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterData
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseUpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseUpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseUpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseCreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseCreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseCreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetFailureDomainsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]FailureDomain
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetFailureDomainsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetFailureDomainsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseDeleteFailureDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseDeleteFailureDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseDeleteFailureDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FailureDomain
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseSetFailureDomainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseSetFailureDomainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseSetFailureDomainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseUpdateClusterMigrationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseUpdateClusterMigrationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseUpdateClusterMigrationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetNamespaceIsolationPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]NamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetNamespaceIsolationPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetNamespaceIsolationPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]BrokerNamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BrokerNamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseDeleteNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseDeleteNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseDeleteNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NamespaceIsolationData
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseSetNamespaceIsolationPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseSetNamespaceIsolationPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseSetNamespaceIsolationPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseGetPeerClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ClustersBaseGetPeerClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseGetPeerClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClustersBaseSetPeerClusterNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClustersBaseSetPeerClusterNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClustersBaseSetPeerClusterNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetAntiAffinityNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NamespacesGetAntiAffinityNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetAntiAffinityNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesDeleteBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesDeleteBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesDeleteBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BookieAffinityGroupData
}

// Status returns HTTPResponse.Status
func (r NamespacesGetBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetTenantNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NamespacesGetTenantNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetTenantNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesDeleteNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesDeleteNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesDeleteNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Policies
}

// Status returns HTTPResponse.Status
func (r NamespacesGetPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesCreateNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesCreateNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesCreateNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r NamespacesGetNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetNamespaceAntiAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetNamespaceAntiAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetNamespaceAntiAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetAutoTopicCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetAutoTopicCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetAutoTopicCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetBundlesDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetBundlesDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetBundlesDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesClearNamespaceBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesClearNamespaceBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesClearNamespaceBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesClearNamespaceBacklogForSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesClearNamespaceBacklogForSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesClearNamespaceBacklogForSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesDeleteCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesDeleteCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesDeleteCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesModifyDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesModifyDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesModifyDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesDeleteDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesDeleteDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesDeleteDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetEncryptionRequiredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetEncryptionRequiredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetEncryptionRequiredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesModifyEncryptionRequiredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesModifyEncryptionRequiredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesModifyEncryptionRequiredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveNamespaceEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveNamespaceEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveNamespaceEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetEntryFiltersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetEntryFiltersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetEntryFiltersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetEntryFiltersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetEntryFiltersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetEntryFiltersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetIsAllowAutoUpdateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetIsAllowAutoUpdateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetIsAllowAutoUpdateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetIsAllowAutoUpdateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetIsAllowAutoUpdateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetIsAllowAutoUpdateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetMaxConsumersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetMaxConsumersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetMaxConsumersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetMaxProducersPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetMaxProducersPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetMaxProducersPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveMaxTopicsPerNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveMaxTopicsPerNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveMaxTopicsPerNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetMaxTopicsPerNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetMaxTopicsPerNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetMaxTopicsPerNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetMaxTopicsPerNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetMaxTopicsPerNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetMaxTopicsPerNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveMaxUnackedmessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveMaxUnackedmessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveMaxUnackedmessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetMaxUnackedMessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetMaxUnackedMessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetMaxUnackedMessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetMaxUnackedMessagesPerConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetMaxUnackedMessagesPerConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetMaxUnackedMessagesPerConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetMaxUnackedmessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetMaxUnackedmessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetMaxUnackedmessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetMaxUnackedMessagesPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetMaxUnackedMessagesPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetMaxUnackedMessagesPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NamespacesGetNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetNamespaceMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetNamespaceMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetNamespaceMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesClearOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesClearOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesClearOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetOffloadDeletionLagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetOffloadDeletionLagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetOffloadDeletionLagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetOffloadThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetOffloadThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetOffloadThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetOffloadThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetOffloadThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetOffloadThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetOffloadThresholdInSecondsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetOffloadThresholdInSecondsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetOffloadThresholdInSecondsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetOffloadThresholdInSecondsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetOffloadThresholdInSecondsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetOffloadThresholdInSecondsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetPermissionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetPermissionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetPermissionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetPermissionOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetPermissionOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetPermissionOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRevokePermissionsOnNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRevokePermissionsOnNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRevokePermissionsOnNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGrantPermissionOnNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGrantPermissionOnNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGrantPermissionOnNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesDeletePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesDeletePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesDeletePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetBookieAffinityGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetBookieAffinityGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetBookieAffinityGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesClearPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesClearPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesClearPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemovePropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemovePropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemovePropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetPropertyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetPropertyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetPropertyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetNamespaceReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NamespacesGetNamespaceReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetNamespaceReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetNamespaceReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetNamespaceReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetNamespaceReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetNamespaceResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetNamespaceResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetNamespaceResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesScanOffloadedLedgersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesScanOffloadedLedgersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesScanOffloadedLedgersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r NamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetSchemaValidtionEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetSchemaValidtionEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetSchemaValidtionEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesDeleteSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesDeleteSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesDeleteSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetSubscriptionAuthModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetSubscriptionAuthModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetSubscriptionAuthModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetSubscriptionAuthModeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetSubscriptionAuthModeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetSubscriptionAuthModeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesDeleteSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesDeleteSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesDeleteSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetSubscriptionExpirationTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetSubscriptionExpirationTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetSubscriptionExpirationTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesRemoveSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesRemoveSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesRemoveSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NamespacesGetTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesUnloadNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesUnloadNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesUnloadNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesUnsubscribeNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesUnsubscribeNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesUnsubscribeNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesDeleteNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesDeleteNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesDeleteNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesClearNamespaceBundleBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesClearNamespaceBundleBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesClearNamespaceBundleBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesClearNamespaceBundleBacklogForSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesClearNamespaceBundleBacklogForSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesClearNamespaceBundleBacklogForSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesSplitNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesSplitNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesSplitNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesGetTopicHashPositionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesGetTopicHashPositionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesGetTopicHashPositionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesUnloadNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesUnloadNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesUnloadNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NamespacesUnsubscribeNamespaceBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NamespacesUnsubscribeNamespaceBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NamespacesUnsubscribeNamespaceBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetPartitionedTopicListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetPartitionedTopicListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetPartitionedTopicListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetListFromBundleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetListFromBundleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetListFromBundleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeleteTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeleteTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeleteTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsCreateNonPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsCreateNonPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsCreateNonPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsExpireMessagesForAllSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsExpireMessagesForAllSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsExpireMessagesForAllSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistentOfflineTopicStats
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]BacklogQuota
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetBacklogSizeByMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetBacklogSizeByMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetBacklogSizeByMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsCompactionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsCompactionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsCompactionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsCompactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsCompactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsCompactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsCreateMissedPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsCreateMissedPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsCreateMissedPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DelayedDeliveryPolicies
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsExamineMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsExamineMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsExamineMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeleteInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeleteInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeleteInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InactiveTopicPolicies
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetManagedLedgerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartitionedManagedLedgerInfo
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetManagedLedgerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetManagedLedgerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetInternalStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetInternalStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetInternalStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetLastMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetLastMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetLastMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMessageByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMessageByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMessageByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetMessageIdByTimestampResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetMessageIdByTimestampResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetMessageIdByTimestampResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsOffloadStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsOffloadStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsOffloadStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsTriggerOffloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsTriggerOffloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsTriggerOffloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetPartitionedStatsInternalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartitionedTopicInternalStats
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetPartitionedStatsInternalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetPartitionedStatsInternalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetPartitionedStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NonPersistentPartitionedTopicStatsImpl
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetPartitionedStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetPartitionedStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeletePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeletePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeletePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetPartitionedMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetPartitionedMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetPartitionedMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsUpdatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsUpdatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsUpdatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsCreatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsCreatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsCreatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRevokePermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRevokePermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRevokePermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGrantPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGrantPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGrantPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemovePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemovePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemovePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistencePolicies
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemovePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemovePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemovePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]string
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsUpdatePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsUpdatePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsUpdatePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemovePublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemovePublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemovePublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublishRate
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DispatchRate
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RetentionPolicies
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeleteShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeleteShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeleteShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistentTopicStats
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubscribeRate
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsDeleteSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsDeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsDeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsAnalyzeSubscriptionBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsAnalyzeSubscriptionBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsAnalyzeSubscriptionBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsExpireTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsExpireTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsExpireTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsExpireTopicMessagesExpireTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsExpireTopicMessagesExpireTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsExpireTopicMessagesExpireTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsPeekNthMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsPeekNthMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsPeekNthMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsUpdateSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsUpdateSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsUpdateSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]bool
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsResetCursorOnPositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsResetCursorOnPositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsResetCursorOnPositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsResetCursorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsResetCursorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsResetCursorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSkipMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSkipMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSkipMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSkipAllMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSkipAllMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSkipAllMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsCreateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsCreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsCreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DispatchRate
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsTerminateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsTerminateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsTerminateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsTerminatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsTerminatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsTerminatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsTrimTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsTrimTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsTrimTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsTruncateTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsTruncateTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsTruncateTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsUnloadTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsUnloadTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsUnloadTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsGetSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsGetSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsGetSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type NonPersistentTopicsSetSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r NonPersistentTopicsSetSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r NonPersistentTopicsSetSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetPartitionedTopicListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetPartitionedTopicListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetPartitionedTopicListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeleteTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeleteTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeleteTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsCreateNonPartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsCreateNonPartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsCreateNonPartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsExpireMessagesForAllSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsExpireMessagesForAllSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsExpireMessagesForAllSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetAutoSubscriptionCreationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetAutoSubscriptionCreationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetAutoSubscriptionCreationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistentOfflineTopicStats
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetBacklogQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetBacklogQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetBacklogQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetBacklogQuotaMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]BacklogQuota
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetBacklogQuotaMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetBacklogQuotaMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetBacklogSizeByMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetBacklogSizeByMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetBacklogSizeByMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsCompactionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsCompactionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsCompactionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsCompactResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsCompactResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsCompactResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int64
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetCompactionThresholdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetCompactionThresholdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetCompactionThresholdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsCreateMissedPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsCreateMissedPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsCreateMissedPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *bool
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetDeduplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetDeduplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetDeduplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeleteDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeleteDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeleteDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetDeduplicationSnapshotIntervalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetDeduplicationSnapshotIntervalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetDeduplicationSnapshotIntervalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeleteDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeleteDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeleteDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DelayedDeliveryPolicies
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetDelayedDeliveryPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetDelayedDeliveryPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetDelayedDeliveryPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetEntryFiltersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetEntryFiltersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetEntryFiltersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsExamineMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsExamineMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsExamineMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeleteInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeleteInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeleteInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InactiveTopicPolicies
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetInactiveTopicPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetInactiveTopicPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetInactiveTopicPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetManagedLedgerInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartitionedManagedLedgerInfo
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetManagedLedgerInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetManagedLedgerInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetInternalStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistentTopicInternalStats
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetInternalStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetInternalStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetLastMessageIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetLastMessageIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetLastMessageIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMessageByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMessageByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMessageByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetMaxConsumersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetMaxConsumersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetMaxConsumersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetMaxConsumersPerSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetMaxConsumersPerSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetMaxConsumersPerSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetMaxMessageSizeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetMaxMessageSizeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetMaxMessageSizeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetMaxProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetMaxProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetMaxProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetMaxSubscriptionsPerTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetMaxSubscriptionsPerTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetMaxSubscriptionsPerTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetMaxUnackedMessagesOnConsumerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetMaxUnackedMessagesOnConsumerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetMaxUnackedMessagesOnConsumerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int32
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetMessageTTLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetMessageTTLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetMessageTTLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetMessageIdByTimestampResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetMessageIdByTimestampResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetMessageIdByTimestampResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsOffloadStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsOffloadStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsOffloadStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsTriggerOffloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsTriggerOffloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsTriggerOffloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetOffloadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetOffloadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetOffloadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetPartitionedStatsInternalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartitionedTopicInternalStats
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetPartitionedStatsInternalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetPartitionedStatsInternalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetPartitionedStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartitionedTopicStatsImpl
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetPartitionedStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetPartitionedStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeletePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeletePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeletePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetPartitionedMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PartitionedTopicMetadata
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetPartitionedMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetPartitionedMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsUpdatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsUpdatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsUpdatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsCreatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsCreatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsCreatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRevokePermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRevokePermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRevokePermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGrantPermissionsOnTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGrantPermissionsOnTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGrantPermissionsOnTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemovePersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemovePersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemovePersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistencePolicies
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetPersistenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetPersistenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetPersistenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemovePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemovePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemovePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]string
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsUpdatePropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsUpdatePropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsUpdatePropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemovePublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemovePublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemovePublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PublishRate
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetPublishRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetPublishRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetPublishRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetReplicationClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetReplicationClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetReplicationClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DispatchRate
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetReplicatorDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetReplicatorDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetReplicatorDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RetentionPolicies
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetRetentionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetRetentionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetRetentionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetSchemaCompatibilityStrategyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetSchemaCompatibilityStrategyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetSchemaCompatibilityStrategyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetSchemaValidationEnforcedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetSchemaValidationEnforcedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetSchemaValidationEnforcedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeleteShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeleteShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeleteShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetShadowTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetShadowTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetShadowTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersistentTopicStats
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SubscribeRate
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetSubscribeRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetSubscribeRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetSubscribeRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsDeleteSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsDeleteSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsDeleteSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsAnalyzeSubscriptionBacklogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsAnalyzeSubscriptionBacklogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsAnalyzeSubscriptionBacklogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsExpireTopicMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsExpireTopicMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsExpireTopicMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsExpireTopicMessagesExpireTimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsExpireTopicMessagesExpireTimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsExpireTopicMessagesExpireTimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsPeekNthMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsPeekNthMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsPeekNthMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsUpdateSubscriptionPropertiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsUpdateSubscriptionPropertiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsUpdateSubscriptionPropertiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]bool
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetReplicatedSubscriptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetReplicatedSubscriptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetReplicatedSubscriptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsResetCursorOnPositionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsResetCursorOnPositionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsResetCursorOnPositionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsResetCursorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsResetCursorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsResetCursorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSkipMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSkipMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSkipMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSkipAllMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSkipAllMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSkipAllMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsCreateSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsCreateSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsCreateSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DispatchRate
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetSubscriptionDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetSubscriptionDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetSubscriptionDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetSubscriptionTypesEnabledResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetSubscriptionTypesEnabledResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetSubscriptionTypesEnabledResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsTerminateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsTerminateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsTerminateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsTerminatePartitionedTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsTerminatePartitionedTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsTerminatePartitionedTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsTrimTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsTrimTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsTrimTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsTruncateTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsTruncateTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsTruncateTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsUnloadTopicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsUnloadTopicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsUnloadTopicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsRemoveSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsRemoveSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsRemoveSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsGetSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsGetSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsGetSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PersistentTopicsSetSubscriptionLevelDispatchRateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PersistentTopicsSetSubscriptionLevelDispatchRateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PersistentTopicsSetSubscriptionLevelDispatchRateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceQuotasGetDefaultResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ResourceQuotasGetDefaultResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceQuotasGetDefaultResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceQuotasSetDefaultResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ResourceQuotasSetDefaultResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceQuotasSetDefaultResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceQuotasRemoveNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResourceQuotasRemoveNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceQuotasRemoveNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceQuotasGetNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResourceQuotasGetNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceQuotasGetNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceQuotasSetNamespaceBundleResourceQuotaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResourceQuotasSetNamespaceBundleResourceQuotaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceQuotasSetNamespaceBundleResourceQuotaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceGroupsGetResourceGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ResourceGroupsGetResourceGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceGroupsGetResourceGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceGroupsDeleteResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResourceGroupsDeleteResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceGroupsDeleteResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceGroupsGetResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResourceGroup
}

// Status returns HTTPResponse.Status
func (r ResourceGroupsGetResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceGroupsGetResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResourceGroupsCreateOrUpdateResourceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResourceGroupsCreateOrUpdateResourceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResourceGroupsCreateOrUpdateResourceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasResourceTestCompatibilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IsCompatibilityResponse
}

// Status returns HTTPResponse.Status
func (r SchemasResourceTestCompatibilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasResourceTestCompatibilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasResourceDeleteSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteSchemaResponse
}

// Status returns HTTPResponse.Status
func (r SchemasResourceDeleteSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasResourceDeleteSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasResourceGetSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSchemaResponse
}

// Status returns HTTPResponse.Status
func (r SchemasResourceGetSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasResourceGetSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasResourcePostSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PostSchemaResponse
}

// Status returns HTTPResponse.Status
func (r SchemasResourcePostSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasResourcePostSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasResourceGetSchemaByVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSchemaResponse
}

// Status returns HTTPResponse.Status
func (r SchemasResourceGetSchemaByVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasResourceGetSchemaByVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasResourceGetAllSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllVersionsSchemaResponse
}

// Status returns HTTPResponse.Status
func (r SchemasResourceGetAllSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasResourceGetAllSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SchemasResourceGetVersionBySchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LongSchemaVersion
}

// Status returns HTTPResponse.Status
func (r SchemasResourceGetVersionBySchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SchemasResourceGetVersionBySchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantsBaseGetTenantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r TenantsBaseGetTenantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantsBaseGetTenantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantsBaseDeleteTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TenantsBaseDeleteTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantsBaseDeleteTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantsBaseGetTenantAdminResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TenantInfo
}

// Status returns HTTPResponse.Status
func (r TenantsBaseGetTenantAdminResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantsBaseGetTenantAdminResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantsBaseUpdateTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TenantsBaseUpdateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantsBaseUpdateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TenantsBaseCreateTenantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TenantsBaseCreateTenantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TenantsBaseCreateTenantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerStatsGetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerFunctionInstanceStats
}

// Status returns HTTPResponse.Status
func (r WorkerStatsGetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerStatsGetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerStatsGetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Metrics
}

// Status returns HTTPResponse.Status
func (r WorkerStatsGetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerStatsGetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetAssignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r WorkerGetAssignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetAssignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]WorkerInfo
}

// Status returns HTTPResponse.Status
func (r WorkerGetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetClusterLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkerInfo
}

// Status returns HTTPResponse.Status
func (r WorkerGetClusterLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetClusterLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerIsLeaderReadyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WorkerIsLeaderReadyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerIsLeaderReadyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetConnectorsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r WorkerGetConnectorsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetConnectorsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetDrainStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WorkerGetDrainStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetDrainStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerDrainResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WorkerDrainResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerDrainResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerGetDrainStatusFromLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WorkerGetDrainStatusFromLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerGetDrainStatusFromLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerDrainAtLeaderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WorkerDrainAtLeaderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerDrainAtLeaderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WorkerRebalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r WorkerRebalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WorkerRebalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// BookiesGetAllBookiesWithResponse request returning *BookiesGetAllBookiesResponse
func (c *ClientWithResponses) BookiesGetAllBookiesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BookiesGetAllBookiesResponse, error) {
	rsp, err := c.BookiesGetAllBookies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBookiesGetAllBookiesResponse(rsp)
}

// BookiesGetBookiesRackInfoWithResponse request returning *BookiesGetBookiesRackInfoResponse
func (c *ClientWithResponses) BookiesGetBookiesRackInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BookiesGetBookiesRackInfoResponse, error) {
	rsp, err := c.BookiesGetBookiesRackInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBookiesGetBookiesRackInfoResponse(rsp)
}

// BookiesDeleteBookieRackInfoWithResponse request returning *BookiesDeleteBookieRackInfoResponse
func (c *ClientWithResponses) BookiesDeleteBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*BookiesDeleteBookieRackInfoResponse, error) {
	rsp, err := c.BookiesDeleteBookieRackInfo(ctx, bookie, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBookiesDeleteBookieRackInfoResponse(rsp)
}

// BookiesGetBookieRackInfoWithResponse request returning *BookiesGetBookieRackInfoResponse
func (c *ClientWithResponses) BookiesGetBookieRackInfoWithResponse(ctx context.Context, bookie string, reqEditors ...RequestEditorFn) (*BookiesGetBookieRackInfoResponse, error) {
	rsp, err := c.BookiesGetBookieRackInfo(ctx, bookie, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBookiesGetBookieRackInfoResponse(rsp)
}

// BookiesUpdateBookieRackInfoWithResponse request returning *BookiesUpdateBookieRackInfoResponse
func (c *ClientWithResponses) BookiesUpdateBookieRackInfoWithResponse(ctx context.Context, bookie string, params *BookiesUpdateBookieRackInfoParams, reqEditors ...RequestEditorFn) (*BookiesUpdateBookieRackInfoResponse, error) {
	rsp, err := c.BookiesUpdateBookieRackInfo(ctx, bookie, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBookiesUpdateBookieRackInfoResponse(rsp)
}

// BrokerStatsBaseGetAllocatorStatsWithResponse request returning *BrokerStatsBaseGetAllocatorStatsResponse
func (c *ClientWithResponses) BrokerStatsBaseGetAllocatorStatsWithResponse(ctx context.Context, allocator string, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetAllocatorStatsResponse, error) {
	rsp, err := c.BrokerStatsBaseGetAllocatorStats(ctx, allocator, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokerStatsBaseGetAllocatorStatsResponse(rsp)
}

// BrokerStatsBaseGetPendingBookieOpsStatsWithResponse request returning *BrokerStatsBaseGetPendingBookieOpsStatsResponse
func (c *ClientWithResponses) BrokerStatsBaseGetPendingBookieOpsStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetPendingBookieOpsStatsResponse, error) {
	rsp, err := c.BrokerStatsBaseGetPendingBookieOpsStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokerStatsBaseGetPendingBookieOpsStatsResponse(rsp)
}

// BrokerStatsGetBrokerResourceAvailabilityWithResponse request returning *BrokerStatsGetBrokerResourceAvailabilityResponse
func (c *ClientWithResponses) BrokerStatsGetBrokerResourceAvailabilityWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*BrokerStatsGetBrokerResourceAvailabilityResponse, error) {
	rsp, err := c.BrokerStatsGetBrokerResourceAvailability(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokerStatsGetBrokerResourceAvailabilityResponse(rsp)
}

// BrokerStatsBaseGetLoadReportWithResponse request returning *BrokerStatsBaseGetLoadReportResponse
func (c *ClientWithResponses) BrokerStatsBaseGetLoadReportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetLoadReportResponse, error) {
	rsp, err := c.BrokerStatsBaseGetLoadReport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokerStatsBaseGetLoadReportResponse(rsp)
}

// BrokerStatsBaseGetMBeansWithResponse request returning *BrokerStatsBaseGetMBeansResponse
func (c *ClientWithResponses) BrokerStatsBaseGetMBeansWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetMBeansResponse, error) {
	rsp, err := c.BrokerStatsBaseGetMBeans(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokerStatsBaseGetMBeansResponse(rsp)
}

// BrokerStatsBaseGetMetricsWithResponse request returning *BrokerStatsBaseGetMetricsResponse
func (c *ClientWithResponses) BrokerStatsBaseGetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsBaseGetMetricsResponse, error) {
	rsp, err := c.BrokerStatsBaseGetMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokerStatsBaseGetMetricsResponse(rsp)
}

// BrokerStatsGetTopics2WithResponse request returning *BrokerStatsGetTopics2Response
func (c *ClientWithResponses) BrokerStatsGetTopics2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokerStatsGetTopics2Response, error) {
	rsp, err := c.BrokerStatsGetTopics2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokerStatsGetTopics2Response(rsp)
}

// BrokersBaseGetActiveBrokersWithResponse request returning *BrokersBaseGetActiveBrokersResponse
func (c *ClientWithResponses) BrokersBaseGetActiveBrokersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetActiveBrokersResponse, error) {
	rsp, err := c.BrokersBaseGetActiveBrokers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseGetActiveBrokersResponse(rsp)
}

// BrokersBaseBacklogQuotaCheckWithResponse request returning *BrokersBaseBacklogQuotaCheckResponse
func (c *ClientWithResponses) BrokersBaseBacklogQuotaCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseBacklogQuotaCheckResponse, error) {
	rsp, err := c.BrokersBaseBacklogQuotaCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseBacklogQuotaCheckResponse(rsp)
}

// BrokersBaseGetDynamicConfigurationNameWithResponse request returning *BrokersBaseGetDynamicConfigurationNameResponse
func (c *ClientWithResponses) BrokersBaseGetDynamicConfigurationNameWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetDynamicConfigurationNameResponse, error) {
	rsp, err := c.BrokersBaseGetDynamicConfigurationName(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseGetDynamicConfigurationNameResponse(rsp)
}

// BrokersBaseGetRuntimeConfigurationWithResponse request returning *BrokersBaseGetRuntimeConfigurationResponse
func (c *ClientWithResponses) BrokersBaseGetRuntimeConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetRuntimeConfigurationResponse, error) {
	rsp, err := c.BrokersBaseGetRuntimeConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseGetRuntimeConfigurationResponse(rsp)
}

// BrokersBaseGetAllDynamicConfigurationsWithResponse request returning *BrokersBaseGetAllDynamicConfigurationsResponse
func (c *ClientWithResponses) BrokersBaseGetAllDynamicConfigurationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetAllDynamicConfigurationsResponse, error) {
	rsp, err := c.BrokersBaseGetAllDynamicConfigurations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseGetAllDynamicConfigurationsResponse(rsp)
}

// BrokersBaseDeleteDynamicConfigurationWithResponse request returning *BrokersBaseDeleteDynamicConfigurationResponse
func (c *ClientWithResponses) BrokersBaseDeleteDynamicConfigurationWithResponse(ctx context.Context, configName string, reqEditors ...RequestEditorFn) (*BrokersBaseDeleteDynamicConfigurationResponse, error) {
	rsp, err := c.BrokersBaseDeleteDynamicConfiguration(ctx, configName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseDeleteDynamicConfigurationResponse(rsp)
}

// BrokersBaseUpdateDynamicConfigurationWithResponse request returning *BrokersBaseUpdateDynamicConfigurationResponse
func (c *ClientWithResponses) BrokersBaseUpdateDynamicConfigurationWithResponse(ctx context.Context, configName string, configValue string, reqEditors ...RequestEditorFn) (*BrokersBaseUpdateDynamicConfigurationResponse, error) {
	rsp, err := c.BrokersBaseUpdateDynamicConfiguration(ctx, configName, configValue, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseUpdateDynamicConfigurationResponse(rsp)
}

// BrokersBaseHealthCheckWithResponse request returning *BrokersBaseHealthCheckResponse
func (c *ClientWithResponses) BrokersBaseHealthCheckWithResponse(ctx context.Context, params *BrokersBaseHealthCheckParams, reqEditors ...RequestEditorFn) (*BrokersBaseHealthCheckResponse, error) {
	rsp, err := c.BrokersBaseHealthCheck(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseHealthCheckResponse(rsp)
}

// BrokersBaseGetInternalConfigurationDataWithResponse request returning *BrokersBaseGetInternalConfigurationDataResponse
func (c *ClientWithResponses) BrokersBaseGetInternalConfigurationDataWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetInternalConfigurationDataResponse, error) {
	rsp, err := c.BrokersBaseGetInternalConfigurationData(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseGetInternalConfigurationDataResponse(rsp)
}

// BrokersBaseGetLeaderBrokerWithResponse request returning *BrokersBaseGetLeaderBrokerResponse
func (c *ClientWithResponses) BrokersBaseGetLeaderBrokerWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseGetLeaderBrokerResponse, error) {
	rsp, err := c.BrokersBaseGetLeaderBroker(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseGetLeaderBrokerResponse(rsp)
}

// BrokersBaseIsReadyWithResponse request returning *BrokersBaseIsReadyResponse
func (c *ClientWithResponses) BrokersBaseIsReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseIsReadyResponse, error) {
	rsp, err := c.BrokersBaseIsReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseIsReadyResponse(rsp)
}

// BrokersBaseShutDownBrokerGracefullyWithResponse request returning *BrokersBaseShutDownBrokerGracefullyResponse
func (c *ClientWithResponses) BrokersBaseShutDownBrokerGracefullyWithResponse(ctx context.Context, params *BrokersBaseShutDownBrokerGracefullyParams, reqEditors ...RequestEditorFn) (*BrokersBaseShutDownBrokerGracefullyResponse, error) {
	rsp, err := c.BrokersBaseShutDownBrokerGracefully(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseShutDownBrokerGracefullyResponse(rsp)
}

// BrokersBaseVersionWithResponse request returning *BrokersBaseVersionResponse
func (c *ClientWithResponses) BrokersBaseVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*BrokersBaseVersionResponse, error) {
	rsp, err := c.BrokersBaseVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseVersionResponse(rsp)
}

// BrokersBaseGetOwnedNamespacesWithResponse request returning *BrokersBaseGetOwnedNamespacesResponse
func (c *ClientWithResponses) BrokersBaseGetOwnedNamespacesWithResponse(ctx context.Context, clusterName string, brokerWebserviceurl string, reqEditors ...RequestEditorFn) (*BrokersBaseGetOwnedNamespacesResponse, error) {
	rsp, err := c.BrokersBaseGetOwnedNamespaces(ctx, clusterName, brokerWebserviceurl, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseGetOwnedNamespacesResponse(rsp)
}

// BrokersBaseGetActiveBrokersByClusterWithResponse request returning *BrokersBaseGetActiveBrokersByClusterResponse
func (c *ClientWithResponses) BrokersBaseGetActiveBrokersByClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*BrokersBaseGetActiveBrokersByClusterResponse, error) {
	rsp, err := c.BrokersBaseGetActiveBrokersByCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBrokersBaseGetActiveBrokersByClusterResponse(rsp)
}

// ClustersBaseGetClustersWithResponse request returning *ClustersBaseGetClustersResponse
func (c *ClientWithResponses) ClustersBaseGetClustersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClustersBaseGetClustersResponse, error) {
	rsp, err := c.ClustersBaseGetClusters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetClustersResponse(rsp)
}

// ClustersBaseDeleteClusterWithResponse request returning *ClustersBaseDeleteClusterResponse
func (c *ClientWithResponses) ClustersBaseDeleteClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseDeleteClusterResponse, error) {
	rsp, err := c.ClustersBaseDeleteCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseDeleteClusterResponse(rsp)
}

// ClustersBaseGetClusterWithResponse request returning *ClustersBaseGetClusterResponse
func (c *ClientWithResponses) ClustersBaseGetClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetClusterResponse, error) {
	rsp, err := c.ClustersBaseGetCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetClusterResponse(rsp)
}

// ClustersBaseUpdateClusterWithBodyWithResponse request with arbitrary body returning *ClustersBaseUpdateClusterResponse
func (c *ClientWithResponses) ClustersBaseUpdateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseUpdateClusterResponse, error) {
	rsp, err := c.ClustersBaseUpdateClusterWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseUpdateClusterResponse(rsp)
}

// ClustersBaseCreateClusterWithBodyWithResponse request with arbitrary body returning *ClustersBaseCreateClusterResponse
func (c *ClientWithResponses) ClustersBaseCreateClusterWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseCreateClusterResponse, error) {
	rsp, err := c.ClustersBaseCreateClusterWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseCreateClusterResponse(rsp)
}

// ClustersBaseGetFailureDomainsWithResponse request returning *ClustersBaseGetFailureDomainsResponse
func (c *ClientWithResponses) ClustersBaseGetFailureDomainsWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetFailureDomainsResponse, error) {
	rsp, err := c.ClustersBaseGetFailureDomains(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetFailureDomainsResponse(rsp)
}

// ClustersBaseDeleteFailureDomainWithResponse request returning *ClustersBaseDeleteFailureDomainResponse
func (c *ClientWithResponses) ClustersBaseDeleteFailureDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*ClustersBaseDeleteFailureDomainResponse, error) {
	rsp, err := c.ClustersBaseDeleteFailureDomain(ctx, cluster, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseDeleteFailureDomainResponse(rsp)
}

// ClustersBaseGetDomainWithResponse request returning *ClustersBaseGetDomainResponse
func (c *ClientWithResponses) ClustersBaseGetDomainWithResponse(ctx context.Context, cluster string, domainName string, reqEditors ...RequestEditorFn) (*ClustersBaseGetDomainResponse, error) {
	rsp, err := c.ClustersBaseGetDomain(ctx, cluster, domainName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetDomainResponse(rsp)
}

// ClustersBaseSetFailureDomainWithBodyWithResponse request with arbitrary body returning *ClustersBaseSetFailureDomainResponse
func (c *ClientWithResponses) ClustersBaseSetFailureDomainWithBodyWithResponse(ctx context.Context, cluster string, domainName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseSetFailureDomainResponse, error) {
	rsp, err := c.ClustersBaseSetFailureDomainWithBody(ctx, cluster, domainName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseSetFailureDomainResponse(rsp)
}

// ClustersBaseUpdateClusterMigrationWithBodyWithResponse request with arbitrary body returning *ClustersBaseUpdateClusterMigrationResponse
func (c *ClientWithResponses) ClustersBaseUpdateClusterMigrationWithBodyWithResponse(ctx context.Context, cluster string, params *ClustersBaseUpdateClusterMigrationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseUpdateClusterMigrationResponse, error) {
	rsp, err := c.ClustersBaseUpdateClusterMigrationWithBody(ctx, cluster, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseUpdateClusterMigrationResponse(rsp)
}

// ClustersBaseGetNamespaceIsolationPoliciesWithResponse request returning *ClustersBaseGetNamespaceIsolationPoliciesResponse
func (c *ClientWithResponses) ClustersBaseGetNamespaceIsolationPoliciesWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetNamespaceIsolationPoliciesResponse, error) {
	rsp, err := c.ClustersBaseGetNamespaceIsolationPolicies(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetNamespaceIsolationPoliciesResponse(rsp)
}

// ClustersBaseGetBrokersWithNamespaceIsolationPolicyWithResponse request returning *ClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) ClustersBaseGetBrokersWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.ClustersBaseGetBrokersWithNamespaceIsolationPolicy(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse(rsp)
}

// ClustersBaseGetBrokerWithNamespaceIsolationPolicyWithResponse request returning *ClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) ClustersBaseGetBrokerWithNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, broker string, reqEditors ...RequestEditorFn) (*ClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.ClustersBaseGetBrokerWithNamespaceIsolationPolicy(ctx, cluster, broker, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse(rsp)
}

// ClustersBaseDeleteNamespaceIsolationPolicyWithResponse request returning *ClustersBaseDeleteNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) ClustersBaseDeleteNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*ClustersBaseDeleteNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.ClustersBaseDeleteNamespaceIsolationPolicy(ctx, cluster, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseDeleteNamespaceIsolationPolicyResponse(rsp)
}

// ClustersBaseGetNamespaceIsolationPolicyWithResponse request returning *ClustersBaseGetNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) ClustersBaseGetNamespaceIsolationPolicyWithResponse(ctx context.Context, cluster string, policyName string, reqEditors ...RequestEditorFn) (*ClustersBaseGetNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.ClustersBaseGetNamespaceIsolationPolicy(ctx, cluster, policyName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetNamespaceIsolationPolicyResponse(rsp)
}

// ClustersBaseSetNamespaceIsolationPolicyWithBodyWithResponse request with arbitrary body returning *ClustersBaseSetNamespaceIsolationPolicyResponse
func (c *ClientWithResponses) ClustersBaseSetNamespaceIsolationPolicyWithBodyWithResponse(ctx context.Context, cluster string, policyName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseSetNamespaceIsolationPolicyResponse, error) {
	rsp, err := c.ClustersBaseSetNamespaceIsolationPolicyWithBody(ctx, cluster, policyName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseSetNamespaceIsolationPolicyResponse(rsp)
}

// ClustersBaseGetPeerClusterWithResponse request returning *ClustersBaseGetPeerClusterResponse
func (c *ClientWithResponses) ClustersBaseGetPeerClusterWithResponse(ctx context.Context, cluster string, reqEditors ...RequestEditorFn) (*ClustersBaseGetPeerClusterResponse, error) {
	rsp, err := c.ClustersBaseGetPeerCluster(ctx, cluster, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseGetPeerClusterResponse(rsp)
}

// ClustersBaseSetPeerClusterNamesWithBodyWithResponse request with arbitrary body returning *ClustersBaseSetPeerClusterNamesResponse
func (c *ClientWithResponses) ClustersBaseSetPeerClusterNamesWithBodyWithResponse(ctx context.Context, cluster string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClustersBaseSetPeerClusterNamesResponse, error) {
	rsp, err := c.ClustersBaseSetPeerClusterNamesWithBody(ctx, cluster, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClustersBaseSetPeerClusterNamesResponse(rsp)
}

// NamespacesGetAntiAffinityNamespacesWithResponse request returning *NamespacesGetAntiAffinityNamespacesResponse
func (c *ClientWithResponses) NamespacesGetAntiAffinityNamespacesWithResponse(ctx context.Context, cluster string, group string, params *NamespacesGetAntiAffinityNamespacesParams, reqEditors ...RequestEditorFn) (*NamespacesGetAntiAffinityNamespacesResponse, error) {
	rsp, err := c.NamespacesGetAntiAffinityNamespaces(ctx, cluster, group, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetAntiAffinityNamespacesResponse(rsp)
}

// NamespacesDeleteBookieAffinityGroupWithResponse request returning *NamespacesDeleteBookieAffinityGroupResponse
func (c *ClientWithResponses) NamespacesDeleteBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteBookieAffinityGroupResponse, error) {
	rsp, err := c.NamespacesDeleteBookieAffinityGroup(ctx, property, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesDeleteBookieAffinityGroupResponse(rsp)
}

// NamespacesGetBookieAffinityGroupWithResponse request returning *NamespacesGetBookieAffinityGroupResponse
func (c *ClientWithResponses) NamespacesGetBookieAffinityGroupWithResponse(ctx context.Context, property string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetBookieAffinityGroupResponse, error) {
	rsp, err := c.NamespacesGetBookieAffinityGroup(ctx, property, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetBookieAffinityGroupResponse(rsp)
}

// NamespacesGetTenantNamespacesWithResponse request returning *NamespacesGetTenantNamespacesResponse
func (c *ClientWithResponses) NamespacesGetTenantNamespacesWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*NamespacesGetTenantNamespacesResponse, error) {
	rsp, err := c.NamespacesGetTenantNamespaces(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetTenantNamespacesResponse(rsp)
}

// NamespacesDeleteNamespaceWithResponse request returning *NamespacesDeleteNamespaceResponse
func (c *ClientWithResponses) NamespacesDeleteNamespaceWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesDeleteNamespaceParams, reqEditors ...RequestEditorFn) (*NamespacesDeleteNamespaceResponse, error) {
	rsp, err := c.NamespacesDeleteNamespace(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesDeleteNamespaceResponse(rsp)
}

// NamespacesGetPoliciesWithResponse request returning *NamespacesGetPoliciesResponse
func (c *ClientWithResponses) NamespacesGetPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPoliciesResponse, error) {
	rsp, err := c.NamespacesGetPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetPoliciesResponse(rsp)
}

// NamespacesCreateNamespaceWithBodyWithResponse request with arbitrary body returning *NamespacesCreateNamespaceResponse
func (c *ClientWithResponses) NamespacesCreateNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesCreateNamespaceResponse, error) {
	rsp, err := c.NamespacesCreateNamespaceWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesCreateNamespaceResponse(rsp)
}

func (c *ClientWithResponses) NamespacesCreateNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesCreateNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesCreateNamespaceResponse, error) {
	rsp, err := c.NamespacesCreateNamespace(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesCreateNamespaceResponse(rsp)
}

// NamespacesRemoveNamespaceAntiAffinityGroupWithResponse request returning *NamespacesRemoveNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) NamespacesRemoveNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.NamespacesRemoveNamespaceAntiAffinityGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveNamespaceAntiAffinityGroupResponse(rsp)
}

// NamespacesGetNamespaceAntiAffinityGroupWithResponse request returning *NamespacesGetNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) NamespacesGetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.NamespacesGetNamespaceAntiAffinityGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetNamespaceAntiAffinityGroupResponse(rsp)
}

// NamespacesSetNamespaceAntiAffinityGroupWithBodyWithResponse request with arbitrary body returning *NamespacesSetNamespaceAntiAffinityGroupResponse
func (c *ClientWithResponses) NamespacesSetNamespaceAntiAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.NamespacesSetNamespaceAntiAffinityGroupWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetNamespaceAntiAffinityGroupResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetNamespaceAntiAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceAntiAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceAntiAffinityGroupResponse, error) {
	rsp, err := c.NamespacesSetNamespaceAntiAffinityGroup(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetNamespaceAntiAffinityGroupResponse(rsp)
}

// NamespacesRemoveAutoSubscriptionCreationWithResponse request returning *NamespacesRemoveAutoSubscriptionCreationResponse
func (c *ClientWithResponses) NamespacesRemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveAutoSubscriptionCreationResponse, error) {
	rsp, err := c.NamespacesRemoveAutoSubscriptionCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveAutoSubscriptionCreationResponse(rsp)
}

// NamespacesGetAutoSubscriptionCreationWithResponse request returning *NamespacesGetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) NamespacesGetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.NamespacesGetAutoSubscriptionCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetAutoSubscriptionCreationResponse(rsp)
}

// NamespacesSetAutoSubscriptionCreationWithBodyWithResponse request with arbitrary body returning *NamespacesSetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) NamespacesSetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.NamespacesSetAutoSubscriptionCreationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetAutoSubscriptionCreationResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetAutoSubscriptionCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.NamespacesSetAutoSubscriptionCreation(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetAutoSubscriptionCreationResponse(rsp)
}

// NamespacesRemoveAutoTopicCreationWithResponse request returning *NamespacesRemoveAutoTopicCreationResponse
func (c *ClientWithResponses) NamespacesRemoveAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveAutoTopicCreationResponse, error) {
	rsp, err := c.NamespacesRemoveAutoTopicCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveAutoTopicCreationResponse(rsp)
}

// NamespacesGetAutoTopicCreationWithResponse request returning *NamespacesGetAutoTopicCreationResponse
func (c *ClientWithResponses) NamespacesGetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetAutoTopicCreationResponse, error) {
	rsp, err := c.NamespacesGetAutoTopicCreation(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetAutoTopicCreationResponse(rsp)
}

// NamespacesSetAutoTopicCreationWithBodyWithResponse request with arbitrary body returning *NamespacesSetAutoTopicCreationResponse
func (c *ClientWithResponses) NamespacesSetAutoTopicCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetAutoTopicCreationResponse, error) {
	rsp, err := c.NamespacesSetAutoTopicCreationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetAutoTopicCreationResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetAutoTopicCreationWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetAutoTopicCreationJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetAutoTopicCreationResponse, error) {
	rsp, err := c.NamespacesSetAutoTopicCreation(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetAutoTopicCreationResponse(rsp)
}

// NamespacesRemoveBacklogQuotaWithResponse request returning *NamespacesRemoveBacklogQuotaResponse
func (c *ClientWithResponses) NamespacesRemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*NamespacesRemoveBacklogQuotaResponse, error) {
	rsp, err := c.NamespacesRemoveBacklogQuota(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveBacklogQuotaResponse(rsp)
}

// NamespacesSetBacklogQuotaWithBodyWithResponse request with arbitrary body returning *NamespacesSetBacklogQuotaResponse
func (c *ClientWithResponses) NamespacesSetBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetBacklogQuotaResponse, error) {
	rsp, err := c.NamespacesSetBacklogQuotaWithBody(ctx, tenant, namespace, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetBacklogQuotaResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesSetBacklogQuotaParams, body NamespacesSetBacklogQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetBacklogQuotaResponse, error) {
	rsp, err := c.NamespacesSetBacklogQuota(ctx, tenant, namespace, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetBacklogQuotaResponse(rsp)
}

// NamespacesGetBacklogQuotaMapWithResponse request returning *NamespacesGetBacklogQuotaMapResponse
func (c *ClientWithResponses) NamespacesGetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetBacklogQuotaMapResponse, error) {
	rsp, err := c.NamespacesGetBacklogQuotaMap(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetBacklogQuotaMapResponse(rsp)
}

// NamespacesGetBundlesDataWithResponse request returning *NamespacesGetBundlesDataResponse
func (c *ClientWithResponses) NamespacesGetBundlesDataWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetBundlesDataResponse, error) {
	rsp, err := c.NamespacesGetBundlesData(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetBundlesDataResponse(rsp)
}

// NamespacesClearNamespaceBacklogWithResponse request returning *NamespacesClearNamespaceBacklogResponse
func (c *ClientWithResponses) NamespacesClearNamespaceBacklogWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesClearNamespaceBacklogParams, reqEditors ...RequestEditorFn) (*NamespacesClearNamespaceBacklogResponse, error) {
	rsp, err := c.NamespacesClearNamespaceBacklog(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesClearNamespaceBacklogResponse(rsp)
}

// NamespacesClearNamespaceBacklogForSubscriptionWithResponse request returning *NamespacesClearNamespaceBacklogForSubscriptionResponse
func (c *ClientWithResponses) NamespacesClearNamespaceBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *NamespacesClearNamespaceBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*NamespacesClearNamespaceBacklogForSubscriptionResponse, error) {
	rsp, err := c.NamespacesClearNamespaceBacklogForSubscription(ctx, tenant, namespace, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesClearNamespaceBacklogForSubscriptionResponse(rsp)
}

// NamespacesDeleteCompactionThresholdWithResponse request returning *NamespacesDeleteCompactionThresholdResponse
func (c *ClientWithResponses) NamespacesDeleteCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteCompactionThresholdResponse, error) {
	rsp, err := c.NamespacesDeleteCompactionThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesDeleteCompactionThresholdResponse(rsp)
}

// NamespacesGetCompactionThresholdWithResponse request returning *NamespacesGetCompactionThresholdResponse
func (c *ClientWithResponses) NamespacesGetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetCompactionThresholdResponse, error) {
	rsp, err := c.NamespacesGetCompactionThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetCompactionThresholdResponse(rsp)
}

// NamespacesSetCompactionThresholdWithBodyWithResponse request with arbitrary body returning *NamespacesSetCompactionThresholdResponse
func (c *ClientWithResponses) NamespacesSetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetCompactionThresholdResponse, error) {
	rsp, err := c.NamespacesSetCompactionThresholdWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetCompactionThresholdResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetCompactionThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetCompactionThresholdResponse, error) {
	rsp, err := c.NamespacesSetCompactionThreshold(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetCompactionThresholdResponse(rsp)
}

// NamespacesRemoveDeduplicationWithResponse request returning *NamespacesRemoveDeduplicationResponse
func (c *ClientWithResponses) NamespacesRemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveDeduplicationResponse, error) {
	rsp, err := c.NamespacesRemoveDeduplication(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveDeduplicationResponse(rsp)
}

// NamespacesGetDeduplicationWithResponse request returning *NamespacesGetDeduplicationResponse
func (c *ClientWithResponses) NamespacesGetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetDeduplicationResponse, error) {
	rsp, err := c.NamespacesGetDeduplication(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetDeduplicationResponse(rsp)
}

// NamespacesModifyDeduplicationWithBodyWithResponse request with arbitrary body returning *NamespacesModifyDeduplicationResponse
func (c *ClientWithResponses) NamespacesModifyDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesModifyDeduplicationResponse, error) {
	rsp, err := c.NamespacesModifyDeduplicationWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesModifyDeduplicationResponse(rsp)
}

func (c *ClientWithResponses) NamespacesModifyDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesModifyDeduplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesModifyDeduplicationResponse, error) {
	rsp, err := c.NamespacesModifyDeduplication(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesModifyDeduplicationResponse(rsp)
}

// NamespacesGetDeduplicationSnapshotIntervalWithResponse request returning *NamespacesGetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) NamespacesGetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.NamespacesGetDeduplicationSnapshotInterval(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetDeduplicationSnapshotIntervalResponse(rsp)
}

// NamespacesSetDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *NamespacesSetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) NamespacesSetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.NamespacesSetDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetDeduplicationSnapshotIntervalResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetDeduplicationSnapshotIntervalJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.NamespacesSetDeduplicationSnapshotInterval(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetDeduplicationSnapshotIntervalResponse(rsp)
}

// NamespacesRemoveDelayedDeliveryPoliciesWithResponse request returning *NamespacesRemoveDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) NamespacesRemoveDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.NamespacesRemoveDelayedDeliveryPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveDelayedDeliveryPoliciesResponse(rsp)
}

// NamespacesGetDelayedDeliveryPoliciesWithResponse request returning *NamespacesGetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) NamespacesGetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.NamespacesGetDelayedDeliveryPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetDelayedDeliveryPoliciesResponse(rsp)
}

// NamespacesSetDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *NamespacesSetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) NamespacesSetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.NamespacesSetDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetDelayedDeliveryPoliciesResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetDelayedDeliveryPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.NamespacesSetDelayedDeliveryPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetDelayedDeliveryPoliciesResponse(rsp)
}

// NamespacesDeleteDispatchRateWithResponse request returning *NamespacesDeleteDispatchRateResponse
func (c *ClientWithResponses) NamespacesDeleteDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteDispatchRateResponse, error) {
	rsp, err := c.NamespacesDeleteDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesDeleteDispatchRateResponse(rsp)
}

// NamespacesGetDispatchRateWithResponse request returning *NamespacesGetDispatchRateResponse
func (c *ClientWithResponses) NamespacesGetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetDispatchRateResponse, error) {
	rsp, err := c.NamespacesGetDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetDispatchRateResponse(rsp)
}

// NamespacesSetDispatchRateWithBodyWithResponse request with arbitrary body returning *NamespacesSetDispatchRateResponse
func (c *ClientWithResponses) NamespacesSetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetDispatchRateResponse, error) {
	rsp, err := c.NamespacesSetDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetDispatchRateResponse, error) {
	rsp, err := c.NamespacesSetDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetDispatchRateResponse(rsp)
}

// NamespacesGetEncryptionRequiredWithResponse request returning *NamespacesGetEncryptionRequiredResponse
func (c *ClientWithResponses) NamespacesGetEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetEncryptionRequiredResponse, error) {
	rsp, err := c.NamespacesGetEncryptionRequired(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetEncryptionRequiredResponse(rsp)
}

// NamespacesModifyEncryptionRequiredWithBodyWithResponse request with arbitrary body returning *NamespacesModifyEncryptionRequiredResponse
func (c *ClientWithResponses) NamespacesModifyEncryptionRequiredWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesModifyEncryptionRequiredResponse, error) {
	rsp, err := c.NamespacesModifyEncryptionRequiredWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesModifyEncryptionRequiredResponse(rsp)
}

func (c *ClientWithResponses) NamespacesModifyEncryptionRequiredWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesModifyEncryptionRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesModifyEncryptionRequiredResponse, error) {
	rsp, err := c.NamespacesModifyEncryptionRequired(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesModifyEncryptionRequiredResponse(rsp)
}

// NamespacesRemoveNamespaceEntryFiltersWithResponse request returning *NamespacesRemoveNamespaceEntryFiltersResponse
func (c *ClientWithResponses) NamespacesRemoveNamespaceEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveNamespaceEntryFiltersResponse, error) {
	rsp, err := c.NamespacesRemoveNamespaceEntryFilters(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveNamespaceEntryFiltersResponse(rsp)
}

// NamespacesGetEntryFiltersPerTopicWithResponse request returning *NamespacesGetEntryFiltersPerTopicResponse
func (c *ClientWithResponses) NamespacesGetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetEntryFiltersPerTopicResponse, error) {
	rsp, err := c.NamespacesGetEntryFiltersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetEntryFiltersPerTopicResponse(rsp)
}

// NamespacesSetEntryFiltersPerTopicWithBodyWithResponse request with arbitrary body returning *NamespacesSetEntryFiltersPerTopicResponse
func (c *ClientWithResponses) NamespacesSetEntryFiltersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetEntryFiltersPerTopicResponse, error) {
	rsp, err := c.NamespacesSetEntryFiltersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetEntryFiltersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetEntryFiltersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetEntryFiltersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetEntryFiltersPerTopicResponse, error) {
	rsp, err := c.NamespacesSetEntryFiltersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetEntryFiltersPerTopicResponse(rsp)
}

// NamespacesRemoveInactiveTopicPoliciesWithResponse request returning *NamespacesRemoveInactiveTopicPoliciesResponse
func (c *ClientWithResponses) NamespacesRemoveInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveInactiveTopicPoliciesResponse, error) {
	rsp, err := c.NamespacesRemoveInactiveTopicPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveInactiveTopicPoliciesResponse(rsp)
}

// NamespacesGetInactiveTopicPoliciesWithResponse request returning *NamespacesGetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) NamespacesGetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.NamespacesGetInactiveTopicPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetInactiveTopicPoliciesResponse(rsp)
}

// NamespacesSetInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *NamespacesSetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) NamespacesSetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.NamespacesSetInactiveTopicPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetInactiveTopicPoliciesResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetInactiveTopicPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.NamespacesSetInactiveTopicPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetInactiveTopicPoliciesResponse(rsp)
}

// NamespacesGetIsAllowAutoUpdateSchemaWithResponse request returning *NamespacesGetIsAllowAutoUpdateSchemaResponse
func (c *ClientWithResponses) NamespacesGetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.NamespacesGetIsAllowAutoUpdateSchema(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetIsAllowAutoUpdateSchemaResponse(rsp)
}

// NamespacesSetIsAllowAutoUpdateSchemaWithBodyWithResponse request with arbitrary body returning *NamespacesSetIsAllowAutoUpdateSchemaResponse
func (c *ClientWithResponses) NamespacesSetIsAllowAutoUpdateSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.NamespacesSetIsAllowAutoUpdateSchemaWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetIsAllowAutoUpdateSchemaResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetIsAllowAutoUpdateSchemaWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetIsAllowAutoUpdateSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetIsAllowAutoUpdateSchemaResponse, error) {
	rsp, err := c.NamespacesSetIsAllowAutoUpdateSchema(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetIsAllowAutoUpdateSchemaResponse(rsp)
}

// NamespacesRemoveMaxConsumersPerSubscriptionWithResponse request returning *NamespacesRemoveMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) NamespacesRemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.NamespacesRemoveMaxConsumersPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveMaxConsumersPerSubscriptionResponse(rsp)
}

// NamespacesGetMaxConsumersPerSubscriptionWithResponse request returning *NamespacesGetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) NamespacesGetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.NamespacesGetMaxConsumersPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetMaxConsumersPerSubscriptionResponse(rsp)
}

// NamespacesSetMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *NamespacesSetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) NamespacesSetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.NamespacesSetMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxConsumersPerSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxConsumersPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.NamespacesSetMaxConsumersPerSubscription(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxConsumersPerSubscriptionResponse(rsp)
}

// NamespacesRemoveMaxConsumersPerTopicWithResponse request returning *NamespacesRemoveMaxConsumersPerTopicResponse
func (c *ClientWithResponses) NamespacesRemoveMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxConsumersPerTopicResponse, error) {
	rsp, err := c.NamespacesRemoveMaxConsumersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveMaxConsumersPerTopicResponse(rsp)
}

// NamespacesGetMaxConsumersPerTopicWithResponse request returning *NamespacesGetMaxConsumersPerTopicResponse
func (c *ClientWithResponses) NamespacesGetMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxConsumersPerTopicResponse, error) {
	rsp, err := c.NamespacesGetMaxConsumersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetMaxConsumersPerTopicResponse(rsp)
}

// NamespacesSetMaxConsumersPerTopicWithBodyWithResponse request with arbitrary body returning *NamespacesSetMaxConsumersPerTopicResponse
func (c *ClientWithResponses) NamespacesSetMaxConsumersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxConsumersPerTopicResponse, error) {
	rsp, err := c.NamespacesSetMaxConsumersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxConsumersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetMaxConsumersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxConsumersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxConsumersPerTopicResponse, error) {
	rsp, err := c.NamespacesSetMaxConsumersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxConsumersPerTopicResponse(rsp)
}

// NamespacesRemoveMaxProducersPerTopicWithResponse request returning *NamespacesRemoveMaxProducersPerTopicResponse
func (c *ClientWithResponses) NamespacesRemoveMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxProducersPerTopicResponse, error) {
	rsp, err := c.NamespacesRemoveMaxProducersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveMaxProducersPerTopicResponse(rsp)
}

// NamespacesGetMaxProducersPerTopicWithResponse request returning *NamespacesGetMaxProducersPerTopicResponse
func (c *ClientWithResponses) NamespacesGetMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxProducersPerTopicResponse, error) {
	rsp, err := c.NamespacesGetMaxProducersPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetMaxProducersPerTopicResponse(rsp)
}

// NamespacesSetMaxProducersPerTopicWithBodyWithResponse request with arbitrary body returning *NamespacesSetMaxProducersPerTopicResponse
func (c *ClientWithResponses) NamespacesSetMaxProducersPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxProducersPerTopicResponse, error) {
	rsp, err := c.NamespacesSetMaxProducersPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxProducersPerTopicResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetMaxProducersPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxProducersPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxProducersPerTopicResponse, error) {
	rsp, err := c.NamespacesSetMaxProducersPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxProducersPerTopicResponse(rsp)
}

// NamespacesRemoveMaxSubscriptionsPerTopicWithResponse request returning *NamespacesRemoveMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) NamespacesRemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.NamespacesRemoveMaxSubscriptionsPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveMaxSubscriptionsPerTopicResponse(rsp)
}

// NamespacesGetMaxSubscriptionsPerTopicWithResponse request returning *NamespacesGetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) NamespacesGetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.NamespacesGetMaxSubscriptionsPerTopic(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetMaxSubscriptionsPerTopicResponse(rsp)
}

// NamespacesSetMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *NamespacesSetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) NamespacesSetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.NamespacesSetMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxSubscriptionsPerTopicResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxSubscriptionsPerTopicJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.NamespacesSetMaxSubscriptionsPerTopic(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxSubscriptionsPerTopicResponse(rsp)
}

// NamespacesRemoveMaxTopicsPerNamespaceWithResponse request returning *NamespacesRemoveMaxTopicsPerNamespaceResponse
func (c *ClientWithResponses) NamespacesRemoveMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.NamespacesRemoveMaxTopicsPerNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveMaxTopicsPerNamespaceResponse(rsp)
}

// NamespacesGetMaxTopicsPerNamespaceWithResponse request returning *NamespacesGetMaxTopicsPerNamespaceResponse
func (c *ClientWithResponses) NamespacesGetMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.NamespacesGetMaxTopicsPerNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetMaxTopicsPerNamespaceResponse(rsp)
}

// NamespacesSetMaxTopicsPerNamespaceWithBodyWithResponse request with arbitrary body returning *NamespacesSetMaxTopicsPerNamespaceResponse
func (c *ClientWithResponses) NamespacesSetMaxTopicsPerNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.NamespacesSetMaxTopicsPerNamespaceWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxTopicsPerNamespaceResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetMaxTopicsPerNamespaceWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxTopicsPerNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxTopicsPerNamespaceResponse, error) {
	rsp, err := c.NamespacesSetMaxTopicsPerNamespace(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxTopicsPerNamespaceResponse(rsp)
}

// NamespacesRemoveMaxUnackedmessagesPerConsumerWithResponse request returning *NamespacesRemoveMaxUnackedmessagesPerConsumerResponse
func (c *ClientWithResponses) NamespacesRemoveMaxUnackedmessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxUnackedmessagesPerConsumerResponse, error) {
	rsp, err := c.NamespacesRemoveMaxUnackedmessagesPerConsumer(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveMaxUnackedmessagesPerConsumerResponse(rsp)
}

// NamespacesGetMaxUnackedMessagesPerConsumerWithResponse request returning *NamespacesGetMaxUnackedMessagesPerConsumerResponse
func (c *ClientWithResponses) NamespacesGetMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.NamespacesGetMaxUnackedMessagesPerConsumer(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetMaxUnackedMessagesPerConsumerResponse(rsp)
}

// NamespacesSetMaxUnackedMessagesPerConsumerWithBodyWithResponse request with arbitrary body returning *NamespacesSetMaxUnackedMessagesPerConsumerResponse
func (c *ClientWithResponses) NamespacesSetMaxUnackedMessagesPerConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.NamespacesSetMaxUnackedMessagesPerConsumerWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxUnackedMessagesPerConsumerResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetMaxUnackedMessagesPerConsumerWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerConsumerJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxUnackedMessagesPerConsumerResponse, error) {
	rsp, err := c.NamespacesSetMaxUnackedMessagesPerConsumer(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxUnackedMessagesPerConsumerResponse(rsp)
}

// NamespacesRemoveMaxUnackedmessagesPerSubscriptionWithResponse request returning *NamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse
func (c *ClientWithResponses) NamespacesRemoveMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse, error) {
	rsp, err := c.NamespacesRemoveMaxUnackedmessagesPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse(rsp)
}

// NamespacesGetMaxUnackedmessagesPerSubscriptionWithResponse request returning *NamespacesGetMaxUnackedmessagesPerSubscriptionResponse
func (c *ClientWithResponses) NamespacesGetMaxUnackedmessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetMaxUnackedmessagesPerSubscriptionResponse, error) {
	rsp, err := c.NamespacesGetMaxUnackedmessagesPerSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetMaxUnackedmessagesPerSubscriptionResponse(rsp)
}

// NamespacesSetMaxUnackedMessagesPerSubscriptionWithBodyWithResponse request with arbitrary body returning *NamespacesSetMaxUnackedMessagesPerSubscriptionResponse
func (c *ClientWithResponses) NamespacesSetMaxUnackedMessagesPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetMaxUnackedMessagesPerSubscriptionResponse, error) {
	rsp, err := c.NamespacesSetMaxUnackedMessagesPerSubscriptionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxUnackedMessagesPerSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetMaxUnackedMessagesPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetMaxUnackedMessagesPerSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetMaxUnackedMessagesPerSubscriptionResponse, error) {
	rsp, err := c.NamespacesSetMaxUnackedMessagesPerSubscription(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetMaxUnackedMessagesPerSubscriptionResponse(rsp)
}

// NamespacesRemoveNamespaceMessageTTLWithResponse request returning *NamespacesRemoveNamespaceMessageTTLResponse
func (c *ClientWithResponses) NamespacesRemoveNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveNamespaceMessageTTLResponse, error) {
	rsp, err := c.NamespacesRemoveNamespaceMessageTTL(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveNamespaceMessageTTLResponse(rsp)
}

// NamespacesGetNamespaceMessageTTLWithResponse request returning *NamespacesGetNamespaceMessageTTLResponse
func (c *ClientWithResponses) NamespacesGetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetNamespaceMessageTTLResponse, error) {
	rsp, err := c.NamespacesGetNamespaceMessageTTL(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetNamespaceMessageTTLResponse(rsp)
}

// NamespacesSetNamespaceMessageTTLWithBodyWithResponse request with arbitrary body returning *NamespacesSetNamespaceMessageTTLResponse
func (c *ClientWithResponses) NamespacesSetNamespaceMessageTTLWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceMessageTTLResponse, error) {
	rsp, err := c.NamespacesSetNamespaceMessageTTLWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetNamespaceMessageTTLResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetNamespaceMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceMessageTTLJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceMessageTTLResponse, error) {
	rsp, err := c.NamespacesSetNamespaceMessageTTL(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetNamespaceMessageTTLResponse(rsp)
}

// NamespacesClearOffloadDeletionLagWithResponse request returning *NamespacesClearOffloadDeletionLagResponse
func (c *ClientWithResponses) NamespacesClearOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesClearOffloadDeletionLagResponse, error) {
	rsp, err := c.NamespacesClearOffloadDeletionLag(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesClearOffloadDeletionLagResponse(rsp)
}

// NamespacesGetOffloadDeletionLagWithResponse request returning *NamespacesGetOffloadDeletionLagResponse
func (c *ClientWithResponses) NamespacesGetOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetOffloadDeletionLagResponse, error) {
	rsp, err := c.NamespacesGetOffloadDeletionLag(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetOffloadDeletionLagResponse(rsp)
}

// NamespacesSetOffloadDeletionLagWithBodyWithResponse request with arbitrary body returning *NamespacesSetOffloadDeletionLagResponse
func (c *ClientWithResponses) NamespacesSetOffloadDeletionLagWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadDeletionLagResponse, error) {
	rsp, err := c.NamespacesSetOffloadDeletionLagWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetOffloadDeletionLagResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetOffloadDeletionLagWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadDeletionLagJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadDeletionLagResponse, error) {
	rsp, err := c.NamespacesSetOffloadDeletionLag(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetOffloadDeletionLagResponse(rsp)
}

// NamespacesGetOffloadPoliciesWithResponse request returning *NamespacesGetOffloadPoliciesResponse
func (c *ClientWithResponses) NamespacesGetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetOffloadPoliciesResponse, error) {
	rsp, err := c.NamespacesGetOffloadPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetOffloadPoliciesResponse(rsp)
}

// NamespacesSetOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *NamespacesSetOffloadPoliciesResponse
func (c *ClientWithResponses) NamespacesSetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadPoliciesResponse, error) {
	rsp, err := c.NamespacesSetOffloadPoliciesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetOffloadPoliciesResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadPoliciesResponse, error) {
	rsp, err := c.NamespacesSetOffloadPolicies(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetOffloadPoliciesResponse(rsp)
}

// NamespacesGetOffloadThresholdWithResponse request returning *NamespacesGetOffloadThresholdResponse
func (c *ClientWithResponses) NamespacesGetOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetOffloadThresholdResponse, error) {
	rsp, err := c.NamespacesGetOffloadThreshold(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetOffloadThresholdResponse(rsp)
}

// NamespacesSetOffloadThresholdWithBodyWithResponse request with arbitrary body returning *NamespacesSetOffloadThresholdResponse
func (c *ClientWithResponses) NamespacesSetOffloadThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadThresholdResponse, error) {
	rsp, err := c.NamespacesSetOffloadThresholdWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetOffloadThresholdResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetOffloadThresholdWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetOffloadThresholdJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadThresholdResponse, error) {
	rsp, err := c.NamespacesSetOffloadThreshold(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetOffloadThresholdResponse(rsp)
}

// NamespacesGetOffloadThresholdInSecondsWithResponse request returning *NamespacesGetOffloadThresholdInSecondsResponse
func (c *ClientWithResponses) NamespacesGetOffloadThresholdInSecondsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetOffloadThresholdInSecondsResponse, error) {
	rsp, err := c.NamespacesGetOffloadThresholdInSeconds(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetOffloadThresholdInSecondsResponse(rsp)
}

// NamespacesSetOffloadThresholdInSecondsWithResponse request returning *NamespacesSetOffloadThresholdInSecondsResponse
func (c *ClientWithResponses) NamespacesSetOffloadThresholdInSecondsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesSetOffloadThresholdInSecondsResponse, error) {
	rsp, err := c.NamespacesSetOffloadThresholdInSeconds(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetOffloadThresholdInSecondsResponse(rsp)
}

// NamespacesGetPermissionsWithResponse request returning *NamespacesGetPermissionsResponse
func (c *ClientWithResponses) NamespacesGetPermissionsWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPermissionsResponse, error) {
	rsp, err := c.NamespacesGetPermissions(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetPermissionsResponse(rsp)
}

// NamespacesGetPermissionOnSubscriptionWithResponse request returning *NamespacesGetPermissionOnSubscriptionResponse
func (c *ClientWithResponses) NamespacesGetPermissionOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPermissionOnSubscriptionResponse, error) {
	rsp, err := c.NamespacesGetPermissionOnSubscription(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetPermissionOnSubscriptionResponse(rsp)
}

// NamespacesRevokePermissionsOnNamespaceWithResponse request returning *NamespacesRevokePermissionsOnNamespaceResponse
func (c *ClientWithResponses) NamespacesRevokePermissionsOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, reqEditors ...RequestEditorFn) (*NamespacesRevokePermissionsOnNamespaceResponse, error) {
	rsp, err := c.NamespacesRevokePermissionsOnNamespace(ctx, tenant, namespace, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRevokePermissionsOnNamespaceResponse(rsp)
}

// NamespacesGrantPermissionOnNamespaceWithBodyWithResponse request with arbitrary body returning *NamespacesGrantPermissionOnNamespaceResponse
func (c *ClientWithResponses) NamespacesGrantPermissionOnNamespaceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesGrantPermissionOnNamespaceResponse, error) {
	rsp, err := c.NamespacesGrantPermissionOnNamespaceWithBody(ctx, tenant, namespace, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGrantPermissionOnNamespaceResponse(rsp)
}

func (c *ClientWithResponses) NamespacesGrantPermissionOnNamespaceWithResponse(ctx context.Context, tenant string, namespace string, role string, body NamespacesGrantPermissionOnNamespaceJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesGrantPermissionOnNamespaceResponse, error) {
	rsp, err := c.NamespacesGrantPermissionOnNamespace(ctx, tenant, namespace, role, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGrantPermissionOnNamespaceResponse(rsp)
}

// NamespacesDeletePersistenceWithResponse request returning *NamespacesDeletePersistenceResponse
func (c *ClientWithResponses) NamespacesDeletePersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeletePersistenceResponse, error) {
	rsp, err := c.NamespacesDeletePersistence(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesDeletePersistenceResponse(rsp)
}

// NamespacesGetPersistenceWithResponse request returning *NamespacesGetPersistenceResponse
func (c *ClientWithResponses) NamespacesGetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPersistenceResponse, error) {
	rsp, err := c.NamespacesGetPersistence(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetPersistenceResponse(rsp)
}

// NamespacesSetPersistenceWithBodyWithResponse request with arbitrary body returning *NamespacesSetPersistenceResponse
func (c *ClientWithResponses) NamespacesSetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetPersistenceResponse, error) {
	rsp, err := c.NamespacesSetPersistenceWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetPersistenceResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetPersistenceJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetPersistenceResponse, error) {
	rsp, err := c.NamespacesSetPersistence(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetPersistenceResponse(rsp)
}

// NamespacesSetBookieAffinityGroupWithBodyWithResponse request with arbitrary body returning *NamespacesSetBookieAffinityGroupResponse
func (c *ClientWithResponses) NamespacesSetBookieAffinityGroupWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetBookieAffinityGroupResponse, error) {
	rsp, err := c.NamespacesSetBookieAffinityGroupWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetBookieAffinityGroupResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetBookieAffinityGroupWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetBookieAffinityGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetBookieAffinityGroupResponse, error) {
	rsp, err := c.NamespacesSetBookieAffinityGroup(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetBookieAffinityGroupResponse(rsp)
}

// NamespacesClearPropertiesWithResponse request returning *NamespacesClearPropertiesResponse
func (c *ClientWithResponses) NamespacesClearPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesClearPropertiesResponse, error) {
	rsp, err := c.NamespacesClearProperties(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesClearPropertiesResponse(rsp)
}

// NamespacesGetPropertiesWithResponse request returning *NamespacesGetPropertiesResponse
func (c *ClientWithResponses) NamespacesGetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetPropertiesResponse, error) {
	rsp, err := c.NamespacesGetProperties(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetPropertiesResponse(rsp)
}

// NamespacesSetPropertiesWithBodyWithResponse request with arbitrary body returning *NamespacesSetPropertiesResponse
func (c *ClientWithResponses) NamespacesSetPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetPropertiesResponse, error) {
	rsp, err := c.NamespacesSetPropertiesWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetPropertiesResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetPropertiesJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetPropertiesResponse, error) {
	rsp, err := c.NamespacesSetProperties(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetPropertiesResponse(rsp)
}

// NamespacesRemovePropertyWithResponse request returning *NamespacesRemovePropertyResponse
func (c *ClientWithResponses) NamespacesRemovePropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*NamespacesRemovePropertyResponse, error) {
	rsp, err := c.NamespacesRemoveProperty(ctx, tenant, namespace, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemovePropertyResponse(rsp)
}

// NamespacesGetPropertyWithResponse request returning *NamespacesGetPropertyResponse
func (c *ClientWithResponses) NamespacesGetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, reqEditors ...RequestEditorFn) (*NamespacesGetPropertyResponse, error) {
	rsp, err := c.NamespacesGetProperty(ctx, tenant, namespace, key, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetPropertyResponse(rsp)
}

// NamespacesSetPropertyWithResponse request returning *NamespacesSetPropertyResponse
func (c *ClientWithResponses) NamespacesSetPropertyWithResponse(ctx context.Context, tenant string, namespace string, key string, value string, reqEditors ...RequestEditorFn) (*NamespacesSetPropertyResponse, error) {
	rsp, err := c.NamespacesSetProperty(ctx, tenant, namespace, key, value, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetPropertyResponse(rsp)
}

// NamespacesRemoveOffloadPoliciesWithResponse request returning *NamespacesRemoveOffloadPoliciesResponse
func (c *ClientWithResponses) NamespacesRemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveOffloadPoliciesResponse, error) {
	rsp, err := c.NamespacesRemoveOffloadPolicies(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveOffloadPoliciesResponse(rsp)
}

// NamespacesGetNamespaceReplicationClustersWithResponse request returning *NamespacesGetNamespaceReplicationClustersResponse
func (c *ClientWithResponses) NamespacesGetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.NamespacesGetNamespaceReplicationClusters(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetNamespaceReplicationClustersResponse(rsp)
}

// NamespacesSetNamespaceReplicationClustersWithBodyWithResponse request with arbitrary body returning *NamespacesSetNamespaceReplicationClustersResponse
func (c *ClientWithResponses) NamespacesSetNamespaceReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.NamespacesSetNamespaceReplicationClustersWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetNamespaceReplicationClustersResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetNamespaceReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetNamespaceReplicationClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceReplicationClustersResponse, error) {
	rsp, err := c.NamespacesSetNamespaceReplicationClusters(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetNamespaceReplicationClustersResponse(rsp)
}

// NamespacesRemoveReplicatorDispatchRateWithResponse request returning *NamespacesRemoveReplicatorDispatchRateResponse
func (c *ClientWithResponses) NamespacesRemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveReplicatorDispatchRateResponse, error) {
	rsp, err := c.NamespacesRemoveReplicatorDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveReplicatorDispatchRateResponse(rsp)
}

// NamespacesGetReplicatorDispatchRateWithResponse request returning *NamespacesGetReplicatorDispatchRateResponse
func (c *ClientWithResponses) NamespacesGetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetReplicatorDispatchRateResponse, error) {
	rsp, err := c.NamespacesGetReplicatorDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetReplicatorDispatchRateResponse(rsp)
}

// NamespacesSetReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *NamespacesSetReplicatorDispatchRateResponse
func (c *ClientWithResponses) NamespacesSetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetReplicatorDispatchRateResponse, error) {
	rsp, err := c.NamespacesSetReplicatorDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetReplicatorDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetReplicatorDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetReplicatorDispatchRateResponse, error) {
	rsp, err := c.NamespacesSetReplicatorDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetReplicatorDispatchRateResponse(rsp)
}

// NamespacesRemoveNamespaceResourceGroupWithResponse request returning *NamespacesRemoveNamespaceResourceGroupResponse
func (c *ClientWithResponses) NamespacesRemoveNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveNamespaceResourceGroupResponse, error) {
	rsp, err := c.NamespacesRemoveNamespaceResourceGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveNamespaceResourceGroupResponse(rsp)
}

// NamespacesGetNamespaceResourceGroupWithResponse request returning *NamespacesGetNamespaceResourceGroupResponse
func (c *ClientWithResponses) NamespacesGetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetNamespaceResourceGroupResponse, error) {
	rsp, err := c.NamespacesGetNamespaceResourceGroup(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetNamespaceResourceGroupResponse(rsp)
}

// NamespacesSetNamespaceResourceGroupWithResponse request returning *NamespacesSetNamespaceResourceGroupResponse
func (c *ClientWithResponses) NamespacesSetNamespaceResourceGroupWithResponse(ctx context.Context, tenant string, namespace string, resourcegroup string, reqEditors ...RequestEditorFn) (*NamespacesSetNamespaceResourceGroupResponse, error) {
	rsp, err := c.NamespacesSetNamespaceResourceGroup(ctx, tenant, namespace, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetNamespaceResourceGroupResponse(rsp)
}

// NamespacesRemoveRetentionWithBodyWithResponse request with arbitrary body returning *NamespacesRemoveRetentionResponse
func (c *ClientWithResponses) NamespacesRemoveRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesRemoveRetentionResponse, error) {
	rsp, err := c.NamespacesRemoveRetentionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveRetentionResponse(rsp)
}

func (c *ClientWithResponses) NamespacesRemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesRemoveRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesRemoveRetentionResponse, error) {
	rsp, err := c.NamespacesRemoveRetention(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveRetentionResponse(rsp)
}

// NamespacesGetRetentionWithResponse request returning *NamespacesGetRetentionResponse
func (c *ClientWithResponses) NamespacesGetRetentionWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetRetentionResponse, error) {
	rsp, err := c.NamespacesGetRetention(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetRetentionResponse(rsp)
}

// NamespacesSetRetentionWithBodyWithResponse request with arbitrary body returning *NamespacesSetRetentionResponse
func (c *ClientWithResponses) NamespacesSetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetRetentionResponse, error) {
	rsp, err := c.NamespacesSetRetentionWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetRetentionResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetRetentionWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetRetentionJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetRetentionResponse, error) {
	rsp, err := c.NamespacesSetRetention(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetRetentionResponse(rsp)
}

// NamespacesScanOffloadedLedgersWithResponse request returning *NamespacesScanOffloadedLedgersResponse
func (c *ClientWithResponses) NamespacesScanOffloadedLedgersWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesScanOffloadedLedgersResponse, error) {
	rsp, err := c.NamespacesScanOffloadedLedgers(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesScanOffloadedLedgersResponse(rsp)
}

// NamespacesGetSchemaAutoUpdateCompatibilityStrategyWithResponse request returning *NamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse
func (c *ClientWithResponses) NamespacesGetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.NamespacesGetSchemaAutoUpdateCompatibilityStrategy(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

// NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse
func (c *ClientWithResponses) NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaAutoUpdateCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	rsp, err := c.NamespacesSetSchemaAutoUpdateCompatibilityStrategy(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp)
}

// NamespacesGetSchemaCompatibilityStrategyWithResponse request returning *NamespacesGetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) NamespacesGetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.NamespacesGetSchemaCompatibilityStrategy(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetSchemaCompatibilityStrategyResponse(rsp)
}

// NamespacesSetSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *NamespacesSetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) NamespacesSetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.NamespacesSetSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSchemaCompatibilityStrategyResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaCompatibilityStrategyJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.NamespacesSetSchemaCompatibilityStrategy(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSchemaCompatibilityStrategyResponse(rsp)
}

// NamespacesGetSchemaValidtionEnforcedWithResponse request returning *NamespacesGetSchemaValidtionEnforcedResponse
func (c *ClientWithResponses) NamespacesGetSchemaValidtionEnforcedWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesGetSchemaValidtionEnforcedParams, reqEditors ...RequestEditorFn) (*NamespacesGetSchemaValidtionEnforcedResponse, error) {
	rsp, err := c.NamespacesGetSchemaValidtionEnforced(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetSchemaValidtionEnforcedResponse(rsp)
}

// NamespacesSetSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *NamespacesSetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) NamespacesSetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.NamespacesSetSchemaValidationEnforcedWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSchemaValidationEnforcedResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSchemaValidationEnforcedJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.NamespacesSetSchemaValidationEnforced(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSchemaValidationEnforcedResponse(rsp)
}

// NamespacesDeleteSubscribeRateWithResponse request returning *NamespacesDeleteSubscribeRateResponse
func (c *ClientWithResponses) NamespacesDeleteSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteSubscribeRateResponse, error) {
	rsp, err := c.NamespacesDeleteSubscribeRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesDeleteSubscribeRateResponse(rsp)
}

// NamespacesGetSubscribeRateWithResponse request returning *NamespacesGetSubscribeRateResponse
func (c *ClientWithResponses) NamespacesGetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscribeRateResponse, error) {
	rsp, err := c.NamespacesGetSubscribeRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetSubscribeRateResponse(rsp)
}

// NamespacesSetSubscribeRateWithBodyWithResponse request with arbitrary body returning *NamespacesSetSubscribeRateResponse
func (c *ClientWithResponses) NamespacesSetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscribeRateResponse, error) {
	rsp, err := c.NamespacesSetSubscribeRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscribeRateResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscribeRateJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscribeRateResponse, error) {
	rsp, err := c.NamespacesSetSubscribeRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscribeRateResponse(rsp)
}

// NamespacesGetSubscriptionAuthModeWithResponse request returning *NamespacesGetSubscriptionAuthModeResponse
func (c *ClientWithResponses) NamespacesGetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscriptionAuthModeResponse, error) {
	rsp, err := c.NamespacesGetSubscriptionAuthMode(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetSubscriptionAuthModeResponse(rsp)
}

// NamespacesSetSubscriptionAuthModeWithBodyWithResponse request with arbitrary body returning *NamespacesSetSubscriptionAuthModeResponse
func (c *ClientWithResponses) NamespacesSetSubscriptionAuthModeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionAuthModeResponse, error) {
	rsp, err := c.NamespacesSetSubscriptionAuthModeWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscriptionAuthModeResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetSubscriptionAuthModeWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionAuthModeJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionAuthModeResponse, error) {
	rsp, err := c.NamespacesSetSubscriptionAuthMode(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscriptionAuthModeResponse(rsp)
}

// NamespacesDeleteSubscriptionDispatchRateWithResponse request returning *NamespacesDeleteSubscriptionDispatchRateResponse
func (c *ClientWithResponses) NamespacesDeleteSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesDeleteSubscriptionDispatchRateResponse, error) {
	rsp, err := c.NamespacesDeleteSubscriptionDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesDeleteSubscriptionDispatchRateResponse(rsp)
}

// NamespacesGetSubscriptionDispatchRateWithResponse request returning *NamespacesGetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) NamespacesGetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.NamespacesGetSubscriptionDispatchRate(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetSubscriptionDispatchRateResponse(rsp)
}

// NamespacesSetSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *NamespacesSetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) NamespacesSetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.NamespacesSetSubscriptionDispatchRateWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscriptionDispatchRateResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionDispatchRateJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.NamespacesSetSubscriptionDispatchRate(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscriptionDispatchRateResponse(rsp)
}

// NamespacesRemoveSubscriptionExpirationTimeWithResponse request returning *NamespacesRemoveSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) NamespacesRemoveSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.NamespacesRemoveSubscriptionExpirationTime(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveSubscriptionExpirationTimeResponse(rsp)
}

// NamespacesGetSubscriptionExpirationTimeWithResponse request returning *NamespacesGetSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) NamespacesGetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.NamespacesGetSubscriptionExpirationTime(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetSubscriptionExpirationTimeResponse(rsp)
}

// NamespacesSetSubscriptionExpirationTimeWithBodyWithResponse request with arbitrary body returning *NamespacesSetSubscriptionExpirationTimeResponse
func (c *ClientWithResponses) NamespacesSetSubscriptionExpirationTimeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.NamespacesSetSubscriptionExpirationTimeWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscriptionExpirationTimeResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetSubscriptionExpirationTimeWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionExpirationTimeJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionExpirationTimeResponse, error) {
	rsp, err := c.NamespacesSetSubscriptionExpirationTime(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscriptionExpirationTimeResponse(rsp)
}

// NamespacesRemoveSubscriptionTypesEnabledWithResponse request returning *NamespacesRemoveSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) NamespacesRemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesRemoveSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.NamespacesRemoveSubscriptionTypesEnabled(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesRemoveSubscriptionTypesEnabledResponse(rsp)
}

// NamespacesGetSubscriptionTypesEnabledWithResponse request returning *NamespacesGetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) NamespacesGetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesGetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.NamespacesGetSubscriptionTypesEnabled(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetSubscriptionTypesEnabledResponse(rsp)
}

// NamespacesSetSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *NamespacesSetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) NamespacesSetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.NamespacesSetSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscriptionTypesEnabledResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, body NamespacesSetSubscriptionTypesEnabledJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.NamespacesSetSubscriptionTypesEnabled(ctx, tenant, namespace, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSetSubscriptionTypesEnabledResponse(rsp)
}

// NamespacesGetTopicsWithResponse request returning *NamespacesGetTopicsResponse
func (c *ClientWithResponses) NamespacesGetTopicsWithResponse(ctx context.Context, tenant string, namespace string, params *NamespacesGetTopicsParams, reqEditors ...RequestEditorFn) (*NamespacesGetTopicsResponse, error) {
	rsp, err := c.NamespacesGetTopics(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetTopicsResponse(rsp)
}

// NamespacesUnloadNamespaceWithResponse request returning *NamespacesUnloadNamespaceResponse
func (c *ClientWithResponses) NamespacesUnloadNamespaceWithResponse(ctx context.Context, tenant string, namespace string, reqEditors ...RequestEditorFn) (*NamespacesUnloadNamespaceResponse, error) {
	rsp, err := c.NamespacesUnloadNamespace(ctx, tenant, namespace, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesUnloadNamespaceResponse(rsp)
}

// NamespacesUnsubscribeNamespaceWithResponse request returning *NamespacesUnsubscribeNamespaceResponse
func (c *ClientWithResponses) NamespacesUnsubscribeNamespaceWithResponse(ctx context.Context, tenant string, namespace string, subscription string, params *NamespacesUnsubscribeNamespaceParams, reqEditors ...RequestEditorFn) (*NamespacesUnsubscribeNamespaceResponse, error) {
	rsp, err := c.NamespacesUnsubscribeNamespace(ctx, tenant, namespace, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesUnsubscribeNamespaceResponse(rsp)
}

// NamespacesDeleteNamespaceBundleWithResponse request returning *NamespacesDeleteNamespaceBundleResponse
func (c *ClientWithResponses) NamespacesDeleteNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesDeleteNamespaceBundleParams, reqEditors ...RequestEditorFn) (*NamespacesDeleteNamespaceBundleResponse, error) {
	rsp, err := c.NamespacesDeleteNamespaceBundle(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesDeleteNamespaceBundleResponse(rsp)
}

// NamespacesClearNamespaceBundleBacklogWithResponse request returning *NamespacesClearNamespaceBundleBacklogResponse
func (c *ClientWithResponses) NamespacesClearNamespaceBundleBacklogWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesClearNamespaceBundleBacklogParams, reqEditors ...RequestEditorFn) (*NamespacesClearNamespaceBundleBacklogResponse, error) {
	rsp, err := c.NamespacesClearNamespaceBundleBacklog(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesClearNamespaceBundleBacklogResponse(rsp)
}

// NamespacesClearNamespaceBundleBacklogForSubscriptionWithResponse request returning *NamespacesClearNamespaceBundleBacklogForSubscriptionResponse
func (c *ClientWithResponses) NamespacesClearNamespaceBundleBacklogForSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *NamespacesClearNamespaceBundleBacklogForSubscriptionParams, reqEditors ...RequestEditorFn) (*NamespacesClearNamespaceBundleBacklogForSubscriptionResponse, error) {
	rsp, err := c.NamespacesClearNamespaceBundleBacklogForSubscription(ctx, tenant, namespace, bundle, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesClearNamespaceBundleBacklogForSubscriptionResponse(rsp)
}

// NamespacesSplitNamespaceBundleWithBodyWithResponse request with arbitrary body returning *NamespacesSplitNamespaceBundleResponse
func (c *ClientWithResponses) NamespacesSplitNamespaceBundleWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NamespacesSplitNamespaceBundleResponse, error) {
	rsp, err := c.NamespacesSplitNamespaceBundleWithBody(ctx, tenant, namespace, bundle, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSplitNamespaceBundleResponse(rsp)
}

func (c *ClientWithResponses) NamespacesSplitNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesSplitNamespaceBundleParams, body NamespacesSplitNamespaceBundleJSONRequestBody, reqEditors ...RequestEditorFn) (*NamespacesSplitNamespaceBundleResponse, error) {
	rsp, err := c.NamespacesSplitNamespaceBundle(ctx, tenant, namespace, bundle, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesSplitNamespaceBundleResponse(rsp)
}

// NamespacesGetTopicHashPositionsWithResponse request returning *NamespacesGetTopicHashPositionsResponse
func (c *ClientWithResponses) NamespacesGetTopicHashPositionsWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesGetTopicHashPositionsParams, reqEditors ...RequestEditorFn) (*NamespacesGetTopicHashPositionsResponse, error) {
	rsp, err := c.NamespacesGetTopicHashPositions(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesGetTopicHashPositionsResponse(rsp)
}

// NamespacesUnloadNamespaceBundleWithResponse request returning *NamespacesUnloadNamespaceBundleResponse
func (c *ClientWithResponses) NamespacesUnloadNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, params *NamespacesUnloadNamespaceBundleParams, reqEditors ...RequestEditorFn) (*NamespacesUnloadNamespaceBundleResponse, error) {
	rsp, err := c.NamespacesUnloadNamespaceBundle(ctx, tenant, namespace, bundle, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesUnloadNamespaceBundleResponse(rsp)
}

// NamespacesUnsubscribeNamespaceBundleWithResponse request returning *NamespacesUnsubscribeNamespaceBundleResponse
func (c *ClientWithResponses) NamespacesUnsubscribeNamespaceBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, subscription string, params *NamespacesUnsubscribeNamespaceBundleParams, reqEditors ...RequestEditorFn) (*NamespacesUnsubscribeNamespaceBundleResponse, error) {
	rsp, err := c.NamespacesUnsubscribeNamespaceBundle(ctx, tenant, namespace, bundle, subscription, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNamespacesUnsubscribeNamespaceBundleResponse(rsp)
}

// NonPersistentTopicsGetListWithResponse request returning *NonPersistentTopicsGetListResponse
func (c *ClientWithResponses) NonPersistentTopicsGetListWithResponse(ctx context.Context, tenant string, namespace string, params *NonPersistentTopicsGetListParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetListResponse, error) {
	rsp, err := c.NonPersistentTopicsGetList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetListResponse(rsp)
}

// NonPersistentTopicsGetPartitionedTopicListWithResponse request returning *NonPersistentTopicsGetPartitionedTopicListResponse
func (c *ClientWithResponses) NonPersistentTopicsGetPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *NonPersistentTopicsGetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPartitionedTopicListResponse, error) {
	rsp, err := c.NonPersistentTopicsGetPartitionedTopicList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetPartitionedTopicListResponse(rsp)
}

// NonPersistentTopicsGetListFromBundleWithResponse request returning *NonPersistentTopicsGetListFromBundleResponse
func (c *ClientWithResponses) NonPersistentTopicsGetListFromBundleWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetListFromBundleResponse, error) {
	rsp, err := c.NonPersistentTopicsGetListFromBundle(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetListFromBundleResponse(rsp)
}

// NonPersistentTopicsDeleteTopicWithResponse request returning *NonPersistentTopicsDeleteTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsDeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsDeleteTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeleteTopicResponse(rsp)
}

// NonPersistentTopicsCreateNonPartitionedTopicWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsCreateNonPartitionedTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsCreateNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCreateNonPartitionedTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsCreateNonPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsCreateNonPartitionedTopicResponse(rsp)
}

// NonPersistentTopicsExpireMessagesForAllSubscriptionsWithResponse request returning *NonPersistentTopicsExpireMessagesForAllSubscriptionsResponse
func (c *ClientWithResponses) NonPersistentTopicsExpireMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsExpireMessagesForAllSubscriptionsResponse, error) {
	rsp, err := c.NonPersistentTopicsExpireMessagesForAllSubscriptions(ctx, tenant, namespace, topic, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsExpireMessagesForAllSubscriptionsResponse(rsp)
}

// NonPersistentTopicsRemoveAutoSubscriptionCreationWithResponse request returning *NonPersistentTopicsRemoveAutoSubscriptionCreationResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveAutoSubscriptionCreationResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveAutoSubscriptionCreation(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveAutoSubscriptionCreationResponse(rsp)
}

// NonPersistentTopicsGetAutoSubscriptionCreationWithResponse request returning *NonPersistentTopicsGetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) NonPersistentTopicsGetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.NonPersistentTopicsGetAutoSubscriptionCreation(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetAutoSubscriptionCreationResponse(rsp)
}

// NonPersistentTopicsSetAutoSubscriptionCreationWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) NonPersistentTopicsSetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.NonPersistentTopicsSetAutoSubscriptionCreationWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetAutoSubscriptionCreationResponse(rsp)
}

// NonPersistentTopicsGetBacklogWithResponse request returning *NonPersistentTopicsGetBacklogResponse
func (c *ClientWithResponses) NonPersistentTopicsGetBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetBacklogResponse, error) {
	rsp, err := c.NonPersistentTopicsGetBacklog(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetBacklogResponse(rsp)
}

// NonPersistentTopicsRemoveBacklogQuotaWithResponse request returning *NonPersistentTopicsRemoveBacklogQuotaResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveBacklogQuotaResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveBacklogQuotaResponse(rsp)
}

// NonPersistentTopicsSetBacklogQuotaWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetBacklogQuotaResponse
func (c *ClientWithResponses) NonPersistentTopicsSetBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetBacklogQuotaResponse, error) {
	rsp, err := c.NonPersistentTopicsSetBacklogQuotaWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetBacklogQuotaResponse(rsp)
}

// NonPersistentTopicsGetBacklogQuotaMapWithResponse request returning *NonPersistentTopicsGetBacklogQuotaMapResponse
func (c *ClientWithResponses) NonPersistentTopicsGetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetBacklogQuotaMapResponse, error) {
	rsp, err := c.NonPersistentTopicsGetBacklogQuotaMap(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetBacklogQuotaMapResponse(rsp)
}

// NonPersistentTopicsGetBacklogSizeByMessageIdWithResponse request returning *NonPersistentTopicsGetBacklogSizeByMessageIdResponse
func (c *ClientWithResponses) NonPersistentTopicsGetBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetBacklogSizeByMessageIdResponse, error) {
	rsp, err := c.NonPersistentTopicsGetBacklogSizeByMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetBacklogSizeByMessageIdResponse(rsp)
}

// NonPersistentTopicsCompactionStatusWithResponse request returning *NonPersistentTopicsCompactionStatusResponse
func (c *ClientWithResponses) NonPersistentTopicsCompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactionStatusParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCompactionStatusResponse, error) {
	rsp, err := c.NonPersistentTopicsCompactionStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsCompactionStatusResponse(rsp)
}

// NonPersistentTopicsCompactWithResponse request returning *NonPersistentTopicsCompactResponse
func (c *ClientWithResponses) NonPersistentTopicsCompactWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCompactParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCompactResponse, error) {
	rsp, err := c.NonPersistentTopicsCompact(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsCompactResponse(rsp)
}

// NonPersistentTopicsRemoveCompactionThresholdWithResponse request returning *NonPersistentTopicsRemoveCompactionThresholdResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveCompactionThresholdResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveCompactionThresholdResponse(rsp)
}

// NonPersistentTopicsGetCompactionThresholdWithResponse request returning *NonPersistentTopicsGetCompactionThresholdResponse
func (c *ClientWithResponses) NonPersistentTopicsGetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetCompactionThresholdResponse, error) {
	rsp, err := c.NonPersistentTopicsGetCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetCompactionThresholdResponse(rsp)
}

// NonPersistentTopicsSetCompactionThresholdWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetCompactionThresholdResponse
func (c *ClientWithResponses) NonPersistentTopicsSetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetCompactionThresholdResponse, error) {
	rsp, err := c.NonPersistentTopicsSetCompactionThresholdWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetCompactionThresholdResponse(rsp)
}

// NonPersistentTopicsCreateMissedPartitionsWithResponse request returning *NonPersistentTopicsCreateMissedPartitionsResponse
func (c *ClientWithResponses) NonPersistentTopicsCreateMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCreateMissedPartitionsResponse, error) {
	rsp, err := c.NonPersistentTopicsCreateMissedPartitions(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsCreateMissedPartitionsResponse(rsp)
}

// NonPersistentTopicsRemoveDeduplicationWithResponse request returning *NonPersistentTopicsRemoveDeduplicationResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveDeduplicationResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveDeduplicationResponse(rsp)
}

// NonPersistentTopicsGetDeduplicationWithResponse request returning *NonPersistentTopicsGetDeduplicationResponse
func (c *ClientWithResponses) NonPersistentTopicsGetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetDeduplicationResponse, error) {
	rsp, err := c.NonPersistentTopicsGetDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetDeduplicationResponse(rsp)
}

// NonPersistentTopicsSetDeduplicationWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetDeduplicationResponse
func (c *ClientWithResponses) NonPersistentTopicsSetDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetDeduplicationResponse, error) {
	rsp, err := c.NonPersistentTopicsSetDeduplicationWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetDeduplicationResponse(rsp)
}

// NonPersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse request returning *NonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) NonPersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.NonPersistentTopicsDeleteDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse(rsp)
}

// NonPersistentTopicsGetDeduplicationSnapshotIntervalWithResponse request returning *NonPersistentTopicsGetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) NonPersistentTopicsGetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.NonPersistentTopicsGetDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetDeduplicationSnapshotIntervalResponse(rsp)
}

// NonPersistentTopicsSetDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) NonPersistentTopicsSetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.NonPersistentTopicsSetDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetDeduplicationSnapshotIntervalResponse(rsp)
}

// NonPersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse request returning *NonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsDeleteDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse(rsp)
}

// NonPersistentTopicsGetDelayedDeliveryPoliciesWithResponse request returning *NonPersistentTopicsGetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsGetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsGetDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetDelayedDeliveryPoliciesResponse(rsp)
}

// NonPersistentTopicsSetDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsSetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsSetDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetDelayedDeliveryPoliciesResponse(rsp)
}

// NonPersistentTopicsRemoveDispatchRateWithResponse request returning *NonPersistentTopicsRemoveDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveDispatchRateResponse(rsp)
}

// NonPersistentTopicsGetDispatchRateWithResponse request returning *NonPersistentTopicsGetDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsGetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsGetDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetDispatchRateResponse(rsp)
}

// NonPersistentTopicsSetDispatchRateWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsSetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsSetDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetDispatchRateResponse(rsp)
}

// NonPersistentTopicsRemoveEntryFiltersWithResponse request returning *NonPersistentTopicsRemoveEntryFiltersResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveEntryFiltersResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveEntryFiltersResponse(rsp)
}

// NonPersistentTopicsGetEntryFiltersWithResponse request returning *NonPersistentTopicsGetEntryFiltersResponse
func (c *ClientWithResponses) NonPersistentTopicsGetEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetEntryFiltersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetEntryFiltersResponse, error) {
	rsp, err := c.NonPersistentTopicsGetEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetEntryFiltersResponse(rsp)
}

// NonPersistentTopicsSetEntryFiltersWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetEntryFiltersResponse
func (c *ClientWithResponses) NonPersistentTopicsSetEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetEntryFiltersResponse, error) {
	rsp, err := c.NonPersistentTopicsSetEntryFiltersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetEntryFiltersResponse(rsp)
}

// NonPersistentTopicsExamineMessageWithResponse request returning *NonPersistentTopicsExamineMessageResponse
func (c *ClientWithResponses) NonPersistentTopicsExamineMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsExamineMessageParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsExamineMessageResponse, error) {
	rsp, err := c.NonPersistentTopicsExamineMessage(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsExamineMessageResponse(rsp)
}

// NonPersistentTopicsDeleteInactiveTopicPoliciesWithResponse request returning *NonPersistentTopicsDeleteInactiveTopicPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsDeleteInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteInactiveTopicPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsDeleteInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeleteInactiveTopicPoliciesResponse(rsp)
}

// NonPersistentTopicsGetInactiveTopicPoliciesWithResponse request returning *NonPersistentTopicsGetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsGetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsGetInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetInactiveTopicPoliciesResponse(rsp)
}

// NonPersistentTopicsSetInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsSetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsSetInactiveTopicPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetInactiveTopicPoliciesResponse(rsp)
}

// NonPersistentTopicsGetManagedLedgerInfoWithResponse request returning *NonPersistentTopicsGetManagedLedgerInfoResponse
func (c *ClientWithResponses) NonPersistentTopicsGetManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetManagedLedgerInfoResponse, error) {
	rsp, err := c.NonPersistentTopicsGetManagedLedgerInfo(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetManagedLedgerInfoResponse(rsp)
}

// NonPersistentTopicsGetInternalStatsWithResponse request returning *NonPersistentTopicsGetInternalStatsResponse
func (c *ClientWithResponses) NonPersistentTopicsGetInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetInternalStatsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetInternalStatsResponse, error) {
	rsp, err := c.NonPersistentTopicsGetInternalStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetInternalStatsResponse(rsp)
}

// NonPersistentTopicsGetLastMessageIdWithResponse request returning *NonPersistentTopicsGetLastMessageIdResponse
func (c *ClientWithResponses) NonPersistentTopicsGetLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetLastMessageIdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetLastMessageIdResponse, error) {
	rsp, err := c.NonPersistentTopicsGetLastMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetLastMessageIdResponse(rsp)
}

// NonPersistentTopicsGetMessageByIdWithResponse request returning *NonPersistentTopicsGetMessageByIdResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *NonPersistentTopicsGetMessageByIdParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMessageByIdResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMessageById(ctx, tenant, namespace, topic, ledgerId, entryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMessageByIdResponse(rsp)
}

// NonPersistentTopicsRemoveMaxConsumersWithResponse request returning *NonPersistentTopicsRemoveMaxConsumersResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxConsumersResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveMaxConsumersResponse(rsp)
}

// NonPersistentTopicsGetMaxConsumersWithResponse request returning *NonPersistentTopicsGetMaxConsumersResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxConsumersResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMaxConsumersResponse(rsp)
}

// NonPersistentTopicsSetMaxConsumersWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetMaxConsumersResponse
func (c *ClientWithResponses) NonPersistentTopicsSetMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxConsumersResponse, error) {
	rsp, err := c.NonPersistentTopicsSetMaxConsumersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetMaxConsumersResponse(rsp)
}

// NonPersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse request returning *NonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse(rsp)
}

// NonPersistentTopicsGetMaxConsumersPerSubscriptionWithResponse request returning *NonPersistentTopicsGetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMaxConsumersPerSubscriptionResponse(rsp)
}

// NonPersistentTopicsSetMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) NonPersistentTopicsSetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.NonPersistentTopicsSetMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetMaxConsumersPerSubscriptionResponse(rsp)
}

// NonPersistentTopicsRemoveMaxMessageSizeWithResponse request returning *NonPersistentTopicsRemoveMaxMessageSizeResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxMessageSizeResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveMaxMessageSizeResponse(rsp)
}

// NonPersistentTopicsGetMaxMessageSizeWithResponse request returning *NonPersistentTopicsGetMaxMessageSizeResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxMessageSizeResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMaxMessageSizeResponse(rsp)
}

// NonPersistentTopicsSetMaxMessageSizeWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetMaxMessageSizeResponse
func (c *ClientWithResponses) NonPersistentTopicsSetMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxMessageSizeResponse, error) {
	rsp, err := c.NonPersistentTopicsSetMaxMessageSizeWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetMaxMessageSizeResponse(rsp)
}

// NonPersistentTopicsRemoveMaxProducersWithResponse request returning *NonPersistentTopicsRemoveMaxProducersResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxProducersResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveMaxProducersResponse(rsp)
}

// NonPersistentTopicsGetMaxProducersWithResponse request returning *NonPersistentTopicsGetMaxProducersResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxProducersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxProducersResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMaxProducersResponse(rsp)
}

// NonPersistentTopicsSetMaxProducersWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetMaxProducersResponse
func (c *ClientWithResponses) NonPersistentTopicsSetMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxProducersResponse, error) {
	rsp, err := c.NonPersistentTopicsSetMaxProducersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetMaxProducersResponse(rsp)
}

// NonPersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse request returning *NonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse(rsp)
}

// NonPersistentTopicsGetMaxSubscriptionsPerTopicWithResponse request returning *NonPersistentTopicsGetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMaxSubscriptionsPerTopicResponse(rsp)
}

// NonPersistentTopicsSetMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsSetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsSetMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetMaxSubscriptionsPerTopicResponse(rsp)
}

// NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse request returning *NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse(rsp)
}

// NonPersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse request returning *NonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse(rsp)
}

// NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse(rsp)
}

// NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse request returning *NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse request returning *NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// NonPersistentTopicsRemoveMessageTTLWithResponse request returning *NonPersistentTopicsRemoveMessageTTLResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveMessageTTLResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveMessageTTLResponse(rsp)
}

// NonPersistentTopicsGetMessageTTLWithResponse request returning *NonPersistentTopicsGetMessageTTLResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetMessageTTLParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMessageTTLResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMessageTTLResponse(rsp)
}

// NonPersistentTopicsSetMessageTTLWithResponse request returning *NonPersistentTopicsSetMessageTTLResponse
func (c *ClientWithResponses) NonPersistentTopicsSetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetMessageTTLParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetMessageTTLResponse, error) {
	rsp, err := c.NonPersistentTopicsSetMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetMessageTTLResponse(rsp)
}

// NonPersistentTopicsGetMessageIdByTimestampWithResponse request returning *NonPersistentTopicsGetMessageIdByTimestampResponse
func (c *ClientWithResponses) NonPersistentTopicsGetMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *NonPersistentTopicsGetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetMessageIdByTimestampResponse, error) {
	rsp, err := c.NonPersistentTopicsGetMessageIdByTimestamp(ctx, tenant, namespace, topic, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetMessageIdByTimestampResponse(rsp)
}

// NonPersistentTopicsOffloadStatusWithResponse request returning *NonPersistentTopicsOffloadStatusResponse
func (c *ClientWithResponses) NonPersistentTopicsOffloadStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsOffloadStatusParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsOffloadStatusResponse, error) {
	rsp, err := c.NonPersistentTopicsOffloadStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsOffloadStatusResponse(rsp)
}

// NonPersistentTopicsTriggerOffloadWithResponse request returning *NonPersistentTopicsTriggerOffloadResponse
func (c *ClientWithResponses) NonPersistentTopicsTriggerOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTriggerOffloadParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTriggerOffloadResponse, error) {
	rsp, err := c.NonPersistentTopicsTriggerOffload(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsTriggerOffloadResponse(rsp)
}

// NonPersistentTopicsRemoveOffloadPoliciesWithResponse request returning *NonPersistentTopicsRemoveOffloadPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveOffloadPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveOffloadPoliciesResponse(rsp)
}

// NonPersistentTopicsGetOffloadPoliciesWithResponse request returning *NonPersistentTopicsGetOffloadPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsGetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetOffloadPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsGetOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetOffloadPoliciesResponse(rsp)
}

// NonPersistentTopicsSetOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetOffloadPoliciesResponse
func (c *ClientWithResponses) NonPersistentTopicsSetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetOffloadPoliciesResponse, error) {
	rsp, err := c.NonPersistentTopicsSetOffloadPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetOffloadPoliciesResponse(rsp)
}

// NonPersistentTopicsGetPartitionedStatsInternalWithResponse request returning *NonPersistentTopicsGetPartitionedStatsInternalResponse
func (c *ClientWithResponses) NonPersistentTopicsGetPartitionedStatsInternalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsInternalParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPartitionedStatsInternalResponse, error) {
	rsp, err := c.NonPersistentTopicsGetPartitionedStatsInternal(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetPartitionedStatsInternalResponse(rsp)
}

// NonPersistentTopicsGetPartitionedStatsWithResponse request returning *NonPersistentTopicsGetPartitionedStatsResponse
func (c *ClientWithResponses) NonPersistentTopicsGetPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPartitionedStatsResponse, error) {
	rsp, err := c.NonPersistentTopicsGetPartitionedStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetPartitionedStatsResponse(rsp)
}

// NonPersistentTopicsDeletePartitionedTopicWithResponse request returning *NonPersistentTopicsDeletePartitionedTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsDeletePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeletePartitionedTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsDeletePartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeletePartitionedTopicResponse(rsp)
}

// NonPersistentTopicsGetPartitionedMetadataWithResponse request returning *NonPersistentTopicsGetPartitionedMetadataResponse
func (c *ClientWithResponses) NonPersistentTopicsGetPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPartitionedMetadataResponse, error) {
	rsp, err := c.NonPersistentTopicsGetPartitionedMetadata(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetPartitionedMetadataResponse(rsp)
}

// NonPersistentTopicsUpdatePartitionedTopicWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsUpdatePartitionedTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsUpdatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsUpdatePartitionedTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsUpdatePartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsUpdatePartitionedTopicResponse(rsp)
}

// NonPersistentTopicsCreatePartitionedTopicWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsCreatePartitionedTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsCreatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCreatePartitionedTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsCreatePartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsCreatePartitionedTopicResponse(rsp)
}

// NonPersistentTopicsGetPermissionsOnTopicWithResponse request returning *NonPersistentTopicsGetPermissionsOnTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsGetPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPermissionsOnTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsGetPermissionsOnTopic(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetPermissionsOnTopicResponse(rsp)
}

// NonPersistentTopicsRevokePermissionsOnTopicWithResponse request returning *NonPersistentTopicsRevokePermissionsOnTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsRevokePermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRevokePermissionsOnTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsRevokePermissionsOnTopic(ctx, tenant, namespace, topic, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRevokePermissionsOnTopicResponse(rsp)
}

// NonPersistentTopicsGrantPermissionsOnTopicWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsGrantPermissionsOnTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsGrantPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGrantPermissionsOnTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsGrantPermissionsOnTopicWithBody(ctx, tenant, namespace, topic, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGrantPermissionsOnTopicResponse(rsp)
}

// NonPersistentTopicsRemovePersistenceWithResponse request returning *NonPersistentTopicsRemovePersistenceResponse
func (c *ClientWithResponses) NonPersistentTopicsRemovePersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePersistenceParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemovePersistenceResponse, error) {
	rsp, err := c.NonPersistentTopicsRemovePersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemovePersistenceResponse(rsp)
}

// NonPersistentTopicsGetPersistenceWithResponse request returning *NonPersistentTopicsGetPersistenceResponse
func (c *ClientWithResponses) NonPersistentTopicsGetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPersistenceParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPersistenceResponse, error) {
	rsp, err := c.NonPersistentTopicsGetPersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetPersistenceResponse(rsp)
}

// NonPersistentTopicsSetPersistenceWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetPersistenceResponse
func (c *ClientWithResponses) NonPersistentTopicsSetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetPersistenceResponse, error) {
	rsp, err := c.NonPersistentTopicsSetPersistenceWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetPersistenceResponse(rsp)
}

// NonPersistentTopicsRemovePropertiesWithResponse request returning *NonPersistentTopicsRemovePropertiesResponse
func (c *ClientWithResponses) NonPersistentTopicsRemovePropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePropertiesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemovePropertiesResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemovePropertiesResponse(rsp)
}

// NonPersistentTopicsGetPropertiesWithResponse request returning *NonPersistentTopicsGetPropertiesResponse
func (c *ClientWithResponses) NonPersistentTopicsGetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPropertiesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPropertiesResponse, error) {
	rsp, err := c.NonPersistentTopicsGetProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetPropertiesResponse(rsp)
}

// NonPersistentTopicsUpdatePropertiesWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsUpdatePropertiesResponse
func (c *ClientWithResponses) NonPersistentTopicsUpdatePropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsUpdatePropertiesResponse, error) {
	rsp, err := c.NonPersistentTopicsUpdatePropertiesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsUpdatePropertiesResponse(rsp)
}

// NonPersistentTopicsRemovePublishRateWithResponse request returning *NonPersistentTopicsRemovePublishRateResponse
func (c *ClientWithResponses) NonPersistentTopicsRemovePublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemovePublishRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemovePublishRateResponse, error) {
	rsp, err := c.NonPersistentTopicsRemovePublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemovePublishRateResponse(rsp)
}

// NonPersistentTopicsGetPublishRateWithResponse request returning *NonPersistentTopicsGetPublishRateResponse
func (c *ClientWithResponses) NonPersistentTopicsGetPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetPublishRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetPublishRateResponse, error) {
	rsp, err := c.NonPersistentTopicsGetPublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetPublishRateResponse(rsp)
}

// NonPersistentTopicsSetPublishRateWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetPublishRateResponse
func (c *ClientWithResponses) NonPersistentTopicsSetPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetPublishRateResponse, error) {
	rsp, err := c.NonPersistentTopicsSetPublishRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetPublishRateResponse(rsp)
}

// NonPersistentTopicsRemoveReplicationClustersWithResponse request returning *NonPersistentTopicsRemoveReplicationClustersResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveReplicationClustersResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveReplicationClustersResponse(rsp)
}

// NonPersistentTopicsGetReplicationClustersWithResponse request returning *NonPersistentTopicsGetReplicationClustersResponse
func (c *ClientWithResponses) NonPersistentTopicsGetReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicationClustersParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetReplicationClustersResponse, error) {
	rsp, err := c.NonPersistentTopicsGetReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetReplicationClustersResponse(rsp)
}

// NonPersistentTopicsSetReplicationClustersWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetReplicationClustersResponse
func (c *ClientWithResponses) NonPersistentTopicsSetReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetReplicationClustersResponse, error) {
	rsp, err := c.NonPersistentTopicsSetReplicationClustersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetReplicationClustersResponse(rsp)
}

// NonPersistentTopicsRemoveReplicatorDispatchRateWithResponse request returning *NonPersistentTopicsRemoveReplicatorDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveReplicatorDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveReplicatorDispatchRateResponse(rsp)
}

// NonPersistentTopicsGetReplicatorDispatchRateWithResponse request returning *NonPersistentTopicsGetReplicatorDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsGetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetReplicatorDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsGetReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetReplicatorDispatchRateResponse(rsp)
}

// NonPersistentTopicsSetReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetReplicatorDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsSetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetReplicatorDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsSetReplicatorDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetReplicatorDispatchRateResponse(rsp)
}

// NonPersistentTopicsRemoveRetentionWithResponse request returning *NonPersistentTopicsRemoveRetentionResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveRetentionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveRetentionResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveRetentionResponse(rsp)
}

// NonPersistentTopicsGetRetentionWithResponse request returning *NonPersistentTopicsGetRetentionResponse
func (c *ClientWithResponses) NonPersistentTopicsGetRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetRetentionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetRetentionResponse, error) {
	rsp, err := c.NonPersistentTopicsGetRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetRetentionResponse(rsp)
}

// NonPersistentTopicsSetRetentionWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetRetentionResponse
func (c *ClientWithResponses) NonPersistentTopicsSetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetRetentionResponse, error) {
	rsp, err := c.NonPersistentTopicsSetRetentionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetRetentionResponse(rsp)
}

// NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse(rsp)
}

// NonPersistentTopicsGetSchemaCompatibilityStrategyWithResponse request returning *NonPersistentTopicsGetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) NonPersistentTopicsGetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.NonPersistentTopicsGetSchemaCompatibilityStrategy(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetSchemaCompatibilityStrategyResponse(rsp)
}

// NonPersistentTopicsSetSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) NonPersistentTopicsSetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.NonPersistentTopicsSetSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetSchemaCompatibilityStrategyResponse(rsp)
}

// NonPersistentTopicsGetSchemaValidationEnforcedWithResponse request returning *NonPersistentTopicsGetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) NonPersistentTopicsGetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.NonPersistentTopicsGetSchemaValidationEnforced(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetSchemaValidationEnforcedResponse(rsp)
}

// NonPersistentTopicsSetSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) NonPersistentTopicsSetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.NonPersistentTopicsSetSchemaValidationEnforcedWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetSchemaValidationEnforcedResponse(rsp)
}

// NonPersistentTopicsDeleteShadowTopicsWithResponse request returning *NonPersistentTopicsDeleteShadowTopicsResponse
func (c *ClientWithResponses) NonPersistentTopicsDeleteShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsDeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteShadowTopicsResponse, error) {
	rsp, err := c.NonPersistentTopicsDeleteShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeleteShadowTopicsResponse(rsp)
}

// NonPersistentTopicsGetShadowTopicsWithResponse request returning *NonPersistentTopicsGetShadowTopicsResponse
func (c *ClientWithResponses) NonPersistentTopicsGetShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetShadowTopicsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetShadowTopicsResponse, error) {
	rsp, err := c.NonPersistentTopicsGetShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetShadowTopicsResponse(rsp)
}

// NonPersistentTopicsSetShadowTopicsWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetShadowTopicsResponse
func (c *ClientWithResponses) NonPersistentTopicsSetShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetShadowTopicsResponse, error) {
	rsp, err := c.NonPersistentTopicsSetShadowTopicsWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetShadowTopicsResponse(rsp)
}

// NonPersistentTopicsGetStatsWithResponse request returning *NonPersistentTopicsGetStatsResponse
func (c *ClientWithResponses) NonPersistentTopicsGetStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetStatsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetStatsResponse, error) {
	rsp, err := c.NonPersistentTopicsGetStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetStatsResponse(rsp)
}

// NonPersistentTopicsRemoveSubscribeRateWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsRemoveSubscribeRateResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSubscribeRateResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveSubscribeRateResponse(rsp)
}

// NonPersistentTopicsGetSubscribeRateWithResponse request returning *NonPersistentTopicsGetSubscribeRateResponse
func (c *ClientWithResponses) NonPersistentTopicsGetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscribeRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscribeRateResponse, error) {
	rsp, err := c.NonPersistentTopicsGetSubscribeRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetSubscribeRateResponse(rsp)
}

// NonPersistentTopicsSetSubscribeRateWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetSubscribeRateResponse
func (c *ClientWithResponses) NonPersistentTopicsSetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSubscribeRateResponse, error) {
	rsp, err := c.NonPersistentTopicsSetSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetSubscribeRateResponse(rsp)
}

// NonPersistentTopicsDeleteSubscriptionWithResponse request returning *NonPersistentTopicsDeleteSubscriptionResponse
func (c *ClientWithResponses) NonPersistentTopicsDeleteSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsDeleteSubscriptionResponse, error) {
	rsp, err := c.NonPersistentTopicsDeleteSubscription(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsDeleteSubscriptionResponse(rsp)
}

// NonPersistentTopicsAnalyzeSubscriptionBacklogWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsAnalyzeSubscriptionBacklogResponse
func (c *ClientWithResponses) NonPersistentTopicsAnalyzeSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsAnalyzeSubscriptionBacklogResponse, error) {
	rsp, err := c.NonPersistentTopicsAnalyzeSubscriptionBacklogWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsAnalyzeSubscriptionBacklogResponse(rsp)
}

// NonPersistentTopicsExpireTopicMessagesWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsExpireTopicMessagesResponse
func (c *ClientWithResponses) NonPersistentTopicsExpireTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsExpireTopicMessagesResponse, error) {
	rsp, err := c.NonPersistentTopicsExpireTopicMessagesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsExpireTopicMessagesResponse(rsp)
}

// NonPersistentTopicsExpireTopicMessagesExpireTimeWithResponse request returning *NonPersistentTopicsExpireTopicMessagesExpireTimeResponse
func (c *ClientWithResponses) NonPersistentTopicsExpireTopicMessagesExpireTimeWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *NonPersistentTopicsExpireTopicMessagesExpireTimeParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsExpireTopicMessagesExpireTimeResponse, error) {
	rsp, err := c.NonPersistentTopicsExpireTopicMessagesExpireTime(ctx, tenant, namespace, topic, subName, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsExpireTopicMessagesExpireTimeResponse(rsp)
}

// NonPersistentTopicsPeekNthMessageWithResponse request returning *NonPersistentTopicsPeekNthMessageResponse
func (c *ClientWithResponses) NonPersistentTopicsPeekNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *NonPersistentTopicsPeekNthMessageParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsPeekNthMessageResponse, error) {
	rsp, err := c.NonPersistentTopicsPeekNthMessage(ctx, tenant, namespace, topic, subName, messagePosition, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsPeekNthMessageResponse(rsp)
}

// NonPersistentTopicsGetSubscriptionPropertiesWithResponse request returning *NonPersistentTopicsGetSubscriptionPropertiesResponse
func (c *ClientWithResponses) NonPersistentTopicsGetSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionPropertiesResponse, error) {
	rsp, err := c.NonPersistentTopicsGetSubscriptionProperties(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetSubscriptionPropertiesResponse(rsp)
}

// NonPersistentTopicsUpdateSubscriptionPropertiesWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsUpdateSubscriptionPropertiesResponse
func (c *ClientWithResponses) NonPersistentTopicsUpdateSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsUpdateSubscriptionPropertiesResponse, error) {
	rsp, err := c.NonPersistentTopicsUpdateSubscriptionPropertiesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsUpdateSubscriptionPropertiesResponse(rsp)
}

// NonPersistentTopicsGetReplicatedSubscriptionStatusWithResponse request returning *NonPersistentTopicsGetReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) NonPersistentTopicsGetReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.NonPersistentTopicsGetReplicatedSubscriptionStatus(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetReplicatedSubscriptionStatusResponse(rsp)
}

// NonPersistentTopicsSetReplicatedSubscriptionStatusWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) NonPersistentTopicsSetReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.NonPersistentTopicsSetReplicatedSubscriptionStatusWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetReplicatedSubscriptionStatusResponse(rsp)
}

// NonPersistentTopicsResetCursorOnPositionWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsResetCursorOnPositionResponse
func (c *ClientWithResponses) NonPersistentTopicsResetCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsResetCursorOnPositionResponse, error) {
	rsp, err := c.NonPersistentTopicsResetCursorOnPositionWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsResetCursorOnPositionResponse(rsp)
}

// NonPersistentTopicsResetCursorWithResponse request returning *NonPersistentTopicsResetCursorResponse
func (c *ClientWithResponses) NonPersistentTopicsResetCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *NonPersistentTopicsResetCursorParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsResetCursorResponse, error) {
	rsp, err := c.NonPersistentTopicsResetCursor(ctx, tenant, namespace, topic, subName, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsResetCursorResponse(rsp)
}

// NonPersistentTopicsSkipMessagesWithResponse request returning *NonPersistentTopicsSkipMessagesResponse
func (c *ClientWithResponses) NonPersistentTopicsSkipMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *NonPersistentTopicsSkipMessagesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSkipMessagesResponse, error) {
	rsp, err := c.NonPersistentTopicsSkipMessages(ctx, tenant, namespace, topic, subName, numMessages, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSkipMessagesResponse(rsp)
}

// NonPersistentTopicsSkipAllMessagesWithResponse request returning *NonPersistentTopicsSkipAllMessagesResponse
func (c *ClientWithResponses) NonPersistentTopicsSkipAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSkipAllMessagesParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSkipAllMessagesResponse, error) {
	rsp, err := c.NonPersistentTopicsSkipAllMessages(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSkipAllMessagesResponse(rsp)
}

// NonPersistentTopicsCreateSubscriptionWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsCreateSubscriptionResponse
func (c *ClientWithResponses) NonPersistentTopicsCreateSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *NonPersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsCreateSubscriptionResponse, error) {
	rsp, err := c.NonPersistentTopicsCreateSubscriptionWithBody(ctx, tenant, namespace, topic, subscriptionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsCreateSubscriptionResponse(rsp)
}

// NonPersistentTopicsRemoveSubscriptionDispatchRateWithResponse request returning *NonPersistentTopicsRemoveSubscriptionDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSubscriptionDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveSubscriptionDispatchRateResponse(rsp)
}

// NonPersistentTopicsGetSubscriptionDispatchRateWithResponse request returning *NonPersistentTopicsGetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsGetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsGetSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetSubscriptionDispatchRateResponse(rsp)
}

// NonPersistentTopicsSetSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsSetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsSetSubscriptionDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetSubscriptionDispatchRateResponse(rsp)
}

// NonPersistentTopicsRemoveSubscriptionTypesEnabledWithResponse request returning *NonPersistentTopicsRemoveSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsRemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveSubscriptionTypesEnabledResponse(rsp)
}

// NonPersistentTopicsGetSubscriptionTypesEnabledWithResponse request returning *NonPersistentTopicsGetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) NonPersistentTopicsGetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.NonPersistentTopicsGetSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetSubscriptionTypesEnabledResponse(rsp)
}

// NonPersistentTopicsSetSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) NonPersistentTopicsSetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.NonPersistentTopicsSetSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetSubscriptionTypesEnabledResponse(rsp)
}

// NonPersistentTopicsGetSubscriptionsWithResponse request returning *NonPersistentTopicsGetSubscriptionsResponse
func (c *ClientWithResponses) NonPersistentTopicsGetSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsGetSubscriptionsParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionsResponse, error) {
	rsp, err := c.NonPersistentTopicsGetSubscriptions(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetSubscriptionsResponse(rsp)
}

// NonPersistentTopicsTerminateWithResponse request returning *NonPersistentTopicsTerminateResponse
func (c *ClientWithResponses) NonPersistentTopicsTerminateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTerminateResponse, error) {
	rsp, err := c.NonPersistentTopicsTerminate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsTerminateResponse(rsp)
}

// NonPersistentTopicsTerminatePartitionedTopicWithResponse request returning *NonPersistentTopicsTerminatePartitionedTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsTerminatePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTerminatePartitionedTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsTerminatePartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsTerminatePartitionedTopicResponse(rsp)
}

// NonPersistentTopicsTrimTopicWithResponse request returning *NonPersistentTopicsTrimTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsTrimTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTrimTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTrimTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsTrimTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsTrimTopicResponse(rsp)
}

// NonPersistentTopicsTruncateTopicWithResponse request returning *NonPersistentTopicsTruncateTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsTruncateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsTruncateTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsTruncateTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsTruncateTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsTruncateTopicResponse(rsp)
}

// NonPersistentTopicsUnloadTopicWithResponse request returning *NonPersistentTopicsUnloadTopicResponse
func (c *ClientWithResponses) NonPersistentTopicsUnloadTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *NonPersistentTopicsUnloadTopicParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsUnloadTopicResponse, error) {
	rsp, err := c.NonPersistentTopicsUnloadTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsUnloadTopicResponse(rsp)
}

// NonPersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse request returning *NonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsRemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsRemoveSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse(rsp)
}

// NonPersistentTopicsGetSubscriptionLevelDispatchRateWithResponse request returning *NonPersistentTopicsGetSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsGetSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsGetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*NonPersistentTopicsGetSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsGetSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsGetSubscriptionLevelDispatchRateResponse(rsp)
}

// NonPersistentTopicsSetSubscriptionLevelDispatchRateWithBodyWithResponse request with arbitrary body returning *NonPersistentTopicsSetSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) NonPersistentTopicsSetSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *NonPersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*NonPersistentTopicsSetSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.NonPersistentTopicsSetSubscriptionLevelDispatchRateWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseNonPersistentTopicsSetSubscriptionLevelDispatchRateResponse(rsp)
}

// PersistentTopicsGetListWithResponse request returning *PersistentTopicsGetListResponse
func (c *ClientWithResponses) PersistentTopicsGetListWithResponse(ctx context.Context, tenant string, namespace string, params *PersistentTopicsGetListParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetListResponse, error) {
	rsp, err := c.PersistentTopicsGetList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetListResponse(rsp)
}

// PersistentTopicsGetPartitionedTopicListWithResponse request returning *PersistentTopicsGetPartitionedTopicListResponse
func (c *ClientWithResponses) PersistentTopicsGetPartitionedTopicListWithResponse(ctx context.Context, tenant string, namespace string, params *PersistentTopicsGetPartitionedTopicListParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPartitionedTopicListResponse, error) {
	rsp, err := c.PersistentTopicsGetPartitionedTopicList(ctx, tenant, namespace, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetPartitionedTopicListResponse(rsp)
}

// PersistentTopicsDeleteTopicWithResponse request returning *PersistentTopicsDeleteTopicResponse
func (c *ClientWithResponses) PersistentTopicsDeleteTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteTopicResponse, error) {
	rsp, err := c.PersistentTopicsDeleteTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeleteTopicResponse(rsp)
}

// PersistentTopicsCreateNonPartitionedTopicWithBodyWithResponse request with arbitrary body returning *PersistentTopicsCreateNonPartitionedTopicResponse
func (c *ClientWithResponses) PersistentTopicsCreateNonPartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCreateNonPartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsCreateNonPartitionedTopicResponse, error) {
	rsp, err := c.PersistentTopicsCreateNonPartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsCreateNonPartitionedTopicResponse(rsp)
}

// PersistentTopicsExpireMessagesForAllSubscriptionsWithResponse request returning *PersistentTopicsExpireMessagesForAllSubscriptionsResponse
func (c *ClientWithResponses) PersistentTopicsExpireMessagesForAllSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, expireTimeInSeconds int32, params *PersistentTopicsExpireMessagesForAllSubscriptionsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsExpireMessagesForAllSubscriptionsResponse, error) {
	rsp, err := c.PersistentTopicsExpireMessagesForAllSubscriptions(ctx, tenant, namespace, topic, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsExpireMessagesForAllSubscriptionsResponse(rsp)
}

// PersistentTopicsRemoveAutoSubscriptionCreationWithResponse request returning *PersistentTopicsRemoveAutoSubscriptionCreationResponse
func (c *ClientWithResponses) PersistentTopicsRemoveAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveAutoSubscriptionCreationResponse, error) {
	rsp, err := c.PersistentTopicsRemoveAutoSubscriptionCreation(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveAutoSubscriptionCreationResponse(rsp)
}

// PersistentTopicsGetAutoSubscriptionCreationWithResponse request returning *PersistentTopicsGetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) PersistentTopicsGetAutoSubscriptionCreationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetAutoSubscriptionCreationParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.PersistentTopicsGetAutoSubscriptionCreation(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetAutoSubscriptionCreationResponse(rsp)
}

// PersistentTopicsSetAutoSubscriptionCreationWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetAutoSubscriptionCreationResponse
func (c *ClientWithResponses) PersistentTopicsSetAutoSubscriptionCreationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetAutoSubscriptionCreationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetAutoSubscriptionCreationResponse, error) {
	rsp, err := c.PersistentTopicsSetAutoSubscriptionCreationWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetAutoSubscriptionCreationResponse(rsp)
}

// PersistentTopicsGetBacklogWithResponse request returning *PersistentTopicsGetBacklogResponse
func (c *ClientWithResponses) PersistentTopicsGetBacklogWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetBacklogResponse, error) {
	rsp, err := c.PersistentTopicsGetBacklog(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetBacklogResponse(rsp)
}

// PersistentTopicsRemoveBacklogQuotaWithResponse request returning *PersistentTopicsRemoveBacklogQuotaResponse
func (c *ClientWithResponses) PersistentTopicsRemoveBacklogQuotaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveBacklogQuotaParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveBacklogQuotaResponse, error) {
	rsp, err := c.PersistentTopicsRemoveBacklogQuota(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveBacklogQuotaResponse(rsp)
}

// PersistentTopicsSetBacklogQuotaWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetBacklogQuotaResponse
func (c *ClientWithResponses) PersistentTopicsSetBacklogQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetBacklogQuotaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetBacklogQuotaResponse, error) {
	rsp, err := c.PersistentTopicsSetBacklogQuotaWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetBacklogQuotaResponse(rsp)
}

// PersistentTopicsGetBacklogQuotaMapWithResponse request returning *PersistentTopicsGetBacklogQuotaMapResponse
func (c *ClientWithResponses) PersistentTopicsGetBacklogQuotaMapWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogQuotaMapParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetBacklogQuotaMapResponse, error) {
	rsp, err := c.PersistentTopicsGetBacklogQuotaMap(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetBacklogQuotaMapResponse(rsp)
}

// PersistentTopicsGetBacklogSizeByMessageIdWithResponse request returning *PersistentTopicsGetBacklogSizeByMessageIdResponse
func (c *ClientWithResponses) PersistentTopicsGetBacklogSizeByMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetBacklogSizeByMessageIdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetBacklogSizeByMessageIdResponse, error) {
	rsp, err := c.PersistentTopicsGetBacklogSizeByMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetBacklogSizeByMessageIdResponse(rsp)
}

// PersistentTopicsCompactionStatusWithResponse request returning *PersistentTopicsCompactionStatusResponse
func (c *ClientWithResponses) PersistentTopicsCompactionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCompactionStatusParams, reqEditors ...RequestEditorFn) (*PersistentTopicsCompactionStatusResponse, error) {
	rsp, err := c.PersistentTopicsCompactionStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsCompactionStatusResponse(rsp)
}

// PersistentTopicsCompactWithResponse request returning *PersistentTopicsCompactResponse
func (c *ClientWithResponses) PersistentTopicsCompactWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCompactParams, reqEditors ...RequestEditorFn) (*PersistentTopicsCompactResponse, error) {
	rsp, err := c.PersistentTopicsCompact(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsCompactResponse(rsp)
}

// PersistentTopicsRemoveCompactionThresholdWithResponse request returning *PersistentTopicsRemoveCompactionThresholdResponse
func (c *ClientWithResponses) PersistentTopicsRemoveCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveCompactionThresholdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveCompactionThresholdResponse, error) {
	rsp, err := c.PersistentTopicsRemoveCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveCompactionThresholdResponse(rsp)
}

// PersistentTopicsGetCompactionThresholdWithResponse request returning *PersistentTopicsGetCompactionThresholdResponse
func (c *ClientWithResponses) PersistentTopicsGetCompactionThresholdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetCompactionThresholdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetCompactionThresholdResponse, error) {
	rsp, err := c.PersistentTopicsGetCompactionThreshold(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetCompactionThresholdResponse(rsp)
}

// PersistentTopicsSetCompactionThresholdWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetCompactionThresholdResponse
func (c *ClientWithResponses) PersistentTopicsSetCompactionThresholdWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetCompactionThresholdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetCompactionThresholdResponse, error) {
	rsp, err := c.PersistentTopicsSetCompactionThresholdWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetCompactionThresholdResponse(rsp)
}

// PersistentTopicsCreateMissedPartitionsWithResponse request returning *PersistentTopicsCreateMissedPartitionsResponse
func (c *ClientWithResponses) PersistentTopicsCreateMissedPartitionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*PersistentTopicsCreateMissedPartitionsResponse, error) {
	rsp, err := c.PersistentTopicsCreateMissedPartitions(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsCreateMissedPartitionsResponse(rsp)
}

// PersistentTopicsRemoveDeduplicationWithResponse request returning *PersistentTopicsRemoveDeduplicationResponse
func (c *ClientWithResponses) PersistentTopicsRemoveDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDeduplicationParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveDeduplicationResponse, error) {
	rsp, err := c.PersistentTopicsRemoveDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveDeduplicationResponse(rsp)
}

// PersistentTopicsGetDeduplicationWithResponse request returning *PersistentTopicsGetDeduplicationResponse
func (c *ClientWithResponses) PersistentTopicsGetDeduplicationWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetDeduplicationResponse, error) {
	rsp, err := c.PersistentTopicsGetDeduplication(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetDeduplicationResponse(rsp)
}

// PersistentTopicsSetDeduplicationWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetDeduplicationResponse
func (c *ClientWithResponses) PersistentTopicsSetDeduplicationWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetDeduplicationResponse, error) {
	rsp, err := c.PersistentTopicsSetDeduplicationWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetDeduplicationResponse(rsp)
}

// PersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse request returning *PersistentTopicsDeleteDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) PersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.PersistentTopicsDeleteDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeleteDeduplicationSnapshotIntervalResponse(rsp)
}

// PersistentTopicsGetDeduplicationSnapshotIntervalWithResponse request returning *PersistentTopicsGetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) PersistentTopicsGetDeduplicationSnapshotIntervalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDeduplicationSnapshotIntervalParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.PersistentTopicsGetDeduplicationSnapshotInterval(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetDeduplicationSnapshotIntervalResponse(rsp)
}

// PersistentTopicsSetDeduplicationSnapshotIntervalWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetDeduplicationSnapshotIntervalResponse
func (c *ClientWithResponses) PersistentTopicsSetDeduplicationSnapshotIntervalWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDeduplicationSnapshotIntervalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetDeduplicationSnapshotIntervalResponse, error) {
	rsp, err := c.PersistentTopicsSetDeduplicationSnapshotIntervalWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetDeduplicationSnapshotIntervalResponse(rsp)
}

// PersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse request returning *PersistentTopicsDeleteDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsDeleteDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeleteDelayedDeliveryPoliciesResponse(rsp)
}

// PersistentTopicsGetDelayedDeliveryPoliciesWithResponse request returning *PersistentTopicsGetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsGetDelayedDeliveryPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDelayedDeliveryPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsGetDelayedDeliveryPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetDelayedDeliveryPoliciesResponse(rsp)
}

// PersistentTopicsSetDelayedDeliveryPoliciesWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetDelayedDeliveryPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsSetDelayedDeliveryPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDelayedDeliveryPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetDelayedDeliveryPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsSetDelayedDeliveryPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetDelayedDeliveryPoliciesResponse(rsp)
}

// PersistentTopicsRemoveDispatchRateWithResponse request returning *PersistentTopicsRemoveDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsRemoveDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsRemoveDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveDispatchRateResponse(rsp)
}

// PersistentTopicsGetDispatchRateWithResponse request returning *PersistentTopicsGetDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsGetDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsGetDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetDispatchRateResponse(rsp)
}

// PersistentTopicsSetDispatchRateWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsSetDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsSetDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetDispatchRateResponse(rsp)
}

// PersistentTopicsRemoveEntryFiltersWithResponse request returning *PersistentTopicsRemoveEntryFiltersResponse
func (c *ClientWithResponses) PersistentTopicsRemoveEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveEntryFiltersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveEntryFiltersResponse, error) {
	rsp, err := c.PersistentTopicsRemoveEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveEntryFiltersResponse(rsp)
}

// PersistentTopicsGetEntryFiltersWithResponse request returning *PersistentTopicsGetEntryFiltersResponse
func (c *ClientWithResponses) PersistentTopicsGetEntryFiltersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetEntryFiltersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetEntryFiltersResponse, error) {
	rsp, err := c.PersistentTopicsGetEntryFilters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetEntryFiltersResponse(rsp)
}

// PersistentTopicsSetEntryFiltersWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetEntryFiltersResponse
func (c *ClientWithResponses) PersistentTopicsSetEntryFiltersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetEntryFiltersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetEntryFiltersResponse, error) {
	rsp, err := c.PersistentTopicsSetEntryFiltersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetEntryFiltersResponse(rsp)
}

// PersistentTopicsExamineMessageWithResponse request returning *PersistentTopicsExamineMessageResponse
func (c *ClientWithResponses) PersistentTopicsExamineMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsExamineMessageParams, reqEditors ...RequestEditorFn) (*PersistentTopicsExamineMessageResponse, error) {
	rsp, err := c.PersistentTopicsExamineMessage(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsExamineMessageResponse(rsp)
}

// PersistentTopicsDeleteInactiveTopicPoliciesWithResponse request returning *PersistentTopicsDeleteInactiveTopicPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsDeleteInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteInactiveTopicPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsDeleteInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeleteInactiveTopicPoliciesResponse(rsp)
}

// PersistentTopicsGetInactiveTopicPoliciesWithResponse request returning *PersistentTopicsGetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsGetInactiveTopicPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetInactiveTopicPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsGetInactiveTopicPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetInactiveTopicPoliciesResponse(rsp)
}

// PersistentTopicsSetInactiveTopicPoliciesWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetInactiveTopicPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsSetInactiveTopicPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetInactiveTopicPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetInactiveTopicPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsSetInactiveTopicPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetInactiveTopicPoliciesResponse(rsp)
}

// PersistentTopicsGetManagedLedgerInfoWithResponse request returning *PersistentTopicsGetManagedLedgerInfoResponse
func (c *ClientWithResponses) PersistentTopicsGetManagedLedgerInfoWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetManagedLedgerInfoParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetManagedLedgerInfoResponse, error) {
	rsp, err := c.PersistentTopicsGetManagedLedgerInfo(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetManagedLedgerInfoResponse(rsp)
}

// PersistentTopicsGetInternalStatsWithResponse request returning *PersistentTopicsGetInternalStatsResponse
func (c *ClientWithResponses) PersistentTopicsGetInternalStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetInternalStatsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetInternalStatsResponse, error) {
	rsp, err := c.PersistentTopicsGetInternalStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetInternalStatsResponse(rsp)
}

// PersistentTopicsGetLastMessageIdWithResponse request returning *PersistentTopicsGetLastMessageIdResponse
func (c *ClientWithResponses) PersistentTopicsGetLastMessageIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetLastMessageIdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetLastMessageIdResponse, error) {
	rsp, err := c.PersistentTopicsGetLastMessageId(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetLastMessageIdResponse(rsp)
}

// PersistentTopicsGetMessageByIdWithResponse request returning *PersistentTopicsGetMessageByIdResponse
func (c *ClientWithResponses) PersistentTopicsGetMessageByIdWithResponse(ctx context.Context, tenant string, namespace string, topic string, ledgerId int64, entryId int64, params *PersistentTopicsGetMessageByIdParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMessageByIdResponse, error) {
	rsp, err := c.PersistentTopicsGetMessageById(ctx, tenant, namespace, topic, ledgerId, entryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMessageByIdResponse(rsp)
}

// PersistentTopicsRemoveMaxConsumersWithResponse request returning *PersistentTopicsRemoveMaxConsumersResponse
func (c *ClientWithResponses) PersistentTopicsRemoveMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxConsumersResponse, error) {
	rsp, err := c.PersistentTopicsRemoveMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveMaxConsumersResponse(rsp)
}

// PersistentTopicsGetMaxConsumersWithResponse request returning *PersistentTopicsGetMaxConsumersResponse
func (c *ClientWithResponses) PersistentTopicsGetMaxConsumersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxConsumersResponse, error) {
	rsp, err := c.PersistentTopicsGetMaxConsumers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMaxConsumersResponse(rsp)
}

// PersistentTopicsSetMaxConsumersWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetMaxConsumersResponse
func (c *ClientWithResponses) PersistentTopicsSetMaxConsumersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxConsumersResponse, error) {
	rsp, err := c.PersistentTopicsSetMaxConsumersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetMaxConsumersResponse(rsp)
}

// PersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse request returning *PersistentTopicsRemoveMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) PersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.PersistentTopicsRemoveMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveMaxConsumersPerSubscriptionResponse(rsp)
}

// PersistentTopicsGetMaxConsumersPerSubscriptionWithResponse request returning *PersistentTopicsGetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) PersistentTopicsGetMaxConsumersPerSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxConsumersPerSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.PersistentTopicsGetMaxConsumersPerSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMaxConsumersPerSubscriptionResponse(rsp)
}

// PersistentTopicsSetMaxConsumersPerSubscriptionWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetMaxConsumersPerSubscriptionResponse
func (c *ClientWithResponses) PersistentTopicsSetMaxConsumersPerSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxConsumersPerSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxConsumersPerSubscriptionResponse, error) {
	rsp, err := c.PersistentTopicsSetMaxConsumersPerSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetMaxConsumersPerSubscriptionResponse(rsp)
}

// PersistentTopicsRemoveMaxMessageSizeWithResponse request returning *PersistentTopicsRemoveMaxMessageSizeResponse
func (c *ClientWithResponses) PersistentTopicsRemoveMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxMessageSizeResponse, error) {
	rsp, err := c.PersistentTopicsRemoveMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveMaxMessageSizeResponse(rsp)
}

// PersistentTopicsGetMaxMessageSizeWithResponse request returning *PersistentTopicsGetMaxMessageSizeResponse
func (c *ClientWithResponses) PersistentTopicsGetMaxMessageSizeWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxMessageSizeParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxMessageSizeResponse, error) {
	rsp, err := c.PersistentTopicsGetMaxMessageSize(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMaxMessageSizeResponse(rsp)
}

// PersistentTopicsSetMaxMessageSizeWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetMaxMessageSizeResponse
func (c *ClientWithResponses) PersistentTopicsSetMaxMessageSizeWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxMessageSizeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxMessageSizeResponse, error) {
	rsp, err := c.PersistentTopicsSetMaxMessageSizeWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetMaxMessageSizeResponse(rsp)
}

// PersistentTopicsRemoveMaxProducersWithResponse request returning *PersistentTopicsRemoveMaxProducersResponse
func (c *ClientWithResponses) PersistentTopicsRemoveMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxProducersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxProducersResponse, error) {
	rsp, err := c.PersistentTopicsRemoveMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveMaxProducersResponse(rsp)
}

// PersistentTopicsGetMaxProducersWithResponse request returning *PersistentTopicsGetMaxProducersResponse
func (c *ClientWithResponses) PersistentTopicsGetMaxProducersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxProducersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxProducersResponse, error) {
	rsp, err := c.PersistentTopicsGetMaxProducers(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMaxProducersResponse(rsp)
}

// PersistentTopicsSetMaxProducersWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetMaxProducersResponse
func (c *ClientWithResponses) PersistentTopicsSetMaxProducersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxProducersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxProducersResponse, error) {
	rsp, err := c.PersistentTopicsSetMaxProducersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetMaxProducersResponse(rsp)
}

// PersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse request returning *PersistentTopicsRemoveMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) PersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.PersistentTopicsRemoveMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveMaxSubscriptionsPerTopicResponse(rsp)
}

// PersistentTopicsGetMaxSubscriptionsPerTopicWithResponse request returning *PersistentTopicsGetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) PersistentTopicsGetMaxSubscriptionsPerTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxSubscriptionsPerTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.PersistentTopicsGetMaxSubscriptionsPerTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMaxSubscriptionsPerTopicResponse(rsp)
}

// PersistentTopicsSetMaxSubscriptionsPerTopicWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetMaxSubscriptionsPerTopicResponse
func (c *ClientWithResponses) PersistentTopicsSetMaxSubscriptionsPerTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxSubscriptionsPerTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxSubscriptionsPerTopicResponse, error) {
	rsp, err := c.PersistentTopicsSetMaxSubscriptionsPerTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetMaxSubscriptionsPerTopicResponse(rsp)
}

// PersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse request returning *PersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) PersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.PersistentTopicsDeleteMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse(rsp)
}

// PersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse request returning *PersistentTopicsGetMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) PersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnConsumerParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.PersistentTopicsGetMaxUnackedMessagesOnConsumer(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMaxUnackedMessagesOnConsumerResponse(rsp)
}

// PersistentTopicsSetMaxUnackedMessagesOnConsumerWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetMaxUnackedMessagesOnConsumerResponse
func (c *ClientWithResponses) PersistentTopicsSetMaxUnackedMessagesOnConsumerWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnConsumerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxUnackedMessagesOnConsumerResponse, error) {
	rsp, err := c.PersistentTopicsSetMaxUnackedMessagesOnConsumerWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetMaxUnackedMessagesOnConsumerResponse(rsp)
}

// PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse request returning *PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.PersistentTopicsDeleteMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// PersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse request returning *PersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) PersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMaxUnackedMessagesOnSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.PersistentTopicsGetMaxUnackedMessagesOnSubscription(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse
func (c *ClientWithResponses) PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMaxUnackedMessagesOnSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse, error) {
	rsp, err := c.PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse(rsp)
}

// PersistentTopicsRemoveMessageTTLWithResponse request returning *PersistentTopicsRemoveMessageTTLResponse
func (c *ClientWithResponses) PersistentTopicsRemoveMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveMessageTTLParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveMessageTTLResponse, error) {
	rsp, err := c.PersistentTopicsRemoveMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveMessageTTLResponse(rsp)
}

// PersistentTopicsGetMessageTTLWithResponse request returning *PersistentTopicsGetMessageTTLResponse
func (c *ClientWithResponses) PersistentTopicsGetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetMessageTTLParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMessageTTLResponse, error) {
	rsp, err := c.PersistentTopicsGetMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMessageTTLResponse(rsp)
}

// PersistentTopicsSetMessageTTLWithResponse request returning *PersistentTopicsSetMessageTTLResponse
func (c *ClientWithResponses) PersistentTopicsSetMessageTTLWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetMessageTTLParams, reqEditors ...RequestEditorFn) (*PersistentTopicsSetMessageTTLResponse, error) {
	rsp, err := c.PersistentTopicsSetMessageTTL(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetMessageTTLResponse(rsp)
}

// PersistentTopicsGetMessageIdByTimestampWithResponse request returning *PersistentTopicsGetMessageIdByTimestampResponse
func (c *ClientWithResponses) PersistentTopicsGetMessageIdByTimestampWithResponse(ctx context.Context, tenant string, namespace string, topic string, timestamp int64, params *PersistentTopicsGetMessageIdByTimestampParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetMessageIdByTimestampResponse, error) {
	rsp, err := c.PersistentTopicsGetMessageIdByTimestamp(ctx, tenant, namespace, topic, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetMessageIdByTimestampResponse(rsp)
}

// PersistentTopicsOffloadStatusWithResponse request returning *PersistentTopicsOffloadStatusResponse
func (c *ClientWithResponses) PersistentTopicsOffloadStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsOffloadStatusParams, reqEditors ...RequestEditorFn) (*PersistentTopicsOffloadStatusResponse, error) {
	rsp, err := c.PersistentTopicsOffloadStatus(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsOffloadStatusResponse(rsp)
}

// PersistentTopicsTriggerOffloadWithResponse request returning *PersistentTopicsTriggerOffloadResponse
func (c *ClientWithResponses) PersistentTopicsTriggerOffloadWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTriggerOffloadParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTriggerOffloadResponse, error) {
	rsp, err := c.PersistentTopicsTriggerOffload(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsTriggerOffloadResponse(rsp)
}

// PersistentTopicsRemoveOffloadPoliciesWithResponse request returning *PersistentTopicsRemoveOffloadPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsRemoveOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveOffloadPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsRemoveOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveOffloadPoliciesResponse(rsp)
}

// PersistentTopicsGetOffloadPoliciesWithResponse request returning *PersistentTopicsGetOffloadPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsGetOffloadPoliciesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetOffloadPoliciesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetOffloadPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsGetOffloadPolicies(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetOffloadPoliciesResponse(rsp)
}

// PersistentTopicsSetOffloadPoliciesWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetOffloadPoliciesResponse
func (c *ClientWithResponses) PersistentTopicsSetOffloadPoliciesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetOffloadPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetOffloadPoliciesResponse, error) {
	rsp, err := c.PersistentTopicsSetOffloadPoliciesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetOffloadPoliciesResponse(rsp)
}

// PersistentTopicsGetPartitionedStatsInternalWithResponse request returning *PersistentTopicsGetPartitionedStatsInternalResponse
func (c *ClientWithResponses) PersistentTopicsGetPartitionedStatsInternalWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsInternalParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPartitionedStatsInternalResponse, error) {
	rsp, err := c.PersistentTopicsGetPartitionedStatsInternal(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetPartitionedStatsInternalResponse(rsp)
}

// PersistentTopicsGetPartitionedStatsWithResponse request returning *PersistentTopicsGetPartitionedStatsResponse
func (c *ClientWithResponses) PersistentTopicsGetPartitionedStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedStatsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPartitionedStatsResponse, error) {
	rsp, err := c.PersistentTopicsGetPartitionedStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetPartitionedStatsResponse(rsp)
}

// PersistentTopicsDeletePartitionedTopicWithResponse request returning *PersistentTopicsDeletePartitionedTopicResponse
func (c *ClientWithResponses) PersistentTopicsDeletePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeletePartitionedTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeletePartitionedTopicResponse, error) {
	rsp, err := c.PersistentTopicsDeletePartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeletePartitionedTopicResponse(rsp)
}

// PersistentTopicsGetPartitionedMetadataWithResponse request returning *PersistentTopicsGetPartitionedMetadataResponse
func (c *ClientWithResponses) PersistentTopicsGetPartitionedMetadataWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPartitionedMetadataParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPartitionedMetadataResponse, error) {
	rsp, err := c.PersistentTopicsGetPartitionedMetadata(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetPartitionedMetadataResponse(rsp)
}

// PersistentTopicsUpdatePartitionedTopicWithBodyWithResponse request with arbitrary body returning *PersistentTopicsUpdatePartitionedTopicResponse
func (c *ClientWithResponses) PersistentTopicsUpdatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsUpdatePartitionedTopicResponse, error) {
	rsp, err := c.PersistentTopicsUpdatePartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsUpdatePartitionedTopicResponse(rsp)
}

// PersistentTopicsCreatePartitionedTopicWithBodyWithResponse request with arbitrary body returning *PersistentTopicsCreatePartitionedTopicResponse
func (c *ClientWithResponses) PersistentTopicsCreatePartitionedTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsCreatePartitionedTopicParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsCreatePartitionedTopicResponse, error) {
	rsp, err := c.PersistentTopicsCreatePartitionedTopicWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsCreatePartitionedTopicResponse(rsp)
}

// PersistentTopicsGetPermissionsOnTopicWithResponse request returning *PersistentTopicsGetPermissionsOnTopicResponse
func (c *ClientWithResponses) PersistentTopicsGetPermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPermissionsOnTopicResponse, error) {
	rsp, err := c.PersistentTopicsGetPermissionsOnTopic(ctx, tenant, namespace, topic, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetPermissionsOnTopicResponse(rsp)
}

// PersistentTopicsRevokePermissionsOnTopicWithResponse request returning *PersistentTopicsRevokePermissionsOnTopicResponse
func (c *ClientWithResponses) PersistentTopicsRevokePermissionsOnTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, reqEditors ...RequestEditorFn) (*PersistentTopicsRevokePermissionsOnTopicResponse, error) {
	rsp, err := c.PersistentTopicsRevokePermissionsOnTopic(ctx, tenant, namespace, topic, role, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRevokePermissionsOnTopicResponse(rsp)
}

// PersistentTopicsGrantPermissionsOnTopicWithBodyWithResponse request with arbitrary body returning *PersistentTopicsGrantPermissionsOnTopicResponse
func (c *ClientWithResponses) PersistentTopicsGrantPermissionsOnTopicWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, role string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsGrantPermissionsOnTopicResponse, error) {
	rsp, err := c.PersistentTopicsGrantPermissionsOnTopicWithBody(ctx, tenant, namespace, topic, role, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGrantPermissionsOnTopicResponse(rsp)
}

// PersistentTopicsRemovePersistenceWithResponse request returning *PersistentTopicsRemovePersistenceResponse
func (c *ClientWithResponses) PersistentTopicsRemovePersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePersistenceParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemovePersistenceResponse, error) {
	rsp, err := c.PersistentTopicsRemovePersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemovePersistenceResponse(rsp)
}

// PersistentTopicsGetPersistenceWithResponse request returning *PersistentTopicsGetPersistenceResponse
func (c *ClientWithResponses) PersistentTopicsGetPersistenceWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPersistenceParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPersistenceResponse, error) {
	rsp, err := c.PersistentTopicsGetPersistence(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetPersistenceResponse(rsp)
}

// PersistentTopicsSetPersistenceWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetPersistenceResponse
func (c *ClientWithResponses) PersistentTopicsSetPersistenceWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetPersistenceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetPersistenceResponse, error) {
	rsp, err := c.PersistentTopicsSetPersistenceWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetPersistenceResponse(rsp)
}

// PersistentTopicsRemovePropertiesWithResponse request returning *PersistentTopicsRemovePropertiesResponse
func (c *ClientWithResponses) PersistentTopicsRemovePropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePropertiesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemovePropertiesResponse, error) {
	rsp, err := c.PersistentTopicsRemoveProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemovePropertiesResponse(rsp)
}

// PersistentTopicsGetPropertiesWithResponse request returning *PersistentTopicsGetPropertiesResponse
func (c *ClientWithResponses) PersistentTopicsGetPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPropertiesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPropertiesResponse, error) {
	rsp, err := c.PersistentTopicsGetProperties(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetPropertiesResponse(rsp)
}

// PersistentTopicsUpdatePropertiesWithBodyWithResponse request with arbitrary body returning *PersistentTopicsUpdatePropertiesResponse
func (c *ClientWithResponses) PersistentTopicsUpdatePropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUpdatePropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsUpdatePropertiesResponse, error) {
	rsp, err := c.PersistentTopicsUpdatePropertiesWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsUpdatePropertiesResponse(rsp)
}

// PersistentTopicsRemovePublishRateWithResponse request returning *PersistentTopicsRemovePublishRateResponse
func (c *ClientWithResponses) PersistentTopicsRemovePublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemovePublishRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemovePublishRateResponse, error) {
	rsp, err := c.PersistentTopicsRemovePublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemovePublishRateResponse(rsp)
}

// PersistentTopicsGetPublishRateWithResponse request returning *PersistentTopicsGetPublishRateResponse
func (c *ClientWithResponses) PersistentTopicsGetPublishRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetPublishRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetPublishRateResponse, error) {
	rsp, err := c.PersistentTopicsGetPublishRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetPublishRateResponse(rsp)
}

// PersistentTopicsSetPublishRateWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetPublishRateResponse
func (c *ClientWithResponses) PersistentTopicsSetPublishRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetPublishRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetPublishRateResponse, error) {
	rsp, err := c.PersistentTopicsSetPublishRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetPublishRateResponse(rsp)
}

// PersistentTopicsRemoveReplicationClustersWithResponse request returning *PersistentTopicsRemoveReplicationClustersResponse
func (c *ClientWithResponses) PersistentTopicsRemoveReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicationClustersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveReplicationClustersResponse, error) {
	rsp, err := c.PersistentTopicsRemoveReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveReplicationClustersResponse(rsp)
}

// PersistentTopicsGetReplicationClustersWithResponse request returning *PersistentTopicsGetReplicationClustersResponse
func (c *ClientWithResponses) PersistentTopicsGetReplicationClustersWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicationClustersParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetReplicationClustersResponse, error) {
	rsp, err := c.PersistentTopicsGetReplicationClusters(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetReplicationClustersResponse(rsp)
}

// PersistentTopicsSetReplicationClustersWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetReplicationClustersResponse
func (c *ClientWithResponses) PersistentTopicsSetReplicationClustersWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicationClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetReplicationClustersResponse, error) {
	rsp, err := c.PersistentTopicsSetReplicationClustersWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetReplicationClustersResponse(rsp)
}

// PersistentTopicsRemoveReplicatorDispatchRateWithResponse request returning *PersistentTopicsRemoveReplicatorDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsRemoveReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveReplicatorDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsRemoveReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveReplicatorDispatchRateResponse(rsp)
}

// PersistentTopicsGetReplicatorDispatchRateWithResponse request returning *PersistentTopicsGetReplicatorDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsGetReplicatorDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetReplicatorDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetReplicatorDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsGetReplicatorDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetReplicatorDispatchRateResponse(rsp)
}

// PersistentTopicsSetReplicatorDispatchRateWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetReplicatorDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsSetReplicatorDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetReplicatorDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetReplicatorDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsSetReplicatorDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetReplicatorDispatchRateResponse(rsp)
}

// PersistentTopicsRemoveRetentionWithResponse request returning *PersistentTopicsRemoveRetentionResponse
func (c *ClientWithResponses) PersistentTopicsRemoveRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveRetentionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveRetentionResponse, error) {
	rsp, err := c.PersistentTopicsRemoveRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveRetentionResponse(rsp)
}

// PersistentTopicsGetRetentionWithResponse request returning *PersistentTopicsGetRetentionResponse
func (c *ClientWithResponses) PersistentTopicsGetRetentionWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetRetentionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetRetentionResponse, error) {
	rsp, err := c.PersistentTopicsGetRetention(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetRetentionResponse(rsp)
}

// PersistentTopicsSetRetentionWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetRetentionResponse
func (c *ClientWithResponses) PersistentTopicsSetRetentionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetRetentionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetRetentionResponse, error) {
	rsp, err := c.PersistentTopicsSetRetentionWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetRetentionResponse(rsp)
}

// PersistentTopicsRemoveSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *PersistentTopicsRemoveSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) PersistentTopicsRemoveSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.PersistentTopicsRemoveSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveSchemaCompatibilityStrategyResponse(rsp)
}

// PersistentTopicsGetSchemaCompatibilityStrategyWithResponse request returning *PersistentTopicsGetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) PersistentTopicsGetSchemaCompatibilityStrategyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaCompatibilityStrategyParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.PersistentTopicsGetSchemaCompatibilityStrategy(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetSchemaCompatibilityStrategyResponse(rsp)
}

// PersistentTopicsSetSchemaCompatibilityStrategyWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetSchemaCompatibilityStrategyResponse
func (c *ClientWithResponses) PersistentTopicsSetSchemaCompatibilityStrategyWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaCompatibilityStrategyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSchemaCompatibilityStrategyResponse, error) {
	rsp, err := c.PersistentTopicsSetSchemaCompatibilityStrategyWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetSchemaCompatibilityStrategyResponse(rsp)
}

// PersistentTopicsGetSchemaValidationEnforcedWithResponse request returning *PersistentTopicsGetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) PersistentTopicsGetSchemaValidationEnforcedWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSchemaValidationEnforcedParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.PersistentTopicsGetSchemaValidationEnforced(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetSchemaValidationEnforcedResponse(rsp)
}

// PersistentTopicsSetSchemaValidationEnforcedWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetSchemaValidationEnforcedResponse
func (c *ClientWithResponses) PersistentTopicsSetSchemaValidationEnforcedWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSchemaValidationEnforcedParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSchemaValidationEnforcedResponse, error) {
	rsp, err := c.PersistentTopicsSetSchemaValidationEnforcedWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetSchemaValidationEnforcedResponse(rsp)
}

// PersistentTopicsDeleteShadowTopicsWithResponse request returning *PersistentTopicsDeleteShadowTopicsResponse
func (c *ClientWithResponses) PersistentTopicsDeleteShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsDeleteShadowTopicsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteShadowTopicsResponse, error) {
	rsp, err := c.PersistentTopicsDeleteShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeleteShadowTopicsResponse(rsp)
}

// PersistentTopicsGetShadowTopicsWithResponse request returning *PersistentTopicsGetShadowTopicsResponse
func (c *ClientWithResponses) PersistentTopicsGetShadowTopicsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetShadowTopicsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetShadowTopicsResponse, error) {
	rsp, err := c.PersistentTopicsGetShadowTopics(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetShadowTopicsResponse(rsp)
}

// PersistentTopicsSetShadowTopicsWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetShadowTopicsResponse
func (c *ClientWithResponses) PersistentTopicsSetShadowTopicsWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetShadowTopicsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetShadowTopicsResponse, error) {
	rsp, err := c.PersistentTopicsSetShadowTopicsWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetShadowTopicsResponse(rsp)
}

// PersistentTopicsGetStatsWithResponse request returning *PersistentTopicsGetStatsResponse
func (c *ClientWithResponses) PersistentTopicsGetStatsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetStatsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetStatsResponse, error) {
	rsp, err := c.PersistentTopicsGetStats(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetStatsResponse(rsp)
}

// PersistentTopicsRemoveSubscribeRateWithBodyWithResponse request with arbitrary body returning *PersistentTopicsRemoveSubscribeRateResponse
func (c *ClientWithResponses) PersistentTopicsRemoveSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSubscribeRateResponse, error) {
	rsp, err := c.PersistentTopicsRemoveSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveSubscribeRateResponse(rsp)
}

// PersistentTopicsGetSubscribeRateWithResponse request returning *PersistentTopicsGetSubscribeRateResponse
func (c *ClientWithResponses) PersistentTopicsGetSubscribeRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscribeRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscribeRateResponse, error) {
	rsp, err := c.PersistentTopicsGetSubscribeRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetSubscribeRateResponse(rsp)
}

// PersistentTopicsSetSubscribeRateWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetSubscribeRateResponse
func (c *ClientWithResponses) PersistentTopicsSetSubscribeRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscribeRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSubscribeRateResponse, error) {
	rsp, err := c.PersistentTopicsSetSubscribeRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetSubscribeRateResponse(rsp)
}

// PersistentTopicsDeleteSubscriptionWithResponse request returning *PersistentTopicsDeleteSubscriptionResponse
func (c *ClientWithResponses) PersistentTopicsDeleteSubscriptionWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsDeleteSubscriptionParams, reqEditors ...RequestEditorFn) (*PersistentTopicsDeleteSubscriptionResponse, error) {
	rsp, err := c.PersistentTopicsDeleteSubscription(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsDeleteSubscriptionResponse(rsp)
}

// PersistentTopicsAnalyzeSubscriptionBacklogWithBodyWithResponse request with arbitrary body returning *PersistentTopicsAnalyzeSubscriptionBacklogResponse
func (c *ClientWithResponses) PersistentTopicsAnalyzeSubscriptionBacklogWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsAnalyzeSubscriptionBacklogParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsAnalyzeSubscriptionBacklogResponse, error) {
	rsp, err := c.PersistentTopicsAnalyzeSubscriptionBacklogWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsAnalyzeSubscriptionBacklogResponse(rsp)
}

// PersistentTopicsExpireTopicMessagesWithBodyWithResponse request with arbitrary body returning *PersistentTopicsExpireTopicMessagesResponse
func (c *ClientWithResponses) PersistentTopicsExpireTopicMessagesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsExpireTopicMessagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsExpireTopicMessagesResponse, error) {
	rsp, err := c.PersistentTopicsExpireTopicMessagesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsExpireTopicMessagesResponse(rsp)
}

// PersistentTopicsExpireTopicMessagesExpireTimeWithResponse request returning *PersistentTopicsExpireTopicMessagesExpireTimeResponse
func (c *ClientWithResponses) PersistentTopicsExpireTopicMessagesExpireTimeWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, expireTimeInSeconds int32, params *PersistentTopicsExpireTopicMessagesExpireTimeParams, reqEditors ...RequestEditorFn) (*PersistentTopicsExpireTopicMessagesExpireTimeResponse, error) {
	rsp, err := c.PersistentTopicsExpireTopicMessagesExpireTime(ctx, tenant, namespace, topic, subName, expireTimeInSeconds, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsExpireTopicMessagesExpireTimeResponse(rsp)
}

// PersistentTopicsPeekNthMessageWithResponse request returning *PersistentTopicsPeekNthMessageResponse
func (c *ClientWithResponses) PersistentTopicsPeekNthMessageWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, messagePosition int32, params *PersistentTopicsPeekNthMessageParams, reqEditors ...RequestEditorFn) (*PersistentTopicsPeekNthMessageResponse, error) {
	rsp, err := c.PersistentTopicsPeekNthMessage(ctx, tenant, namespace, topic, subName, messagePosition, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsPeekNthMessageResponse(rsp)
}

// PersistentTopicsGetSubscriptionPropertiesWithResponse request returning *PersistentTopicsGetSubscriptionPropertiesResponse
func (c *ClientWithResponses) PersistentTopicsGetSubscriptionPropertiesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionPropertiesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionPropertiesResponse, error) {
	rsp, err := c.PersistentTopicsGetSubscriptionProperties(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetSubscriptionPropertiesResponse(rsp)
}

// PersistentTopicsUpdateSubscriptionPropertiesWithBodyWithResponse request with arbitrary body returning *PersistentTopicsUpdateSubscriptionPropertiesResponse
func (c *ClientWithResponses) PersistentTopicsUpdateSubscriptionPropertiesWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsUpdateSubscriptionPropertiesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsUpdateSubscriptionPropertiesResponse, error) {
	rsp, err := c.PersistentTopicsUpdateSubscriptionPropertiesWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsUpdateSubscriptionPropertiesResponse(rsp)
}

// PersistentTopicsGetReplicatedSubscriptionStatusWithResponse request returning *PersistentTopicsGetReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) PersistentTopicsGetReplicatedSubscriptionStatusWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetReplicatedSubscriptionStatusParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.PersistentTopicsGetReplicatedSubscriptionStatus(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetReplicatedSubscriptionStatusResponse(rsp)
}

// PersistentTopicsSetReplicatedSubscriptionStatusWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetReplicatedSubscriptionStatusResponse
func (c *ClientWithResponses) PersistentTopicsSetReplicatedSubscriptionStatusWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetReplicatedSubscriptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetReplicatedSubscriptionStatusResponse, error) {
	rsp, err := c.PersistentTopicsSetReplicatedSubscriptionStatusWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetReplicatedSubscriptionStatusResponse(rsp)
}

// PersistentTopicsResetCursorOnPositionWithBodyWithResponse request with arbitrary body returning *PersistentTopicsResetCursorOnPositionResponse
func (c *ClientWithResponses) PersistentTopicsResetCursorOnPositionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsResetCursorOnPositionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsResetCursorOnPositionResponse, error) {
	rsp, err := c.PersistentTopicsResetCursorOnPositionWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsResetCursorOnPositionResponse(rsp)
}

// PersistentTopicsResetCursorWithResponse request returning *PersistentTopicsResetCursorResponse
func (c *ClientWithResponses) PersistentTopicsResetCursorWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, timestamp int64, params *PersistentTopicsResetCursorParams, reqEditors ...RequestEditorFn) (*PersistentTopicsResetCursorResponse, error) {
	rsp, err := c.PersistentTopicsResetCursor(ctx, tenant, namespace, topic, subName, timestamp, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsResetCursorResponse(rsp)
}

// PersistentTopicsSkipMessagesWithResponse request returning *PersistentTopicsSkipMessagesResponse
func (c *ClientWithResponses) PersistentTopicsSkipMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, numMessages int32, params *PersistentTopicsSkipMessagesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsSkipMessagesResponse, error) {
	rsp, err := c.PersistentTopicsSkipMessages(ctx, tenant, namespace, topic, subName, numMessages, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSkipMessagesResponse(rsp)
}

// PersistentTopicsSkipAllMessagesWithResponse request returning *PersistentTopicsSkipAllMessagesResponse
func (c *ClientWithResponses) PersistentTopicsSkipAllMessagesWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSkipAllMessagesParams, reqEditors ...RequestEditorFn) (*PersistentTopicsSkipAllMessagesResponse, error) {
	rsp, err := c.PersistentTopicsSkipAllMessages(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSkipAllMessagesResponse(rsp)
}

// PersistentTopicsCreateSubscriptionWithBodyWithResponse request with arbitrary body returning *PersistentTopicsCreateSubscriptionResponse
func (c *ClientWithResponses) PersistentTopicsCreateSubscriptionWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subscriptionName string, params *PersistentTopicsCreateSubscriptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsCreateSubscriptionResponse, error) {
	rsp, err := c.PersistentTopicsCreateSubscriptionWithBody(ctx, tenant, namespace, topic, subscriptionName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsCreateSubscriptionResponse(rsp)
}

// PersistentTopicsRemoveSubscriptionDispatchRateWithResponse request returning *PersistentTopicsRemoveSubscriptionDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsRemoveSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSubscriptionDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsRemoveSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveSubscriptionDispatchRateResponse(rsp)
}

// PersistentTopicsGetSubscriptionDispatchRateWithResponse request returning *PersistentTopicsGetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsGetSubscriptionDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsGetSubscriptionDispatchRate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetSubscriptionDispatchRateResponse(rsp)
}

// PersistentTopicsSetSubscriptionDispatchRateWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetSubscriptionDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsSetSubscriptionDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSubscriptionDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsSetSubscriptionDispatchRateWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetSubscriptionDispatchRateResponse(rsp)
}

// PersistentTopicsRemoveSubscriptionTypesEnabledWithResponse request returning *PersistentTopicsRemoveSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) PersistentTopicsRemoveSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsRemoveSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.PersistentTopicsRemoveSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveSubscriptionTypesEnabledResponse(rsp)
}

// PersistentTopicsGetSubscriptionTypesEnabledWithResponse request returning *PersistentTopicsGetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) PersistentTopicsGetSubscriptionTypesEnabledWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionTypesEnabledParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.PersistentTopicsGetSubscriptionTypesEnabled(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetSubscriptionTypesEnabledResponse(rsp)
}

// PersistentTopicsSetSubscriptionTypesEnabledWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetSubscriptionTypesEnabledResponse
func (c *ClientWithResponses) PersistentTopicsSetSubscriptionTypesEnabledWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsSetSubscriptionTypesEnabledParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSubscriptionTypesEnabledResponse, error) {
	rsp, err := c.PersistentTopicsSetSubscriptionTypesEnabledWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetSubscriptionTypesEnabledResponse(rsp)
}

// PersistentTopicsGetSubscriptionsWithResponse request returning *PersistentTopicsGetSubscriptionsResponse
func (c *ClientWithResponses) PersistentTopicsGetSubscriptionsWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsGetSubscriptionsParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionsResponse, error) {
	rsp, err := c.PersistentTopicsGetSubscriptions(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetSubscriptionsResponse(rsp)
}

// PersistentTopicsTerminateWithResponse request returning *PersistentTopicsTerminateResponse
func (c *ClientWithResponses) PersistentTopicsTerminateWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTerminateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTerminateResponse, error) {
	rsp, err := c.PersistentTopicsTerminate(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsTerminateResponse(rsp)
}

// PersistentTopicsTerminatePartitionedTopicWithResponse request returning *PersistentTopicsTerminatePartitionedTopicResponse
func (c *ClientWithResponses) PersistentTopicsTerminatePartitionedTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTerminatePartitionedTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTerminatePartitionedTopicResponse, error) {
	rsp, err := c.PersistentTopicsTerminatePartitionedTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsTerminatePartitionedTopicResponse(rsp)
}

// PersistentTopicsTrimTopicWithResponse request returning *PersistentTopicsTrimTopicResponse
func (c *ClientWithResponses) PersistentTopicsTrimTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTrimTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTrimTopicResponse, error) {
	rsp, err := c.PersistentTopicsTrimTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsTrimTopicResponse(rsp)
}

// PersistentTopicsTruncateTopicWithResponse request returning *PersistentTopicsTruncateTopicResponse
func (c *ClientWithResponses) PersistentTopicsTruncateTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsTruncateTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsTruncateTopicResponse, error) {
	rsp, err := c.PersistentTopicsTruncateTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsTruncateTopicResponse(rsp)
}

// PersistentTopicsUnloadTopicWithResponse request returning *PersistentTopicsUnloadTopicResponse
func (c *ClientWithResponses) PersistentTopicsUnloadTopicWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *PersistentTopicsUnloadTopicParams, reqEditors ...RequestEditorFn) (*PersistentTopicsUnloadTopicResponse, error) {
	rsp, err := c.PersistentTopicsUnloadTopic(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsUnloadTopicResponse(rsp)
}

// PersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse request returning *PersistentTopicsRemoveSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsRemoveSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsRemoveSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsRemoveSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsRemoveSubscriptionLevelDispatchRateResponse(rsp)
}

// PersistentTopicsGetSubscriptionLevelDispatchRateWithResponse request returning *PersistentTopicsGetSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsGetSubscriptionLevelDispatchRateWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsGetSubscriptionLevelDispatchRateParams, reqEditors ...RequestEditorFn) (*PersistentTopicsGetSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsGetSubscriptionLevelDispatchRate(ctx, tenant, namespace, topic, subName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsGetSubscriptionLevelDispatchRateResponse(rsp)
}

// PersistentTopicsSetSubscriptionLevelDispatchRateWithBodyWithResponse request with arbitrary body returning *PersistentTopicsSetSubscriptionLevelDispatchRateResponse
func (c *ClientWithResponses) PersistentTopicsSetSubscriptionLevelDispatchRateWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, subName string, params *PersistentTopicsSetSubscriptionLevelDispatchRateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PersistentTopicsSetSubscriptionLevelDispatchRateResponse, error) {
	rsp, err := c.PersistentTopicsSetSubscriptionLevelDispatchRateWithBody(ctx, tenant, namespace, topic, subName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePersistentTopicsSetSubscriptionLevelDispatchRateResponse(rsp)
}

// ResourceQuotasGetDefaultResourceQuotaWithResponse request returning *ResourceQuotasGetDefaultResourceQuotaResponse
func (c *ClientWithResponses) ResourceQuotasGetDefaultResourceQuotaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResourceQuotasGetDefaultResourceQuotaResponse, error) {
	rsp, err := c.ResourceQuotasGetDefaultResourceQuota(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceQuotasGetDefaultResourceQuotaResponse(rsp)
}

// ResourceQuotasSetDefaultResourceQuotaWithBodyWithResponse request with arbitrary body returning *ResourceQuotasSetDefaultResourceQuotaResponse
func (c *ClientWithResponses) ResourceQuotasSetDefaultResourceQuotaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResourceQuotasSetDefaultResourceQuotaResponse, error) {
	rsp, err := c.ResourceQuotasSetDefaultResourceQuotaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceQuotasSetDefaultResourceQuotaResponse(rsp)
}

func (c *ClientWithResponses) ResourceQuotasSetDefaultResourceQuotaWithResponse(ctx context.Context, body ResourceQuotasSetDefaultResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*ResourceQuotasSetDefaultResourceQuotaResponse, error) {
	rsp, err := c.ResourceQuotasSetDefaultResourceQuota(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceQuotasSetDefaultResourceQuotaResponse(rsp)
}

// ResourceQuotasRemoveNamespaceBundleResourceQuotaWithResponse request returning *ResourceQuotasRemoveNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) ResourceQuotasRemoveNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*ResourceQuotasRemoveNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.ResourceQuotasRemoveNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceQuotasRemoveNamespaceBundleResourceQuotaResponse(rsp)
}

// ResourceQuotasGetNamespaceBundleResourceQuotaWithResponse request returning *ResourceQuotasGetNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) ResourceQuotasGetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, reqEditors ...RequestEditorFn) (*ResourceQuotasGetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.ResourceQuotasGetNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceQuotasGetNamespaceBundleResourceQuotaResponse(rsp)
}

// ResourceQuotasSetNamespaceBundleResourceQuotaWithBodyWithResponse request with arbitrary body returning *ResourceQuotasSetNamespaceBundleResourceQuotaResponse
func (c *ClientWithResponses) ResourceQuotasSetNamespaceBundleResourceQuotaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, bundle string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResourceQuotasSetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.ResourceQuotasSetNamespaceBundleResourceQuotaWithBody(ctx, tenant, namespace, bundle, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceQuotasSetNamespaceBundleResourceQuotaResponse(rsp)
}

func (c *ClientWithResponses) ResourceQuotasSetNamespaceBundleResourceQuotaWithResponse(ctx context.Context, tenant string, namespace string, bundle string, body ResourceQuotasSetNamespaceBundleResourceQuotaJSONRequestBody, reqEditors ...RequestEditorFn) (*ResourceQuotasSetNamespaceBundleResourceQuotaResponse, error) {
	rsp, err := c.ResourceQuotasSetNamespaceBundleResourceQuota(ctx, tenant, namespace, bundle, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceQuotasSetNamespaceBundleResourceQuotaResponse(rsp)
}

// ResourceGroupsGetResourceGroupsWithResponse request returning *ResourceGroupsGetResourceGroupsResponse
func (c *ClientWithResponses) ResourceGroupsGetResourceGroupsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResourceGroupsGetResourceGroupsResponse, error) {
	rsp, err := c.ResourceGroupsGetResourceGroups(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceGroupsGetResourceGroupsResponse(rsp)
}

// ResourceGroupsDeleteResourceGroupWithResponse request returning *ResourceGroupsDeleteResourceGroupResponse
func (c *ClientWithResponses) ResourceGroupsDeleteResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*ResourceGroupsDeleteResourceGroupResponse, error) {
	rsp, err := c.ResourceGroupsDeleteResourceGroup(ctx, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceGroupsDeleteResourceGroupResponse(rsp)
}

// ResourceGroupsGetResourceGroupWithResponse request returning *ResourceGroupsGetResourceGroupResponse
func (c *ClientWithResponses) ResourceGroupsGetResourceGroupWithResponse(ctx context.Context, resourcegroup string, reqEditors ...RequestEditorFn) (*ResourceGroupsGetResourceGroupResponse, error) {
	rsp, err := c.ResourceGroupsGetResourceGroup(ctx, resourcegroup, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceGroupsGetResourceGroupResponse(rsp)
}

// ResourceGroupsCreateOrUpdateResourceGroupWithBodyWithResponse request with arbitrary body returning *ResourceGroupsCreateOrUpdateResourceGroupResponse
func (c *ClientWithResponses) ResourceGroupsCreateOrUpdateResourceGroupWithBodyWithResponse(ctx context.Context, resourcegroup string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResourceGroupsCreateOrUpdateResourceGroupResponse, error) {
	rsp, err := c.ResourceGroupsCreateOrUpdateResourceGroupWithBody(ctx, resourcegroup, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceGroupsCreateOrUpdateResourceGroupResponse(rsp)
}

func (c *ClientWithResponses) ResourceGroupsCreateOrUpdateResourceGroupWithResponse(ctx context.Context, resourcegroup string, body ResourceGroupsCreateOrUpdateResourceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ResourceGroupsCreateOrUpdateResourceGroupResponse, error) {
	rsp, err := c.ResourceGroupsCreateOrUpdateResourceGroup(ctx, resourcegroup, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResourceGroupsCreateOrUpdateResourceGroupResponse(rsp)
}

// SchemasResourceTestCompatibilityWithBodyWithResponse request with arbitrary body returning *SchemasResourceTestCompatibilityResponse
func (c *ClientWithResponses) SchemasResourceTestCompatibilityWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasResourceTestCompatibilityResponse, error) {
	rsp, err := c.SchemasResourceTestCompatibilityWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourceTestCompatibilityResponse(rsp)
}

func (c *ClientWithResponses) SchemasResourceTestCompatibilityWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceTestCompatibilityParams, body SchemasResourceTestCompatibilityJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasResourceTestCompatibilityResponse, error) {
	rsp, err := c.SchemasResourceTestCompatibility(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourceTestCompatibilityResponse(rsp)
}

// SchemasResourceDeleteSchemaWithResponse request returning *SchemasResourceDeleteSchemaResponse
func (c *ClientWithResponses) SchemasResourceDeleteSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceDeleteSchemaParams, reqEditors ...RequestEditorFn) (*SchemasResourceDeleteSchemaResponse, error) {
	rsp, err := c.SchemasResourceDeleteSchema(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourceDeleteSchemaResponse(rsp)
}

// SchemasResourceGetSchemaWithResponse request returning *SchemasResourceGetSchemaResponse
func (c *ClientWithResponses) SchemasResourceGetSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetSchemaParams, reqEditors ...RequestEditorFn) (*SchemasResourceGetSchemaResponse, error) {
	rsp, err := c.SchemasResourceGetSchema(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourceGetSchemaResponse(rsp)
}

// SchemasResourcePostSchemaWithBodyWithResponse request with arbitrary body returning *SchemasResourcePostSchemaResponse
func (c *ClientWithResponses) SchemasResourcePostSchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasResourcePostSchemaResponse, error) {
	rsp, err := c.SchemasResourcePostSchemaWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourcePostSchemaResponse(rsp)
}

func (c *ClientWithResponses) SchemasResourcePostSchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourcePostSchemaParams, body SchemasResourcePostSchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasResourcePostSchemaResponse, error) {
	rsp, err := c.SchemasResourcePostSchema(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourcePostSchemaResponse(rsp)
}

// SchemasResourceGetSchemaByVersionWithResponse request returning *SchemasResourceGetSchemaByVersionResponse
func (c *ClientWithResponses) SchemasResourceGetSchemaByVersionWithResponse(ctx context.Context, tenant string, namespace string, topic string, version string, params *SchemasResourceGetSchemaByVersionParams, reqEditors ...RequestEditorFn) (*SchemasResourceGetSchemaByVersionResponse, error) {
	rsp, err := c.SchemasResourceGetSchemaByVersion(ctx, tenant, namespace, topic, version, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourceGetSchemaByVersionResponse(rsp)
}

// SchemasResourceGetAllSchemasWithResponse request returning *SchemasResourceGetAllSchemasResponse
func (c *ClientWithResponses) SchemasResourceGetAllSchemasWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetAllSchemasParams, reqEditors ...RequestEditorFn) (*SchemasResourceGetAllSchemasResponse, error) {
	rsp, err := c.SchemasResourceGetAllSchemas(ctx, tenant, namespace, topic, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourceGetAllSchemasResponse(rsp)
}

// SchemasResourceGetVersionBySchemaWithBodyWithResponse request with arbitrary body returning *SchemasResourceGetVersionBySchemaResponse
func (c *ClientWithResponses) SchemasResourceGetVersionBySchemaWithBodyWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SchemasResourceGetVersionBySchemaResponse, error) {
	rsp, err := c.SchemasResourceGetVersionBySchemaWithBody(ctx, tenant, namespace, topic, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourceGetVersionBySchemaResponse(rsp)
}

func (c *ClientWithResponses) SchemasResourceGetVersionBySchemaWithResponse(ctx context.Context, tenant string, namespace string, topic string, params *SchemasResourceGetVersionBySchemaParams, body SchemasResourceGetVersionBySchemaJSONRequestBody, reqEditors ...RequestEditorFn) (*SchemasResourceGetVersionBySchemaResponse, error) {
	rsp, err := c.SchemasResourceGetVersionBySchema(ctx, tenant, namespace, topic, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSchemasResourceGetVersionBySchemaResponse(rsp)
}

// TenantsBaseGetTenantsWithResponse request returning *TenantsBaseGetTenantsResponse
func (c *ClientWithResponses) TenantsBaseGetTenantsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*TenantsBaseGetTenantsResponse, error) {
	rsp, err := c.TenantsBaseGetTenants(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantsBaseGetTenantsResponse(rsp)
}

// TenantsBaseDeleteTenantWithResponse request returning *TenantsBaseDeleteTenantResponse
func (c *ClientWithResponses) TenantsBaseDeleteTenantWithResponse(ctx context.Context, tenant string, params *TenantsBaseDeleteTenantParams, reqEditors ...RequestEditorFn) (*TenantsBaseDeleteTenantResponse, error) {
	rsp, err := c.TenantsBaseDeleteTenant(ctx, tenant, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantsBaseDeleteTenantResponse(rsp)
}

// TenantsBaseGetTenantAdminWithResponse request returning *TenantsBaseGetTenantAdminResponse
func (c *ClientWithResponses) TenantsBaseGetTenantAdminWithResponse(ctx context.Context, tenant string, reqEditors ...RequestEditorFn) (*TenantsBaseGetTenantAdminResponse, error) {
	rsp, err := c.TenantsBaseGetTenantAdmin(ctx, tenant, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantsBaseGetTenantAdminResponse(rsp)
}

// TenantsBaseUpdateTenantWithBodyWithResponse request with arbitrary body returning *TenantsBaseUpdateTenantResponse
func (c *ClientWithResponses) TenantsBaseUpdateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantsBaseUpdateTenantResponse, error) {
	rsp, err := c.TenantsBaseUpdateTenantWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantsBaseUpdateTenantResponse(rsp)
}

func (c *ClientWithResponses) TenantsBaseUpdateTenantWithResponse(ctx context.Context, tenant string, body TenantsBaseUpdateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantsBaseUpdateTenantResponse, error) {
	rsp, err := c.TenantsBaseUpdateTenant(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantsBaseUpdateTenantResponse(rsp)
}

// TenantsBaseCreateTenantWithBodyWithResponse request with arbitrary body returning *TenantsBaseCreateTenantResponse
func (c *ClientWithResponses) TenantsBaseCreateTenantWithBodyWithResponse(ctx context.Context, tenant string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TenantsBaseCreateTenantResponse, error) {
	rsp, err := c.TenantsBaseCreateTenantWithBody(ctx, tenant, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantsBaseCreateTenantResponse(rsp)
}

func (c *ClientWithResponses) TenantsBaseCreateTenantWithResponse(ctx context.Context, tenant string, body TenantsBaseCreateTenantJSONRequestBody, reqEditors ...RequestEditorFn) (*TenantsBaseCreateTenantResponse, error) {
	rsp, err := c.TenantsBaseCreateTenant(ctx, tenant, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTenantsBaseCreateTenantResponse(rsp)
}

// WorkerStatsGetStatsWithResponse request returning *WorkerStatsGetStatsResponse
func (c *ClientWithResponses) WorkerStatsGetStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerStatsGetStatsResponse, error) {
	rsp, err := c.WorkerStatsGetStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerStatsGetStatsResponse(rsp)
}

// WorkerStatsGetMetricsWithResponse request returning *WorkerStatsGetMetricsResponse
func (c *ClientWithResponses) WorkerStatsGetMetricsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerStatsGetMetricsResponse, error) {
	rsp, err := c.WorkerStatsGetMetrics(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerStatsGetMetricsResponse(rsp)
}

// WorkerGetAssignmentsWithResponse request returning *WorkerGetAssignmentsResponse
func (c *ClientWithResponses) WorkerGetAssignmentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetAssignmentsResponse, error) {
	rsp, err := c.WorkerGetAssignments(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetAssignmentsResponse(rsp)
}

// WorkerGetClusterWithResponse request returning *WorkerGetClusterResponse
func (c *ClientWithResponses) WorkerGetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetClusterResponse, error) {
	rsp, err := c.WorkerGetCluster(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetClusterResponse(rsp)
}

// WorkerGetClusterLeaderWithResponse request returning *WorkerGetClusterLeaderResponse
func (c *ClientWithResponses) WorkerGetClusterLeaderWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetClusterLeaderResponse, error) {
	rsp, err := c.WorkerGetClusterLeader(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetClusterLeaderResponse(rsp)
}

// WorkerIsLeaderReadyWithResponse request returning *WorkerIsLeaderReadyResponse
func (c *ClientWithResponses) WorkerIsLeaderReadyWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerIsLeaderReadyResponse, error) {
	rsp, err := c.WorkerIsLeaderReady(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerIsLeaderReadyResponse(rsp)
}

// WorkerGetConnectorsListWithResponse request returning *WorkerGetConnectorsListResponse
func (c *ClientWithResponses) WorkerGetConnectorsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetConnectorsListResponse, error) {
	rsp, err := c.WorkerGetConnectorsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetConnectorsListResponse(rsp)
}

// WorkerGetDrainStatusWithResponse request returning *WorkerGetDrainStatusResponse
func (c *ClientWithResponses) WorkerGetDrainStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerGetDrainStatusResponse, error) {
	rsp, err := c.WorkerGetDrainStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetDrainStatusResponse(rsp)
}

// WorkerDrainWithResponse request returning *WorkerDrainResponse
func (c *ClientWithResponses) WorkerDrainWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerDrainResponse, error) {
	rsp, err := c.WorkerDrain(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerDrainResponse(rsp)
}

// WorkerGetDrainStatusFromLeaderWithResponse request returning *WorkerGetDrainStatusFromLeaderResponse
func (c *ClientWithResponses) WorkerGetDrainStatusFromLeaderWithResponse(ctx context.Context, params *WorkerGetDrainStatusFromLeaderParams, reqEditors ...RequestEditorFn) (*WorkerGetDrainStatusFromLeaderResponse, error) {
	rsp, err := c.WorkerGetDrainStatusFromLeader(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerGetDrainStatusFromLeaderResponse(rsp)
}

// WorkerDrainAtLeaderWithResponse request returning *WorkerDrainAtLeaderResponse
func (c *ClientWithResponses) WorkerDrainAtLeaderWithResponse(ctx context.Context, params *WorkerDrainAtLeaderParams, reqEditors ...RequestEditorFn) (*WorkerDrainAtLeaderResponse, error) {
	rsp, err := c.WorkerDrainAtLeader(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerDrainAtLeaderResponse(rsp)
}

// WorkerRebalanceWithResponse request returning *WorkerRebalanceResponse
func (c *ClientWithResponses) WorkerRebalanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*WorkerRebalanceResponse, error) {
	rsp, err := c.WorkerRebalance(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseWorkerRebalanceResponse(rsp)
}

// ParseBookiesGetAllBookiesResponse parses an HTTP response from a BookiesGetAllBookiesWithResponse call
func ParseBookiesGetAllBookiesResponse(rsp *http.Response) (*BookiesGetAllBookiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BookiesGetAllBookiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookiesClusterInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBookiesGetBookiesRackInfoResponse parses an HTTP response from a BookiesGetBookiesRackInfoWithResponse call
func ParseBookiesGetBookiesRackInfoResponse(rsp *http.Response) (*BookiesGetBookiesRackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BookiesGetBookiesRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]map[string]BookieInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBookiesDeleteBookieRackInfoResponse parses an HTTP response from a BookiesDeleteBookieRackInfoWithResponse call
func ParseBookiesDeleteBookieRackInfoResponse(rsp *http.Response) (*BookiesDeleteBookieRackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BookiesDeleteBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBookiesGetBookieRackInfoResponse parses an HTTP response from a BookiesGetBookieRackInfoWithResponse call
func ParseBookiesGetBookieRackInfoResponse(rsp *http.Response) (*BookiesGetBookieRackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BookiesGetBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookieInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBookiesUpdateBookieRackInfoResponse parses an HTTP response from a BookiesUpdateBookieRackInfoWithResponse call
func ParseBookiesUpdateBookieRackInfoResponse(rsp *http.Response) (*BookiesUpdateBookieRackInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BookiesUpdateBookieRackInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokerStatsBaseGetAllocatorStatsResponse parses an HTTP response from a BrokerStatsBaseGetAllocatorStatsWithResponse call
func ParseBrokerStatsBaseGetAllocatorStatsResponse(rsp *http.Response) (*BrokerStatsBaseGetAllocatorStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokerStatsBaseGetAllocatorStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllocatorStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokerStatsBaseGetPendingBookieOpsStatsResponse parses an HTTP response from a BrokerStatsBaseGetPendingBookieOpsStatsWithResponse call
func ParseBrokerStatsBaseGetPendingBookieOpsStatsResponse(rsp *http.Response) (*BrokerStatsBaseGetPendingBookieOpsStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokerStatsBaseGetPendingBookieOpsStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]PendingBookieOpsStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokerStatsGetBrokerResourceAvailabilityResponse parses an HTTP response from a BrokerStatsGetBrokerResourceAvailabilityWithResponse call
func ParseBrokerStatsGetBrokerResourceAvailabilityResponse(rsp *http.Response) (*BrokerStatsGetBrokerResourceAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokerStatsGetBrokerResourceAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]ResourceUnit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokerStatsBaseGetLoadReportResponse parses an HTTP response from a BrokerStatsBaseGetLoadReportWithResponse call
func ParseBrokerStatsBaseGetLoadReportResponse(rsp *http.Response) (*BrokerStatsBaseGetLoadReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokerStatsBaseGetLoadReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoadReport
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokerStatsBaseGetMBeansResponse parses an HTTP response from a BrokerStatsBaseGetMBeansWithResponse call
func ParseBrokerStatsBaseGetMBeansResponse(rsp *http.Response) (*BrokerStatsBaseGetMBeansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokerStatsBaseGetMBeansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokerStatsBaseGetMetricsResponse parses an HTTP response from a BrokerStatsBaseGetMetricsWithResponse call
func ParseBrokerStatsBaseGetMetricsResponse(rsp *http.Response) (*BrokerStatsBaseGetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokerStatsBaseGetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokerStatsGetTopics2Response parses an HTTP response from a BrokerStatsGetTopics2WithResponse call
func ParseBrokerStatsGetTopics2Response(rsp *http.Response) (*BrokerStatsGetTopics2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokerStatsGetTopics2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OutputStream
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokersBaseGetActiveBrokersResponse parses an HTTP response from a BrokersBaseGetActiveBrokersWithResponse call
func ParseBrokersBaseGetActiveBrokersResponse(rsp *http.Response) (*BrokersBaseGetActiveBrokersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseGetActiveBrokersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokersBaseBacklogQuotaCheckResponse parses an HTTP response from a BrokersBaseBacklogQuotaCheckWithResponse call
func ParseBrokersBaseBacklogQuotaCheckResponse(rsp *http.Response) (*BrokersBaseBacklogQuotaCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseBacklogQuotaCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseGetDynamicConfigurationNameResponse parses an HTTP response from a BrokersBaseGetDynamicConfigurationNameWithResponse call
func ParseBrokersBaseGetDynamicConfigurationNameResponse(rsp *http.Response) (*BrokersBaseGetDynamicConfigurationNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseGetDynamicConfigurationNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseGetRuntimeConfigurationResponse parses an HTTP response from a BrokersBaseGetRuntimeConfigurationWithResponse call
func ParseBrokersBaseGetRuntimeConfigurationResponse(rsp *http.Response) (*BrokersBaseGetRuntimeConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseGetRuntimeConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseGetAllDynamicConfigurationsResponse parses an HTTP response from a BrokersBaseGetAllDynamicConfigurationsWithResponse call
func ParseBrokersBaseGetAllDynamicConfigurationsResponse(rsp *http.Response) (*BrokersBaseGetAllDynamicConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseGetAllDynamicConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseDeleteDynamicConfigurationResponse parses an HTTP response from a BrokersBaseDeleteDynamicConfigurationWithResponse call
func ParseBrokersBaseDeleteDynamicConfigurationResponse(rsp *http.Response) (*BrokersBaseDeleteDynamicConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseDeleteDynamicConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseUpdateDynamicConfigurationResponse parses an HTTP response from a BrokersBaseUpdateDynamicConfigurationWithResponse call
func ParseBrokersBaseUpdateDynamicConfigurationResponse(rsp *http.Response) (*BrokersBaseUpdateDynamicConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseUpdateDynamicConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseHealthCheckResponse parses an HTTP response from a BrokersBaseHealthCheckWithResponse call
func ParseBrokersBaseHealthCheckResponse(rsp *http.Response) (*BrokersBaseHealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseHealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseGetInternalConfigurationDataResponse parses an HTTP response from a BrokersBaseGetInternalConfigurationDataWithResponse call
func ParseBrokersBaseGetInternalConfigurationDataResponse(rsp *http.Response) (*BrokersBaseGetInternalConfigurationDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseGetInternalConfigurationDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InternalConfigurationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokersBaseGetLeaderBrokerResponse parses an HTTP response from a BrokersBaseGetLeaderBrokerWithResponse call
func ParseBrokersBaseGetLeaderBrokerResponse(rsp *http.Response) (*BrokersBaseGetLeaderBrokerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseGetLeaderBrokerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrokerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokersBaseIsReadyResponse parses an HTTP response from a BrokersBaseIsReadyWithResponse call
func ParseBrokersBaseIsReadyResponse(rsp *http.Response) (*BrokersBaseIsReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseIsReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseShutDownBrokerGracefullyResponse parses an HTTP response from a BrokersBaseShutDownBrokerGracefullyWithResponse call
func ParseBrokersBaseShutDownBrokerGracefullyResponse(rsp *http.Response) (*BrokersBaseShutDownBrokerGracefullyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseShutDownBrokerGracefullyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBrokersBaseVersionResponse parses an HTTP response from a BrokersBaseVersionWithResponse call
func ParseBrokersBaseVersionResponse(rsp *http.Response) (*BrokersBaseVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokersBaseGetOwnedNamespacesResponse parses an HTTP response from a BrokersBaseGetOwnedNamespacesWithResponse call
func ParseBrokersBaseGetOwnedNamespacesResponse(rsp *http.Response) (*BrokersBaseGetOwnedNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseGetOwnedNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]NamespaceOwnershipStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBrokersBaseGetActiveBrokersByClusterResponse parses an HTTP response from a BrokersBaseGetActiveBrokersByClusterWithResponse call
func ParseBrokersBaseGetActiveBrokersByClusterResponse(rsp *http.Response) (*BrokersBaseGetActiveBrokersByClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BrokersBaseGetActiveBrokersByClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseGetClustersResponse parses an HTTP response from a ClustersBaseGetClustersWithResponse call
func ParseClustersBaseGetClustersResponse(rsp *http.Response) (*ClustersBaseGetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseDeleteClusterResponse parses an HTTP response from a ClustersBaseDeleteClusterWithResponse call
func ParseClustersBaseDeleteClusterResponse(rsp *http.Response) (*ClustersBaseDeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseDeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClustersBaseGetClusterResponse parses an HTTP response from a ClustersBaseGetClusterWithResponse call
func ParseClustersBaseGetClusterResponse(rsp *http.Response) (*ClustersBaseGetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseUpdateClusterResponse parses an HTTP response from a ClustersBaseUpdateClusterWithResponse call
func ParseClustersBaseUpdateClusterResponse(rsp *http.Response) (*ClustersBaseUpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseUpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClustersBaseCreateClusterResponse parses an HTTP response from a ClustersBaseCreateClusterWithResponse call
func ParseClustersBaseCreateClusterResponse(rsp *http.Response) (*ClustersBaseCreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseCreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClustersBaseGetFailureDomainsResponse parses an HTTP response from a ClustersBaseGetFailureDomainsWithResponse call
func ParseClustersBaseGetFailureDomainsResponse(rsp *http.Response) (*ClustersBaseGetFailureDomainsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetFailureDomainsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]FailureDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseDeleteFailureDomainResponse parses an HTTP response from a ClustersBaseDeleteFailureDomainWithResponse call
func ParseClustersBaseDeleteFailureDomainResponse(rsp *http.Response) (*ClustersBaseDeleteFailureDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseDeleteFailureDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClustersBaseGetDomainResponse parses an HTTP response from a ClustersBaseGetDomainWithResponse call
func ParseClustersBaseGetDomainResponse(rsp *http.Response) (*ClustersBaseGetDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FailureDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseSetFailureDomainResponse parses an HTTP response from a ClustersBaseSetFailureDomainWithResponse call
func ParseClustersBaseSetFailureDomainResponse(rsp *http.Response) (*ClustersBaseSetFailureDomainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseSetFailureDomainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClustersBaseUpdateClusterMigrationResponse parses an HTTP response from a ClustersBaseUpdateClusterMigrationWithResponse call
func ParseClustersBaseUpdateClusterMigrationResponse(rsp *http.Response) (*ClustersBaseUpdateClusterMigrationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseUpdateClusterMigrationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClustersBaseGetNamespaceIsolationPoliciesResponse parses an HTTP response from a ClustersBaseGetNamespaceIsolationPoliciesWithResponse call
func ParseClustersBaseGetNamespaceIsolationPoliciesResponse(rsp *http.Response) (*ClustersBaseGetNamespaceIsolationPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetNamespaceIsolationPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]NamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse parses an HTTP response from a ClustersBaseGetBrokersWithNamespaceIsolationPolicyWithResponse call
func ParseClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse(rsp *http.Response) (*ClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetBrokersWithNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []BrokerNamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse parses an HTTP response from a ClustersBaseGetBrokerWithNamespaceIsolationPolicyWithResponse call
func ParseClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse(rsp *http.Response) (*ClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetBrokerWithNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BrokerNamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseDeleteNamespaceIsolationPolicyResponse parses an HTTP response from a ClustersBaseDeleteNamespaceIsolationPolicyWithResponse call
func ParseClustersBaseDeleteNamespaceIsolationPolicyResponse(rsp *http.Response) (*ClustersBaseDeleteNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseDeleteNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClustersBaseGetNamespaceIsolationPolicyResponse parses an HTTP response from a ClustersBaseGetNamespaceIsolationPolicyWithResponse call
func ParseClustersBaseGetNamespaceIsolationPolicyResponse(rsp *http.Response) (*ClustersBaseGetNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NamespaceIsolationData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseSetNamespaceIsolationPolicyResponse parses an HTTP response from a ClustersBaseSetNamespaceIsolationPolicyWithResponse call
func ParseClustersBaseSetNamespaceIsolationPolicyResponse(rsp *http.Response) (*ClustersBaseSetNamespaceIsolationPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseSetNamespaceIsolationPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseClustersBaseGetPeerClusterResponse parses an HTTP response from a ClustersBaseGetPeerClusterWithResponse call
func ParseClustersBaseGetPeerClusterResponse(rsp *http.Response) (*ClustersBaseGetPeerClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseGetPeerClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseClustersBaseSetPeerClusterNamesResponse parses an HTTP response from a ClustersBaseSetPeerClusterNamesWithResponse call
func ParseClustersBaseSetPeerClusterNamesResponse(rsp *http.Response) (*ClustersBaseSetPeerClusterNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClustersBaseSetPeerClusterNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetAntiAffinityNamespacesResponse parses an HTTP response from a NamespacesGetAntiAffinityNamespacesWithResponse call
func ParseNamespacesGetAntiAffinityNamespacesResponse(rsp *http.Response) (*NamespacesGetAntiAffinityNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetAntiAffinityNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesDeleteBookieAffinityGroupResponse parses an HTTP response from a NamespacesDeleteBookieAffinityGroupWithResponse call
func ParseNamespacesDeleteBookieAffinityGroupResponse(rsp *http.Response) (*NamespacesDeleteBookieAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesDeleteBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetBookieAffinityGroupResponse parses an HTTP response from a NamespacesGetBookieAffinityGroupWithResponse call
func ParseNamespacesGetBookieAffinityGroupResponse(rsp *http.Response) (*NamespacesGetBookieAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BookieAffinityGroupData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesGetTenantNamespacesResponse parses an HTTP response from a NamespacesGetTenantNamespacesWithResponse call
func ParseNamespacesGetTenantNamespacesResponse(rsp *http.Response) (*NamespacesGetTenantNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetTenantNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesDeleteNamespaceResponse parses an HTTP response from a NamespacesDeleteNamespaceWithResponse call
func ParseNamespacesDeleteNamespaceResponse(rsp *http.Response) (*NamespacesDeleteNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesDeleteNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetPoliciesResponse parses an HTTP response from a NamespacesGetPoliciesWithResponse call
func ParseNamespacesGetPoliciesResponse(rsp *http.Response) (*NamespacesGetPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Policies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesCreateNamespaceResponse parses an HTTP response from a NamespacesCreateNamespaceWithResponse call
func ParseNamespacesCreateNamespaceResponse(rsp *http.Response) (*NamespacesCreateNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesCreateNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveNamespaceAntiAffinityGroupResponse parses an HTTP response from a NamespacesRemoveNamespaceAntiAffinityGroupWithResponse call
func ParseNamespacesRemoveNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*NamespacesRemoveNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetNamespaceAntiAffinityGroupResponse parses an HTTP response from a NamespacesGetNamespaceAntiAffinityGroupWithResponse call
func ParseNamespacesGetNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*NamespacesGetNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesSetNamespaceAntiAffinityGroupResponse parses an HTTP response from a NamespacesSetNamespaceAntiAffinityGroupWithResponse call
func ParseNamespacesSetNamespaceAntiAffinityGroupResponse(rsp *http.Response) (*NamespacesSetNamespaceAntiAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetNamespaceAntiAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveAutoSubscriptionCreationResponse parses an HTTP response from a NamespacesRemoveAutoSubscriptionCreationWithResponse call
func ParseNamespacesRemoveAutoSubscriptionCreationResponse(rsp *http.Response) (*NamespacesRemoveAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetAutoSubscriptionCreationResponse parses an HTTP response from a NamespacesGetAutoSubscriptionCreationWithResponse call
func ParseNamespacesGetAutoSubscriptionCreationResponse(rsp *http.Response) (*NamespacesGetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetAutoSubscriptionCreationResponse parses an HTTP response from a NamespacesSetAutoSubscriptionCreationWithResponse call
func ParseNamespacesSetAutoSubscriptionCreationResponse(rsp *http.Response) (*NamespacesSetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveAutoTopicCreationResponse parses an HTTP response from a NamespacesRemoveAutoTopicCreationWithResponse call
func ParseNamespacesRemoveAutoTopicCreationResponse(rsp *http.Response) (*NamespacesRemoveAutoTopicCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetAutoTopicCreationResponse parses an HTTP response from a NamespacesGetAutoTopicCreationWithResponse call
func ParseNamespacesGetAutoTopicCreationResponse(rsp *http.Response) (*NamespacesGetAutoTopicCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetAutoTopicCreationResponse parses an HTTP response from a NamespacesSetAutoTopicCreationWithResponse call
func ParseNamespacesSetAutoTopicCreationResponse(rsp *http.Response) (*NamespacesSetAutoTopicCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetAutoTopicCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveBacklogQuotaResponse parses an HTTP response from a NamespacesRemoveBacklogQuotaWithResponse call
func ParseNamespacesRemoveBacklogQuotaResponse(rsp *http.Response) (*NamespacesRemoveBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetBacklogQuotaResponse parses an HTTP response from a NamespacesSetBacklogQuotaWithResponse call
func ParseNamespacesSetBacklogQuotaResponse(rsp *http.Response) (*NamespacesSetBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetBacklogQuotaMapResponse parses an HTTP response from a NamespacesGetBacklogQuotaMapWithResponse call
func ParseNamespacesGetBacklogQuotaMapResponse(rsp *http.Response) (*NamespacesGetBacklogQuotaMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetBundlesDataResponse parses an HTTP response from a NamespacesGetBundlesDataWithResponse call
func ParseNamespacesGetBundlesDataResponse(rsp *http.Response) (*NamespacesGetBundlesDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetBundlesDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesClearNamespaceBacklogResponse parses an HTTP response from a NamespacesClearNamespaceBacklogWithResponse call
func ParseNamespacesClearNamespaceBacklogResponse(rsp *http.Response) (*NamespacesClearNamespaceBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesClearNamespaceBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesClearNamespaceBacklogForSubscriptionResponse parses an HTTP response from a NamespacesClearNamespaceBacklogForSubscriptionWithResponse call
func ParseNamespacesClearNamespaceBacklogForSubscriptionResponse(rsp *http.Response) (*NamespacesClearNamespaceBacklogForSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesClearNamespaceBacklogForSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesDeleteCompactionThresholdResponse parses an HTTP response from a NamespacesDeleteCompactionThresholdWithResponse call
func ParseNamespacesDeleteCompactionThresholdResponse(rsp *http.Response) (*NamespacesDeleteCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesDeleteCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetCompactionThresholdResponse parses an HTTP response from a NamespacesGetCompactionThresholdWithResponse call
func ParseNamespacesGetCompactionThresholdResponse(rsp *http.Response) (*NamespacesGetCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetCompactionThresholdResponse parses an HTTP response from a NamespacesSetCompactionThresholdWithResponse call
func ParseNamespacesSetCompactionThresholdResponse(rsp *http.Response) (*NamespacesSetCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveDeduplicationResponse parses an HTTP response from a NamespacesRemoveDeduplicationWithResponse call
func ParseNamespacesRemoveDeduplicationResponse(rsp *http.Response) (*NamespacesRemoveDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetDeduplicationResponse parses an HTTP response from a NamespacesGetDeduplicationWithResponse call
func ParseNamespacesGetDeduplicationResponse(rsp *http.Response) (*NamespacesGetDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesModifyDeduplicationResponse parses an HTTP response from a NamespacesModifyDeduplicationWithResponse call
func ParseNamespacesModifyDeduplicationResponse(rsp *http.Response) (*NamespacesModifyDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesModifyDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetDeduplicationSnapshotIntervalResponse parses an HTTP response from a NamespacesGetDeduplicationSnapshotIntervalWithResponse call
func ParseNamespacesGetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*NamespacesGetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetDeduplicationSnapshotIntervalResponse parses an HTTP response from a NamespacesSetDeduplicationSnapshotIntervalWithResponse call
func ParseNamespacesSetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*NamespacesSetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveDelayedDeliveryPoliciesResponse parses an HTTP response from a NamespacesRemoveDelayedDeliveryPoliciesWithResponse call
func ParseNamespacesRemoveDelayedDeliveryPoliciesResponse(rsp *http.Response) (*NamespacesRemoveDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetDelayedDeliveryPoliciesResponse parses an HTTP response from a NamespacesGetDelayedDeliveryPoliciesWithResponse call
func ParseNamespacesGetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*NamespacesGetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetDelayedDeliveryPoliciesResponse parses an HTTP response from a NamespacesSetDelayedDeliveryPoliciesWithResponse call
func ParseNamespacesSetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*NamespacesSetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesDeleteDispatchRateResponse parses an HTTP response from a NamespacesDeleteDispatchRateWithResponse call
func ParseNamespacesDeleteDispatchRateResponse(rsp *http.Response) (*NamespacesDeleteDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesDeleteDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetDispatchRateResponse parses an HTTP response from a NamespacesGetDispatchRateWithResponse call
func ParseNamespacesGetDispatchRateResponse(rsp *http.Response) (*NamespacesGetDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetDispatchRateResponse parses an HTTP response from a NamespacesSetDispatchRateWithResponse call
func ParseNamespacesSetDispatchRateResponse(rsp *http.Response) (*NamespacesSetDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetEncryptionRequiredResponse parses an HTTP response from a NamespacesGetEncryptionRequiredWithResponse call
func ParseNamespacesGetEncryptionRequiredResponse(rsp *http.Response) (*NamespacesGetEncryptionRequiredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetEncryptionRequiredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesModifyEncryptionRequiredResponse parses an HTTP response from a NamespacesModifyEncryptionRequiredWithResponse call
func ParseNamespacesModifyEncryptionRequiredResponse(rsp *http.Response) (*NamespacesModifyEncryptionRequiredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesModifyEncryptionRequiredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveNamespaceEntryFiltersResponse parses an HTTP response from a NamespacesRemoveNamespaceEntryFiltersWithResponse call
func ParseNamespacesRemoveNamespaceEntryFiltersResponse(rsp *http.Response) (*NamespacesRemoveNamespaceEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveNamespaceEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetEntryFiltersPerTopicResponse parses an HTTP response from a NamespacesGetEntryFiltersPerTopicWithResponse call
func ParseNamespacesGetEntryFiltersPerTopicResponse(rsp *http.Response) (*NamespacesGetEntryFiltersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetEntryFiltersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetEntryFiltersPerTopicResponse parses an HTTP response from a NamespacesSetEntryFiltersPerTopicWithResponse call
func ParseNamespacesSetEntryFiltersPerTopicResponse(rsp *http.Response) (*NamespacesSetEntryFiltersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetEntryFiltersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveInactiveTopicPoliciesResponse parses an HTTP response from a NamespacesRemoveInactiveTopicPoliciesWithResponse call
func ParseNamespacesRemoveInactiveTopicPoliciesResponse(rsp *http.Response) (*NamespacesRemoveInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetInactiveTopicPoliciesResponse parses an HTTP response from a NamespacesGetInactiveTopicPoliciesWithResponse call
func ParseNamespacesGetInactiveTopicPoliciesResponse(rsp *http.Response) (*NamespacesGetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetInactiveTopicPoliciesResponse parses an HTTP response from a NamespacesSetInactiveTopicPoliciesWithResponse call
func ParseNamespacesSetInactiveTopicPoliciesResponse(rsp *http.Response) (*NamespacesSetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetIsAllowAutoUpdateSchemaResponse parses an HTTP response from a NamespacesGetIsAllowAutoUpdateSchemaWithResponse call
func ParseNamespacesGetIsAllowAutoUpdateSchemaResponse(rsp *http.Response) (*NamespacesGetIsAllowAutoUpdateSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetIsAllowAutoUpdateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetIsAllowAutoUpdateSchemaResponse parses an HTTP response from a NamespacesSetIsAllowAutoUpdateSchemaWithResponse call
func ParseNamespacesSetIsAllowAutoUpdateSchemaResponse(rsp *http.Response) (*NamespacesSetIsAllowAutoUpdateSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetIsAllowAutoUpdateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveMaxConsumersPerSubscriptionResponse parses an HTTP response from a NamespacesRemoveMaxConsumersPerSubscriptionWithResponse call
func ParseNamespacesRemoveMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*NamespacesRemoveMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetMaxConsumersPerSubscriptionResponse parses an HTTP response from a NamespacesGetMaxConsumersPerSubscriptionWithResponse call
func ParseNamespacesGetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*NamespacesGetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetMaxConsumersPerSubscriptionResponse parses an HTTP response from a NamespacesSetMaxConsumersPerSubscriptionWithResponse call
func ParseNamespacesSetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*NamespacesSetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveMaxConsumersPerTopicResponse parses an HTTP response from a NamespacesRemoveMaxConsumersPerTopicWithResponse call
func ParseNamespacesRemoveMaxConsumersPerTopicResponse(rsp *http.Response) (*NamespacesRemoveMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetMaxConsumersPerTopicResponse parses an HTTP response from a NamespacesGetMaxConsumersPerTopicWithResponse call
func ParseNamespacesGetMaxConsumersPerTopicResponse(rsp *http.Response) (*NamespacesGetMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetMaxConsumersPerTopicResponse parses an HTTP response from a NamespacesSetMaxConsumersPerTopicWithResponse call
func ParseNamespacesSetMaxConsumersPerTopicResponse(rsp *http.Response) (*NamespacesSetMaxConsumersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetMaxConsumersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveMaxProducersPerTopicResponse parses an HTTP response from a NamespacesRemoveMaxProducersPerTopicWithResponse call
func ParseNamespacesRemoveMaxProducersPerTopicResponse(rsp *http.Response) (*NamespacesRemoveMaxProducersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetMaxProducersPerTopicResponse parses an HTTP response from a NamespacesGetMaxProducersPerTopicWithResponse call
func ParseNamespacesGetMaxProducersPerTopicResponse(rsp *http.Response) (*NamespacesGetMaxProducersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetMaxProducersPerTopicResponse parses an HTTP response from a NamespacesSetMaxProducersPerTopicWithResponse call
func ParseNamespacesSetMaxProducersPerTopicResponse(rsp *http.Response) (*NamespacesSetMaxProducersPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetMaxProducersPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveMaxSubscriptionsPerTopicResponse parses an HTTP response from a NamespacesRemoveMaxSubscriptionsPerTopicWithResponse call
func ParseNamespacesRemoveMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*NamespacesRemoveMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetMaxSubscriptionsPerTopicResponse parses an HTTP response from a NamespacesGetMaxSubscriptionsPerTopicWithResponse call
func ParseNamespacesGetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*NamespacesGetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetMaxSubscriptionsPerTopicResponse parses an HTTP response from a NamespacesSetMaxSubscriptionsPerTopicWithResponse call
func ParseNamespacesSetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*NamespacesSetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveMaxTopicsPerNamespaceResponse parses an HTTP response from a NamespacesRemoveMaxTopicsPerNamespaceWithResponse call
func ParseNamespacesRemoveMaxTopicsPerNamespaceResponse(rsp *http.Response) (*NamespacesRemoveMaxTopicsPerNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveMaxTopicsPerNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetMaxTopicsPerNamespaceResponse parses an HTTP response from a NamespacesGetMaxTopicsPerNamespaceWithResponse call
func ParseNamespacesGetMaxTopicsPerNamespaceResponse(rsp *http.Response) (*NamespacesGetMaxTopicsPerNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetMaxTopicsPerNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetMaxTopicsPerNamespaceResponse parses an HTTP response from a NamespacesSetMaxTopicsPerNamespaceWithResponse call
func ParseNamespacesSetMaxTopicsPerNamespaceResponse(rsp *http.Response) (*NamespacesSetMaxTopicsPerNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetMaxTopicsPerNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveMaxUnackedmessagesPerConsumerResponse parses an HTTP response from a NamespacesRemoveMaxUnackedmessagesPerConsumerWithResponse call
func ParseNamespacesRemoveMaxUnackedmessagesPerConsumerResponse(rsp *http.Response) (*NamespacesRemoveMaxUnackedmessagesPerConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveMaxUnackedmessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetMaxUnackedMessagesPerConsumerResponse parses an HTTP response from a NamespacesGetMaxUnackedMessagesPerConsumerWithResponse call
func ParseNamespacesGetMaxUnackedMessagesPerConsumerResponse(rsp *http.Response) (*NamespacesGetMaxUnackedMessagesPerConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetMaxUnackedMessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetMaxUnackedMessagesPerConsumerResponse parses an HTTP response from a NamespacesSetMaxUnackedMessagesPerConsumerWithResponse call
func ParseNamespacesSetMaxUnackedMessagesPerConsumerResponse(rsp *http.Response) (*NamespacesSetMaxUnackedMessagesPerConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetMaxUnackedMessagesPerConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse parses an HTTP response from a NamespacesRemoveMaxUnackedmessagesPerSubscriptionWithResponse call
func ParseNamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse(rsp *http.Response) (*NamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveMaxUnackedmessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetMaxUnackedmessagesPerSubscriptionResponse parses an HTTP response from a NamespacesGetMaxUnackedmessagesPerSubscriptionWithResponse call
func ParseNamespacesGetMaxUnackedmessagesPerSubscriptionResponse(rsp *http.Response) (*NamespacesGetMaxUnackedmessagesPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetMaxUnackedmessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetMaxUnackedMessagesPerSubscriptionResponse parses an HTTP response from a NamespacesSetMaxUnackedMessagesPerSubscriptionWithResponse call
func ParseNamespacesSetMaxUnackedMessagesPerSubscriptionResponse(rsp *http.Response) (*NamespacesSetMaxUnackedMessagesPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetMaxUnackedMessagesPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveNamespaceMessageTTLResponse parses an HTTP response from a NamespacesRemoveNamespaceMessageTTLWithResponse call
func ParseNamespacesRemoveNamespaceMessageTTLResponse(rsp *http.Response) (*NamespacesRemoveNamespaceMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetNamespaceMessageTTLResponse parses an HTTP response from a NamespacesGetNamespaceMessageTTLWithResponse call
func ParseNamespacesGetNamespaceMessageTTLResponse(rsp *http.Response) (*NamespacesGetNamespaceMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesSetNamespaceMessageTTLResponse parses an HTTP response from a NamespacesSetNamespaceMessageTTLWithResponse call
func ParseNamespacesSetNamespaceMessageTTLResponse(rsp *http.Response) (*NamespacesSetNamespaceMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetNamespaceMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesClearOffloadDeletionLagResponse parses an HTTP response from a NamespacesClearOffloadDeletionLagWithResponse call
func ParseNamespacesClearOffloadDeletionLagResponse(rsp *http.Response) (*NamespacesClearOffloadDeletionLagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesClearOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetOffloadDeletionLagResponse parses an HTTP response from a NamespacesGetOffloadDeletionLagWithResponse call
func ParseNamespacesGetOffloadDeletionLagResponse(rsp *http.Response) (*NamespacesGetOffloadDeletionLagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetOffloadDeletionLagResponse parses an HTTP response from a NamespacesSetOffloadDeletionLagWithResponse call
func ParseNamespacesSetOffloadDeletionLagResponse(rsp *http.Response) (*NamespacesSetOffloadDeletionLagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetOffloadDeletionLagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetOffloadPoliciesResponse parses an HTTP response from a NamespacesGetOffloadPoliciesWithResponse call
func ParseNamespacesGetOffloadPoliciesResponse(rsp *http.Response) (*NamespacesGetOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetOffloadPoliciesResponse parses an HTTP response from a NamespacesSetOffloadPoliciesWithResponse call
func ParseNamespacesSetOffloadPoliciesResponse(rsp *http.Response) (*NamespacesSetOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetOffloadThresholdResponse parses an HTTP response from a NamespacesGetOffloadThresholdWithResponse call
func ParseNamespacesGetOffloadThresholdResponse(rsp *http.Response) (*NamespacesGetOffloadThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetOffloadThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetOffloadThresholdResponse parses an HTTP response from a NamespacesSetOffloadThresholdWithResponse call
func ParseNamespacesSetOffloadThresholdResponse(rsp *http.Response) (*NamespacesSetOffloadThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetOffloadThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetOffloadThresholdInSecondsResponse parses an HTTP response from a NamespacesGetOffloadThresholdInSecondsWithResponse call
func ParseNamespacesGetOffloadThresholdInSecondsResponse(rsp *http.Response) (*NamespacesGetOffloadThresholdInSecondsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetOffloadThresholdInSecondsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetOffloadThresholdInSecondsResponse parses an HTTP response from a NamespacesSetOffloadThresholdInSecondsWithResponse call
func ParseNamespacesSetOffloadThresholdInSecondsResponse(rsp *http.Response) (*NamespacesSetOffloadThresholdInSecondsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetOffloadThresholdInSecondsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetPermissionsResponse parses an HTTP response from a NamespacesGetPermissionsWithResponse call
func ParseNamespacesGetPermissionsResponse(rsp *http.Response) (*NamespacesGetPermissionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetPermissionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetPermissionOnSubscriptionResponse parses an HTTP response from a NamespacesGetPermissionOnSubscriptionWithResponse call
func ParseNamespacesGetPermissionOnSubscriptionResponse(rsp *http.Response) (*NamespacesGetPermissionOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetPermissionOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRevokePermissionsOnNamespaceResponse parses an HTTP response from a NamespacesRevokePermissionsOnNamespaceWithResponse call
func ParseNamespacesRevokePermissionsOnNamespaceResponse(rsp *http.Response) (*NamespacesRevokePermissionsOnNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRevokePermissionsOnNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGrantPermissionOnNamespaceResponse parses an HTTP response from a NamespacesGrantPermissionOnNamespaceWithResponse call
func ParseNamespacesGrantPermissionOnNamespaceResponse(rsp *http.Response) (*NamespacesGrantPermissionOnNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGrantPermissionOnNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesDeletePersistenceResponse parses an HTTP response from a NamespacesDeletePersistenceWithResponse call
func ParseNamespacesDeletePersistenceResponse(rsp *http.Response) (*NamespacesDeletePersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesDeletePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetPersistenceResponse parses an HTTP response from a NamespacesGetPersistenceWithResponse call
func ParseNamespacesGetPersistenceResponse(rsp *http.Response) (*NamespacesGetPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetPersistenceResponse parses an HTTP response from a NamespacesSetPersistenceWithResponse call
func ParseNamespacesSetPersistenceResponse(rsp *http.Response) (*NamespacesSetPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetBookieAffinityGroupResponse parses an HTTP response from a NamespacesSetBookieAffinityGroupWithResponse call
func ParseNamespacesSetBookieAffinityGroupResponse(rsp *http.Response) (*NamespacesSetBookieAffinityGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetBookieAffinityGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesClearPropertiesResponse parses an HTTP response from a NamespacesClearPropertiesWithResponse call
func ParseNamespacesClearPropertiesResponse(rsp *http.Response) (*NamespacesClearPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesClearPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetPropertiesResponse parses an HTTP response from a NamespacesGetPropertiesWithResponse call
func ParseNamespacesGetPropertiesResponse(rsp *http.Response) (*NamespacesGetPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetPropertiesResponse parses an HTTP response from a NamespacesSetPropertiesWithResponse call
func ParseNamespacesSetPropertiesResponse(rsp *http.Response) (*NamespacesSetPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemovePropertyResponse parses an HTTP response from a NamespacesRemovePropertyWithResponse call
func ParseNamespacesRemovePropertyResponse(rsp *http.Response) (*NamespacesRemovePropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemovePropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetPropertyResponse parses an HTTP response from a NamespacesGetPropertyWithResponse call
func ParseNamespacesGetPropertyResponse(rsp *http.Response) (*NamespacesGetPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetPropertyResponse parses an HTTP response from a NamespacesSetPropertyWithResponse call
func ParseNamespacesSetPropertyResponse(rsp *http.Response) (*NamespacesSetPropertyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetPropertyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveOffloadPoliciesResponse parses an HTTP response from a NamespacesRemoveOffloadPoliciesWithResponse call
func ParseNamespacesRemoveOffloadPoliciesResponse(rsp *http.Response) (*NamespacesRemoveOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetNamespaceReplicationClustersResponse parses an HTTP response from a NamespacesGetNamespaceReplicationClustersWithResponse call
func ParseNamespacesGetNamespaceReplicationClustersResponse(rsp *http.Response) (*NamespacesGetNamespaceReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetNamespaceReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesSetNamespaceReplicationClustersResponse parses an HTTP response from a NamespacesSetNamespaceReplicationClustersWithResponse call
func ParseNamespacesSetNamespaceReplicationClustersResponse(rsp *http.Response) (*NamespacesSetNamespaceReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetNamespaceReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveReplicatorDispatchRateResponse parses an HTTP response from a NamespacesRemoveReplicatorDispatchRateWithResponse call
func ParseNamespacesRemoveReplicatorDispatchRateResponse(rsp *http.Response) (*NamespacesRemoveReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetReplicatorDispatchRateResponse parses an HTTP response from a NamespacesGetReplicatorDispatchRateWithResponse call
func ParseNamespacesGetReplicatorDispatchRateResponse(rsp *http.Response) (*NamespacesGetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetReplicatorDispatchRateResponse parses an HTTP response from a NamespacesSetReplicatorDispatchRateWithResponse call
func ParseNamespacesSetReplicatorDispatchRateResponse(rsp *http.Response) (*NamespacesSetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveNamespaceResourceGroupResponse parses an HTTP response from a NamespacesRemoveNamespaceResourceGroupWithResponse call
func ParseNamespacesRemoveNamespaceResourceGroupResponse(rsp *http.Response) (*NamespacesRemoveNamespaceResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetNamespaceResourceGroupResponse parses an HTTP response from a NamespacesGetNamespaceResourceGroupWithResponse call
func ParseNamespacesGetNamespaceResourceGroupResponse(rsp *http.Response) (*NamespacesGetNamespaceResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetNamespaceResourceGroupResponse parses an HTTP response from a NamespacesSetNamespaceResourceGroupWithResponse call
func ParseNamespacesSetNamespaceResourceGroupResponse(rsp *http.Response) (*NamespacesSetNamespaceResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetNamespaceResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveRetentionResponse parses an HTTP response from a NamespacesRemoveRetentionWithResponse call
func ParseNamespacesRemoveRetentionResponse(rsp *http.Response) (*NamespacesRemoveRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetRetentionResponse parses an HTTP response from a NamespacesGetRetentionWithResponse call
func ParseNamespacesGetRetentionResponse(rsp *http.Response) (*NamespacesGetRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetRetentionResponse parses an HTTP response from a NamespacesSetRetentionWithResponse call
func ParseNamespacesSetRetentionResponse(rsp *http.Response) (*NamespacesSetRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesScanOffloadedLedgersResponse parses an HTTP response from a NamespacesScanOffloadedLedgersWithResponse call
func ParseNamespacesScanOffloadedLedgersResponse(rsp *http.Response) (*NamespacesScanOffloadedLedgersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesScanOffloadedLedgersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse parses an HTTP response from a NamespacesGetSchemaAutoUpdateCompatibilityStrategyWithResponse call
func ParseNamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse(rsp *http.Response) (*NamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetSchemaAutoUpdateCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse parses an HTTP response from a NamespacesSetSchemaAutoUpdateCompatibilityStrategyWithResponse call
func ParseNamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse(rsp *http.Response) (*NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetSchemaAutoUpdateCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetSchemaCompatibilityStrategyResponse parses an HTTP response from a NamespacesGetSchemaCompatibilityStrategyWithResponse call
func ParseNamespacesGetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*NamespacesGetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetSchemaCompatibilityStrategyResponse parses an HTTP response from a NamespacesSetSchemaCompatibilityStrategyWithResponse call
func ParseNamespacesSetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*NamespacesSetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetSchemaValidtionEnforcedResponse parses an HTTP response from a NamespacesGetSchemaValidtionEnforcedWithResponse call
func ParseNamespacesGetSchemaValidtionEnforcedResponse(rsp *http.Response) (*NamespacesGetSchemaValidtionEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetSchemaValidtionEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetSchemaValidationEnforcedResponse parses an HTTP response from a NamespacesSetSchemaValidationEnforcedWithResponse call
func ParseNamespacesSetSchemaValidationEnforcedResponse(rsp *http.Response) (*NamespacesSetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesDeleteSubscribeRateResponse parses an HTTP response from a NamespacesDeleteSubscribeRateWithResponse call
func ParseNamespacesDeleteSubscribeRateResponse(rsp *http.Response) (*NamespacesDeleteSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesDeleteSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetSubscribeRateResponse parses an HTTP response from a NamespacesGetSubscribeRateWithResponse call
func ParseNamespacesGetSubscribeRateResponse(rsp *http.Response) (*NamespacesGetSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetSubscribeRateResponse parses an HTTP response from a NamespacesSetSubscribeRateWithResponse call
func ParseNamespacesSetSubscribeRateResponse(rsp *http.Response) (*NamespacesSetSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetSubscriptionAuthModeResponse parses an HTTP response from a NamespacesGetSubscriptionAuthModeWithResponse call
func ParseNamespacesGetSubscriptionAuthModeResponse(rsp *http.Response) (*NamespacesGetSubscriptionAuthModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetSubscriptionAuthModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetSubscriptionAuthModeResponse parses an HTTP response from a NamespacesSetSubscriptionAuthModeWithResponse call
func ParseNamespacesSetSubscriptionAuthModeResponse(rsp *http.Response) (*NamespacesSetSubscriptionAuthModeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetSubscriptionAuthModeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesDeleteSubscriptionDispatchRateResponse parses an HTTP response from a NamespacesDeleteSubscriptionDispatchRateWithResponse call
func ParseNamespacesDeleteSubscriptionDispatchRateResponse(rsp *http.Response) (*NamespacesDeleteSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesDeleteSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetSubscriptionDispatchRateResponse parses an HTTP response from a NamespacesGetSubscriptionDispatchRateWithResponse call
func ParseNamespacesGetSubscriptionDispatchRateResponse(rsp *http.Response) (*NamespacesGetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetSubscriptionDispatchRateResponse parses an HTTP response from a NamespacesSetSubscriptionDispatchRateWithResponse call
func ParseNamespacesSetSubscriptionDispatchRateResponse(rsp *http.Response) (*NamespacesSetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveSubscriptionExpirationTimeResponse parses an HTTP response from a NamespacesRemoveSubscriptionExpirationTimeWithResponse call
func ParseNamespacesRemoveSubscriptionExpirationTimeResponse(rsp *http.Response) (*NamespacesRemoveSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetSubscriptionExpirationTimeResponse parses an HTTP response from a NamespacesGetSubscriptionExpirationTimeWithResponse call
func ParseNamespacesGetSubscriptionExpirationTimeResponse(rsp *http.Response) (*NamespacesGetSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetSubscriptionExpirationTimeResponse parses an HTTP response from a NamespacesSetSubscriptionExpirationTimeWithResponse call
func ParseNamespacesSetSubscriptionExpirationTimeResponse(rsp *http.Response) (*NamespacesSetSubscriptionExpirationTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetSubscriptionExpirationTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesRemoveSubscriptionTypesEnabledResponse parses an HTTP response from a NamespacesRemoveSubscriptionTypesEnabledWithResponse call
func ParseNamespacesRemoveSubscriptionTypesEnabledResponse(rsp *http.Response) (*NamespacesRemoveSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesRemoveSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetSubscriptionTypesEnabledResponse parses an HTTP response from a NamespacesGetSubscriptionTypesEnabledWithResponse call
func ParseNamespacesGetSubscriptionTypesEnabledResponse(rsp *http.Response) (*NamespacesGetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSetSubscriptionTypesEnabledResponse parses an HTTP response from a NamespacesSetSubscriptionTypesEnabledWithResponse call
func ParseNamespacesSetSubscriptionTypesEnabledResponse(rsp *http.Response) (*NamespacesSetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetTopicsResponse parses an HTTP response from a NamespacesGetTopicsWithResponse call
func ParseNamespacesGetTopicsResponse(rsp *http.Response) (*NamespacesGetTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNamespacesUnloadNamespaceResponse parses an HTTP response from a NamespacesUnloadNamespaceWithResponse call
func ParseNamespacesUnloadNamespaceResponse(rsp *http.Response) (*NamespacesUnloadNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesUnloadNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesUnsubscribeNamespaceResponse parses an HTTP response from a NamespacesUnsubscribeNamespaceWithResponse call
func ParseNamespacesUnsubscribeNamespaceResponse(rsp *http.Response) (*NamespacesUnsubscribeNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesUnsubscribeNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesDeleteNamespaceBundleResponse parses an HTTP response from a NamespacesDeleteNamespaceBundleWithResponse call
func ParseNamespacesDeleteNamespaceBundleResponse(rsp *http.Response) (*NamespacesDeleteNamespaceBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesDeleteNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesClearNamespaceBundleBacklogResponse parses an HTTP response from a NamespacesClearNamespaceBundleBacklogWithResponse call
func ParseNamespacesClearNamespaceBundleBacklogResponse(rsp *http.Response) (*NamespacesClearNamespaceBundleBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesClearNamespaceBundleBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesClearNamespaceBundleBacklogForSubscriptionResponse parses an HTTP response from a NamespacesClearNamespaceBundleBacklogForSubscriptionWithResponse call
func ParseNamespacesClearNamespaceBundleBacklogForSubscriptionResponse(rsp *http.Response) (*NamespacesClearNamespaceBundleBacklogForSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesClearNamespaceBundleBacklogForSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesSplitNamespaceBundleResponse parses an HTTP response from a NamespacesSplitNamespaceBundleWithResponse call
func ParseNamespacesSplitNamespaceBundleResponse(rsp *http.Response) (*NamespacesSplitNamespaceBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesSplitNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesGetTopicHashPositionsResponse parses an HTTP response from a NamespacesGetTopicHashPositionsWithResponse call
func ParseNamespacesGetTopicHashPositionsResponse(rsp *http.Response) (*NamespacesGetTopicHashPositionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesGetTopicHashPositionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesUnloadNamespaceBundleResponse parses an HTTP response from a NamespacesUnloadNamespaceBundleWithResponse call
func ParseNamespacesUnloadNamespaceBundleResponse(rsp *http.Response) (*NamespacesUnloadNamespaceBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesUnloadNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNamespacesUnsubscribeNamespaceBundleResponse parses an HTTP response from a NamespacesUnsubscribeNamespaceBundleWithResponse call
func ParseNamespacesUnsubscribeNamespaceBundleResponse(rsp *http.Response) (*NamespacesUnsubscribeNamespaceBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NamespacesUnsubscribeNamespaceBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetListResponse parses an HTTP response from a NonPersistentTopicsGetListWithResponse call
func ParseNonPersistentTopicsGetListResponse(rsp *http.Response) (*NonPersistentTopicsGetListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsGetPartitionedTopicListResponse parses an HTTP response from a NonPersistentTopicsGetPartitionedTopicListWithResponse call
func ParseNonPersistentTopicsGetPartitionedTopicListResponse(rsp *http.Response) (*NonPersistentTopicsGetPartitionedTopicListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetPartitionedTopicListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsGetListFromBundleResponse parses an HTTP response from a NonPersistentTopicsGetListFromBundleWithResponse call
func ParseNonPersistentTopicsGetListFromBundleResponse(rsp *http.Response) (*NonPersistentTopicsGetListFromBundleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetListFromBundleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsDeleteTopicResponse parses an HTTP response from a NonPersistentTopicsDeleteTopicWithResponse call
func ParseNonPersistentTopicsDeleteTopicResponse(rsp *http.Response) (*NonPersistentTopicsDeleteTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeleteTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsCreateNonPartitionedTopicResponse parses an HTTP response from a NonPersistentTopicsCreateNonPartitionedTopicWithResponse call
func ParseNonPersistentTopicsCreateNonPartitionedTopicResponse(rsp *http.Response) (*NonPersistentTopicsCreateNonPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsCreateNonPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsExpireMessagesForAllSubscriptionsResponse parses an HTTP response from a NonPersistentTopicsExpireMessagesForAllSubscriptionsWithResponse call
func ParseNonPersistentTopicsExpireMessagesForAllSubscriptionsResponse(rsp *http.Response) (*NonPersistentTopicsExpireMessagesForAllSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsExpireMessagesForAllSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveAutoSubscriptionCreationResponse parses an HTTP response from a NonPersistentTopicsRemoveAutoSubscriptionCreationWithResponse call
func ParseNonPersistentTopicsRemoveAutoSubscriptionCreationResponse(rsp *http.Response) (*NonPersistentTopicsRemoveAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetAutoSubscriptionCreationResponse parses an HTTP response from a NonPersistentTopicsGetAutoSubscriptionCreationWithResponse call
func ParseNonPersistentTopicsGetAutoSubscriptionCreationResponse(rsp *http.Response) (*NonPersistentTopicsGetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSetAutoSubscriptionCreationResponse parses an HTTP response from a NonPersistentTopicsSetAutoSubscriptionCreationWithResponse call
func ParseNonPersistentTopicsSetAutoSubscriptionCreationResponse(rsp *http.Response) (*NonPersistentTopicsSetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetBacklogResponse parses an HTTP response from a NonPersistentTopicsGetBacklogWithResponse call
func ParseNonPersistentTopicsGetBacklogResponse(rsp *http.Response) (*NonPersistentTopicsGetBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistentOfflineTopicStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveBacklogQuotaResponse parses an HTTP response from a NonPersistentTopicsRemoveBacklogQuotaWithResponse call
func ParseNonPersistentTopicsRemoveBacklogQuotaResponse(rsp *http.Response) (*NonPersistentTopicsRemoveBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSetBacklogQuotaResponse parses an HTTP response from a NonPersistentTopicsSetBacklogQuotaWithResponse call
func ParseNonPersistentTopicsSetBacklogQuotaResponse(rsp *http.Response) (*NonPersistentTopicsSetBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetBacklogQuotaMapResponse parses an HTTP response from a NonPersistentTopicsGetBacklogQuotaMapWithResponse call
func ParseNonPersistentTopicsGetBacklogQuotaMapResponse(rsp *http.Response) (*NonPersistentTopicsGetBacklogQuotaMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]BacklogQuota
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsGetBacklogSizeByMessageIdResponse parses an HTTP response from a NonPersistentTopicsGetBacklogSizeByMessageIdWithResponse call
func ParseNonPersistentTopicsGetBacklogSizeByMessageIdResponse(rsp *http.Response) (*NonPersistentTopicsGetBacklogSizeByMessageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetBacklogSizeByMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsCompactionStatusResponse parses an HTTP response from a NonPersistentTopicsCompactionStatusWithResponse call
func ParseNonPersistentTopicsCompactionStatusResponse(rsp *http.Response) (*NonPersistentTopicsCompactionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsCompactionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsCompactResponse parses an HTTP response from a NonPersistentTopicsCompactWithResponse call
func ParseNonPersistentTopicsCompactResponse(rsp *http.Response) (*NonPersistentTopicsCompactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsCompactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveCompactionThresholdResponse parses an HTTP response from a NonPersistentTopicsRemoveCompactionThresholdWithResponse call
func ParseNonPersistentTopicsRemoveCompactionThresholdResponse(rsp *http.Response) (*NonPersistentTopicsRemoveCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetCompactionThresholdResponse parses an HTTP response from a NonPersistentTopicsGetCompactionThresholdWithResponse call
func ParseNonPersistentTopicsGetCompactionThresholdResponse(rsp *http.Response) (*NonPersistentTopicsGetCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetCompactionThresholdResponse parses an HTTP response from a NonPersistentTopicsSetCompactionThresholdWithResponse call
func ParseNonPersistentTopicsSetCompactionThresholdResponse(rsp *http.Response) (*NonPersistentTopicsSetCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsCreateMissedPartitionsResponse parses an HTTP response from a NonPersistentTopicsCreateMissedPartitionsWithResponse call
func ParseNonPersistentTopicsCreateMissedPartitionsResponse(rsp *http.Response) (*NonPersistentTopicsCreateMissedPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsCreateMissedPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveDeduplicationResponse parses an HTTP response from a NonPersistentTopicsRemoveDeduplicationWithResponse call
func ParseNonPersistentTopicsRemoveDeduplicationResponse(rsp *http.Response) (*NonPersistentTopicsRemoveDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetDeduplicationResponse parses an HTTP response from a NonPersistentTopicsGetDeduplicationWithResponse call
func ParseNonPersistentTopicsGetDeduplicationResponse(rsp *http.Response) (*NonPersistentTopicsGetDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetDeduplicationResponse parses an HTTP response from a NonPersistentTopicsSetDeduplicationWithResponse call
func ParseNonPersistentTopicsSetDeduplicationResponse(rsp *http.Response) (*NonPersistentTopicsSetDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse parses an HTTP response from a NonPersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse call
func ParseNonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*NonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeleteDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetDeduplicationSnapshotIntervalResponse parses an HTTP response from a NonPersistentTopicsGetDeduplicationSnapshotIntervalWithResponse call
func ParseNonPersistentTopicsGetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*NonPersistentTopicsGetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetDeduplicationSnapshotIntervalResponse parses an HTTP response from a NonPersistentTopicsSetDeduplicationSnapshotIntervalWithResponse call
func ParseNonPersistentTopicsSetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*NonPersistentTopicsSetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse parses an HTTP response from a NonPersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse call
func ParseNonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeleteDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetDelayedDeliveryPoliciesResponse parses an HTTP response from a NonPersistentTopicsGetDelayedDeliveryPoliciesWithResponse call
func ParseNonPersistentTopicsGetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsGetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DelayedDeliveryPolicies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetDelayedDeliveryPoliciesResponse parses an HTTP response from a NonPersistentTopicsSetDelayedDeliveryPoliciesWithResponse call
func ParseNonPersistentTopicsSetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsSetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveDispatchRateResponse parses an HTTP response from a NonPersistentTopicsRemoveDispatchRateWithResponse call
func ParseNonPersistentTopicsRemoveDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsRemoveDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetDispatchRateResponse parses an HTTP response from a NonPersistentTopicsGetDispatchRateWithResponse call
func ParseNonPersistentTopicsGetDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsGetDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSetDispatchRateResponse parses an HTTP response from a NonPersistentTopicsSetDispatchRateWithResponse call
func ParseNonPersistentTopicsSetDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsSetDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveEntryFiltersResponse parses an HTTP response from a NonPersistentTopicsRemoveEntryFiltersWithResponse call
func ParseNonPersistentTopicsRemoveEntryFiltersResponse(rsp *http.Response) (*NonPersistentTopicsRemoveEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetEntryFiltersResponse parses an HTTP response from a NonPersistentTopicsGetEntryFiltersWithResponse call
func ParseNonPersistentTopicsGetEntryFiltersResponse(rsp *http.Response) (*NonPersistentTopicsGetEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSetEntryFiltersResponse parses an HTTP response from a NonPersistentTopicsSetEntryFiltersWithResponse call
func ParseNonPersistentTopicsSetEntryFiltersResponse(rsp *http.Response) (*NonPersistentTopicsSetEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsExamineMessageResponse parses an HTTP response from a NonPersistentTopicsExamineMessageWithResponse call
func ParseNonPersistentTopicsExamineMessageResponse(rsp *http.Response) (*NonPersistentTopicsExamineMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsExamineMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsDeleteInactiveTopicPoliciesResponse parses an HTTP response from a NonPersistentTopicsDeleteInactiveTopicPoliciesWithResponse call
func ParseNonPersistentTopicsDeleteInactiveTopicPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsDeleteInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeleteInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetInactiveTopicPoliciesResponse parses an HTTP response from a NonPersistentTopicsGetInactiveTopicPoliciesWithResponse call
func ParseNonPersistentTopicsGetInactiveTopicPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsGetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InactiveTopicPolicies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetInactiveTopicPoliciesResponse parses an HTTP response from a NonPersistentTopicsSetInactiveTopicPoliciesWithResponse call
func ParseNonPersistentTopicsSetInactiveTopicPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsSetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetManagedLedgerInfoResponse parses an HTTP response from a NonPersistentTopicsGetManagedLedgerInfoWithResponse call
func ParseNonPersistentTopicsGetManagedLedgerInfoResponse(rsp *http.Response) (*NonPersistentTopicsGetManagedLedgerInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetManagedLedgerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartitionedManagedLedgerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsGetInternalStatsResponse parses an HTTP response from a NonPersistentTopicsGetInternalStatsWithResponse call
func ParseNonPersistentTopicsGetInternalStatsResponse(rsp *http.Response) (*NonPersistentTopicsGetInternalStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetInternalStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetLastMessageIdResponse parses an HTTP response from a NonPersistentTopicsGetLastMessageIdWithResponse call
func ParseNonPersistentTopicsGetLastMessageIdResponse(rsp *http.Response) (*NonPersistentTopicsGetLastMessageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetLastMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMessageByIdResponse parses an HTTP response from a NonPersistentTopicsGetMessageByIdWithResponse call
func ParseNonPersistentTopicsGetMessageByIdResponse(rsp *http.Response) (*NonPersistentTopicsGetMessageByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMessageByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveMaxConsumersResponse parses an HTTP response from a NonPersistentTopicsRemoveMaxConsumersWithResponse call
func ParseNonPersistentTopicsRemoveMaxConsumersResponse(rsp *http.Response) (*NonPersistentTopicsRemoveMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMaxConsumersResponse parses an HTTP response from a NonPersistentTopicsGetMaxConsumersWithResponse call
func ParseNonPersistentTopicsGetMaxConsumersResponse(rsp *http.Response) (*NonPersistentTopicsGetMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetMaxConsumersResponse parses an HTTP response from a NonPersistentTopicsSetMaxConsumersWithResponse call
func ParseNonPersistentTopicsSetMaxConsumersResponse(rsp *http.Response) (*NonPersistentTopicsSetMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse parses an HTTP response from a NonPersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse call
func ParseNonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*NonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMaxConsumersPerSubscriptionResponse parses an HTTP response from a NonPersistentTopicsGetMaxConsumersPerSubscriptionWithResponse call
func ParseNonPersistentTopicsGetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*NonPersistentTopicsGetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetMaxConsumersPerSubscriptionResponse parses an HTTP response from a NonPersistentTopicsSetMaxConsumersPerSubscriptionWithResponse call
func ParseNonPersistentTopicsSetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*NonPersistentTopicsSetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveMaxMessageSizeResponse parses an HTTP response from a NonPersistentTopicsRemoveMaxMessageSizeWithResponse call
func ParseNonPersistentTopicsRemoveMaxMessageSizeResponse(rsp *http.Response) (*NonPersistentTopicsRemoveMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMaxMessageSizeResponse parses an HTTP response from a NonPersistentTopicsGetMaxMessageSizeWithResponse call
func ParseNonPersistentTopicsGetMaxMessageSizeResponse(rsp *http.Response) (*NonPersistentTopicsGetMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetMaxMessageSizeResponse parses an HTTP response from a NonPersistentTopicsSetMaxMessageSizeWithResponse call
func ParseNonPersistentTopicsSetMaxMessageSizeResponse(rsp *http.Response) (*NonPersistentTopicsSetMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveMaxProducersResponse parses an HTTP response from a NonPersistentTopicsRemoveMaxProducersWithResponse call
func ParseNonPersistentTopicsRemoveMaxProducersResponse(rsp *http.Response) (*NonPersistentTopicsRemoveMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMaxProducersResponse parses an HTTP response from a NonPersistentTopicsGetMaxProducersWithResponse call
func ParseNonPersistentTopicsGetMaxProducersResponse(rsp *http.Response) (*NonPersistentTopicsGetMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetMaxProducersResponse parses an HTTP response from a NonPersistentTopicsSetMaxProducersWithResponse call
func ParseNonPersistentTopicsSetMaxProducersResponse(rsp *http.Response) (*NonPersistentTopicsSetMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse parses an HTTP response from a NonPersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse call
func ParseNonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*NonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMaxSubscriptionsPerTopicResponse parses an HTTP response from a NonPersistentTopicsGetMaxSubscriptionsPerTopicWithResponse call
func ParseNonPersistentTopicsGetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*NonPersistentTopicsGetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetMaxSubscriptionsPerTopicResponse parses an HTTP response from a NonPersistentTopicsSetMaxSubscriptionsPerTopicWithResponse call
func ParseNonPersistentTopicsSetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*NonPersistentTopicsSetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse call
func ParseNonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a NonPersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse call
func ParseNonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*NonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a NonPersistentTopicsSetMaxUnackedMessagesOnConsumerWithResponse call
func ParseNonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*NonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseNonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseNonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithResponse call
func ParseNonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveMessageTTLResponse parses an HTTP response from a NonPersistentTopicsRemoveMessageTTLWithResponse call
func ParseNonPersistentTopicsRemoveMessageTTLResponse(rsp *http.Response) (*NonPersistentTopicsRemoveMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMessageTTLResponse parses an HTTP response from a NonPersistentTopicsGetMessageTTLWithResponse call
func ParseNonPersistentTopicsGetMessageTTLResponse(rsp *http.Response) (*NonPersistentTopicsGetMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetMessageTTLResponse parses an HTTP response from a NonPersistentTopicsSetMessageTTLWithResponse call
func ParseNonPersistentTopicsSetMessageTTLResponse(rsp *http.Response) (*NonPersistentTopicsSetMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetMessageIdByTimestampResponse parses an HTTP response from a NonPersistentTopicsGetMessageIdByTimestampWithResponse call
func ParseNonPersistentTopicsGetMessageIdByTimestampResponse(rsp *http.Response) (*NonPersistentTopicsGetMessageIdByTimestampResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetMessageIdByTimestampResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsOffloadStatusResponse parses an HTTP response from a NonPersistentTopicsOffloadStatusWithResponse call
func ParseNonPersistentTopicsOffloadStatusResponse(rsp *http.Response) (*NonPersistentTopicsOffloadStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsOffloadStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsTriggerOffloadResponse parses an HTTP response from a NonPersistentTopicsTriggerOffloadWithResponse call
func ParseNonPersistentTopicsTriggerOffloadResponse(rsp *http.Response) (*NonPersistentTopicsTriggerOffloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsTriggerOffloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveOffloadPoliciesResponse parses an HTTP response from a NonPersistentTopicsRemoveOffloadPoliciesWithResponse call
func ParseNonPersistentTopicsRemoveOffloadPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsRemoveOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetOffloadPoliciesResponse parses an HTTP response from a NonPersistentTopicsGetOffloadPoliciesWithResponse call
func ParseNonPersistentTopicsGetOffloadPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsGetOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSetOffloadPoliciesResponse parses an HTTP response from a NonPersistentTopicsSetOffloadPoliciesWithResponse call
func ParseNonPersistentTopicsSetOffloadPoliciesResponse(rsp *http.Response) (*NonPersistentTopicsSetOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetPartitionedStatsInternalResponse parses an HTTP response from a NonPersistentTopicsGetPartitionedStatsInternalWithResponse call
func ParseNonPersistentTopicsGetPartitionedStatsInternalResponse(rsp *http.Response) (*NonPersistentTopicsGetPartitionedStatsInternalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetPartitionedStatsInternalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartitionedTopicInternalStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsGetPartitionedStatsResponse parses an HTTP response from a NonPersistentTopicsGetPartitionedStatsWithResponse call
func ParseNonPersistentTopicsGetPartitionedStatsResponse(rsp *http.Response) (*NonPersistentTopicsGetPartitionedStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetPartitionedStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NonPersistentPartitionedTopicStatsImpl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsDeletePartitionedTopicResponse parses an HTTP response from a NonPersistentTopicsDeletePartitionedTopicWithResponse call
func ParseNonPersistentTopicsDeletePartitionedTopicResponse(rsp *http.Response) (*NonPersistentTopicsDeletePartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeletePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetPartitionedMetadataResponse parses an HTTP response from a NonPersistentTopicsGetPartitionedMetadataWithResponse call
func ParseNonPersistentTopicsGetPartitionedMetadataResponse(rsp *http.Response) (*NonPersistentTopicsGetPartitionedMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetPartitionedMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsUpdatePartitionedTopicResponse parses an HTTP response from a NonPersistentTopicsUpdatePartitionedTopicWithResponse call
func ParseNonPersistentTopicsUpdatePartitionedTopicResponse(rsp *http.Response) (*NonPersistentTopicsUpdatePartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsUpdatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsCreatePartitionedTopicResponse parses an HTTP response from a NonPersistentTopicsCreatePartitionedTopicWithResponse call
func ParseNonPersistentTopicsCreatePartitionedTopicResponse(rsp *http.Response) (*NonPersistentTopicsCreatePartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsCreatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetPermissionsOnTopicResponse parses an HTTP response from a NonPersistentTopicsGetPermissionsOnTopicWithResponse call
func ParseNonPersistentTopicsGetPermissionsOnTopicResponse(rsp *http.Response) (*NonPersistentTopicsGetPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRevokePermissionsOnTopicResponse parses an HTTP response from a NonPersistentTopicsRevokePermissionsOnTopicWithResponse call
func ParseNonPersistentTopicsRevokePermissionsOnTopicResponse(rsp *http.Response) (*NonPersistentTopicsRevokePermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRevokePermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGrantPermissionsOnTopicResponse parses an HTTP response from a NonPersistentTopicsGrantPermissionsOnTopicWithResponse call
func ParseNonPersistentTopicsGrantPermissionsOnTopicResponse(rsp *http.Response) (*NonPersistentTopicsGrantPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGrantPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemovePersistenceResponse parses an HTTP response from a NonPersistentTopicsRemovePersistenceWithResponse call
func ParseNonPersistentTopicsRemovePersistenceResponse(rsp *http.Response) (*NonPersistentTopicsRemovePersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemovePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetPersistenceResponse parses an HTTP response from a NonPersistentTopicsGetPersistenceWithResponse call
func ParseNonPersistentTopicsGetPersistenceResponse(rsp *http.Response) (*NonPersistentTopicsGetPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistencePolicies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetPersistenceResponse parses an HTTP response from a NonPersistentTopicsSetPersistenceWithResponse call
func ParseNonPersistentTopicsSetPersistenceResponse(rsp *http.Response) (*NonPersistentTopicsSetPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemovePropertiesResponse parses an HTTP response from a NonPersistentTopicsRemovePropertiesWithResponse call
func ParseNonPersistentTopicsRemovePropertiesResponse(rsp *http.Response) (*NonPersistentTopicsRemovePropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemovePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetPropertiesResponse parses an HTTP response from a NonPersistentTopicsGetPropertiesWithResponse call
func ParseNonPersistentTopicsGetPropertiesResponse(rsp *http.Response) (*NonPersistentTopicsGetPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsUpdatePropertiesResponse parses an HTTP response from a NonPersistentTopicsUpdatePropertiesWithResponse call
func ParseNonPersistentTopicsUpdatePropertiesResponse(rsp *http.Response) (*NonPersistentTopicsUpdatePropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsUpdatePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemovePublishRateResponse parses an HTTP response from a NonPersistentTopicsRemovePublishRateWithResponse call
func ParseNonPersistentTopicsRemovePublishRateResponse(rsp *http.Response) (*NonPersistentTopicsRemovePublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemovePublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetPublishRateResponse parses an HTTP response from a NonPersistentTopicsGetPublishRateWithResponse call
func ParseNonPersistentTopicsGetPublishRateResponse(rsp *http.Response) (*NonPersistentTopicsGetPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublishRate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetPublishRateResponse parses an HTTP response from a NonPersistentTopicsSetPublishRateWithResponse call
func ParseNonPersistentTopicsSetPublishRateResponse(rsp *http.Response) (*NonPersistentTopicsSetPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveReplicationClustersResponse parses an HTTP response from a NonPersistentTopicsRemoveReplicationClustersWithResponse call
func ParseNonPersistentTopicsRemoveReplicationClustersResponse(rsp *http.Response) (*NonPersistentTopicsRemoveReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetReplicationClustersResponse parses an HTTP response from a NonPersistentTopicsGetReplicationClustersWithResponse call
func ParseNonPersistentTopicsGetReplicationClustersResponse(rsp *http.Response) (*NonPersistentTopicsGetReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetReplicationClustersResponse parses an HTTP response from a NonPersistentTopicsSetReplicationClustersWithResponse call
func ParseNonPersistentTopicsSetReplicationClustersResponse(rsp *http.Response) (*NonPersistentTopicsSetReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveReplicatorDispatchRateResponse parses an HTTP response from a NonPersistentTopicsRemoveReplicatorDispatchRateWithResponse call
func ParseNonPersistentTopicsRemoveReplicatorDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsRemoveReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetReplicatorDispatchRateResponse parses an HTTP response from a NonPersistentTopicsGetReplicatorDispatchRateWithResponse call
func ParseNonPersistentTopicsGetReplicatorDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsGetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DispatchRate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetReplicatorDispatchRateResponse parses an HTTP response from a NonPersistentTopicsSetReplicatorDispatchRateWithResponse call
func ParseNonPersistentTopicsSetReplicatorDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsSetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveRetentionResponse parses an HTTP response from a NonPersistentTopicsRemoveRetentionWithResponse call
func ParseNonPersistentTopicsRemoveRetentionResponse(rsp *http.Response) (*NonPersistentTopicsRemoveRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetRetentionResponse parses an HTTP response from a NonPersistentTopicsGetRetentionWithResponse call
func ParseNonPersistentTopicsGetRetentionResponse(rsp *http.Response) (*NonPersistentTopicsGetRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RetentionPolicies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetRetentionResponse parses an HTTP response from a NonPersistentTopicsSetRetentionWithResponse call
func ParseNonPersistentTopicsSetRetentionResponse(rsp *http.Response) (*NonPersistentTopicsSetRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse parses an HTTP response from a NonPersistentTopicsRemoveSchemaCompatibilityStrategyWithResponse call
func ParseNonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse(rsp *http.Response) (*NonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetSchemaCompatibilityStrategyResponse parses an HTTP response from a NonPersistentTopicsGetSchemaCompatibilityStrategyWithResponse call
func ParseNonPersistentTopicsGetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*NonPersistentTopicsGetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetSchemaCompatibilityStrategyResponse parses an HTTP response from a NonPersistentTopicsSetSchemaCompatibilityStrategyWithResponse call
func ParseNonPersistentTopicsSetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*NonPersistentTopicsSetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetSchemaValidationEnforcedResponse parses an HTTP response from a NonPersistentTopicsGetSchemaValidationEnforcedWithResponse call
func ParseNonPersistentTopicsGetSchemaValidationEnforcedResponse(rsp *http.Response) (*NonPersistentTopicsGetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSetSchemaValidationEnforcedResponse parses an HTTP response from a NonPersistentTopicsSetSchemaValidationEnforcedWithResponse call
func ParseNonPersistentTopicsSetSchemaValidationEnforcedResponse(rsp *http.Response) (*NonPersistentTopicsSetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsDeleteShadowTopicsResponse parses an HTTP response from a NonPersistentTopicsDeleteShadowTopicsWithResponse call
func ParseNonPersistentTopicsDeleteShadowTopicsResponse(rsp *http.Response) (*NonPersistentTopicsDeleteShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeleteShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetShadowTopicsResponse parses an HTTP response from a NonPersistentTopicsGetShadowTopicsWithResponse call
func ParseNonPersistentTopicsGetShadowTopicsResponse(rsp *http.Response) (*NonPersistentTopicsGetShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSetShadowTopicsResponse parses an HTTP response from a NonPersistentTopicsSetShadowTopicsWithResponse call
func ParseNonPersistentTopicsSetShadowTopicsResponse(rsp *http.Response) (*NonPersistentTopicsSetShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetStatsResponse parses an HTTP response from a NonPersistentTopicsGetStatsWithResponse call
func ParseNonPersistentTopicsGetStatsResponse(rsp *http.Response) (*NonPersistentTopicsGetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistentTopicStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveSubscribeRateResponse parses an HTTP response from a NonPersistentTopicsRemoveSubscribeRateWithResponse call
func ParseNonPersistentTopicsRemoveSubscribeRateResponse(rsp *http.Response) (*NonPersistentTopicsRemoveSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetSubscribeRateResponse parses an HTTP response from a NonPersistentTopicsGetSubscribeRateWithResponse call
func ParseNonPersistentTopicsGetSubscribeRateResponse(rsp *http.Response) (*NonPersistentTopicsGetSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscribeRate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetSubscribeRateResponse parses an HTTP response from a NonPersistentTopicsSetSubscribeRateWithResponse call
func ParseNonPersistentTopicsSetSubscribeRateResponse(rsp *http.Response) (*NonPersistentTopicsSetSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsDeleteSubscriptionResponse parses an HTTP response from a NonPersistentTopicsDeleteSubscriptionWithResponse call
func ParseNonPersistentTopicsDeleteSubscriptionResponse(rsp *http.Response) (*NonPersistentTopicsDeleteSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsDeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsAnalyzeSubscriptionBacklogResponse parses an HTTP response from a NonPersistentTopicsAnalyzeSubscriptionBacklogWithResponse call
func ParseNonPersistentTopicsAnalyzeSubscriptionBacklogResponse(rsp *http.Response) (*NonPersistentTopicsAnalyzeSubscriptionBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsAnalyzeSubscriptionBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsExpireTopicMessagesResponse parses an HTTP response from a NonPersistentTopicsExpireTopicMessagesWithResponse call
func ParseNonPersistentTopicsExpireTopicMessagesResponse(rsp *http.Response) (*NonPersistentTopicsExpireTopicMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsExpireTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsExpireTopicMessagesExpireTimeResponse parses an HTTP response from a NonPersistentTopicsExpireTopicMessagesExpireTimeWithResponse call
func ParseNonPersistentTopicsExpireTopicMessagesExpireTimeResponse(rsp *http.Response) (*NonPersistentTopicsExpireTopicMessagesExpireTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsExpireTopicMessagesExpireTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsPeekNthMessageResponse parses an HTTP response from a NonPersistentTopicsPeekNthMessageWithResponse call
func ParseNonPersistentTopicsPeekNthMessageResponse(rsp *http.Response) (*NonPersistentTopicsPeekNthMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsPeekNthMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetSubscriptionPropertiesResponse parses an HTTP response from a NonPersistentTopicsGetSubscriptionPropertiesWithResponse call
func ParseNonPersistentTopicsGetSubscriptionPropertiesResponse(rsp *http.Response) (*NonPersistentTopicsGetSubscriptionPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsUpdateSubscriptionPropertiesResponse parses an HTTP response from a NonPersistentTopicsUpdateSubscriptionPropertiesWithResponse call
func ParseNonPersistentTopicsUpdateSubscriptionPropertiesResponse(rsp *http.Response) (*NonPersistentTopicsUpdateSubscriptionPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsUpdateSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetReplicatedSubscriptionStatusResponse parses an HTTP response from a NonPersistentTopicsGetReplicatedSubscriptionStatusWithResponse call
func ParseNonPersistentTopicsGetReplicatedSubscriptionStatusResponse(rsp *http.Response) (*NonPersistentTopicsGetReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetReplicatedSubscriptionStatusResponse parses an HTTP response from a NonPersistentTopicsSetReplicatedSubscriptionStatusWithResponse call
func ParseNonPersistentTopicsSetReplicatedSubscriptionStatusResponse(rsp *http.Response) (*NonPersistentTopicsSetReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsResetCursorOnPositionResponse parses an HTTP response from a NonPersistentTopicsResetCursorOnPositionWithResponse call
func ParseNonPersistentTopicsResetCursorOnPositionResponse(rsp *http.Response) (*NonPersistentTopicsResetCursorOnPositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsResetCursorOnPositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsResetCursorResponse parses an HTTP response from a NonPersistentTopicsResetCursorWithResponse call
func ParseNonPersistentTopicsResetCursorResponse(rsp *http.Response) (*NonPersistentTopicsResetCursorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsResetCursorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSkipMessagesResponse parses an HTTP response from a NonPersistentTopicsSkipMessagesWithResponse call
func ParseNonPersistentTopicsSkipMessagesResponse(rsp *http.Response) (*NonPersistentTopicsSkipMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSkipMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSkipAllMessagesResponse parses an HTTP response from a NonPersistentTopicsSkipAllMessagesWithResponse call
func ParseNonPersistentTopicsSkipAllMessagesResponse(rsp *http.Response) (*NonPersistentTopicsSkipAllMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSkipAllMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsCreateSubscriptionResponse parses an HTTP response from a NonPersistentTopicsCreateSubscriptionWithResponse call
func ParseNonPersistentTopicsCreateSubscriptionResponse(rsp *http.Response) (*NonPersistentTopicsCreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsCreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveSubscriptionDispatchRateResponse parses an HTTP response from a NonPersistentTopicsRemoveSubscriptionDispatchRateWithResponse call
func ParseNonPersistentTopicsRemoveSubscriptionDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsRemoveSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetSubscriptionDispatchRateResponse parses an HTTP response from a NonPersistentTopicsGetSubscriptionDispatchRateWithResponse call
func ParseNonPersistentTopicsGetSubscriptionDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsGetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DispatchRate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetSubscriptionDispatchRateResponse parses an HTTP response from a NonPersistentTopicsSetSubscriptionDispatchRateWithResponse call
func ParseNonPersistentTopicsSetSubscriptionDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsSetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveSubscriptionTypesEnabledResponse parses an HTTP response from a NonPersistentTopicsRemoveSubscriptionTypesEnabledWithResponse call
func ParseNonPersistentTopicsRemoveSubscriptionTypesEnabledResponse(rsp *http.Response) (*NonPersistentTopicsRemoveSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetSubscriptionTypesEnabledResponse parses an HTTP response from a NonPersistentTopicsGetSubscriptionTypesEnabledWithResponse call
func ParseNonPersistentTopicsGetSubscriptionTypesEnabledResponse(rsp *http.Response) (*NonPersistentTopicsGetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsSetSubscriptionTypesEnabledResponse parses an HTTP response from a NonPersistentTopicsSetSubscriptionTypesEnabledWithResponse call
func ParseNonPersistentTopicsSetSubscriptionTypesEnabledResponse(rsp *http.Response) (*NonPersistentTopicsSetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetSubscriptionsResponse parses an HTTP response from a NonPersistentTopicsGetSubscriptionsWithResponse call
func ParseNonPersistentTopicsGetSubscriptionsResponse(rsp *http.Response) (*NonPersistentTopicsGetSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseNonPersistentTopicsTerminateResponse parses an HTTP response from a NonPersistentTopicsTerminateWithResponse call
func ParseNonPersistentTopicsTerminateResponse(rsp *http.Response) (*NonPersistentTopicsTerminateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsTerminateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsTerminatePartitionedTopicResponse parses an HTTP response from a NonPersistentTopicsTerminatePartitionedTopicWithResponse call
func ParseNonPersistentTopicsTerminatePartitionedTopicResponse(rsp *http.Response) (*NonPersistentTopicsTerminatePartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsTerminatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsTrimTopicResponse parses an HTTP response from a NonPersistentTopicsTrimTopicWithResponse call
func ParseNonPersistentTopicsTrimTopicResponse(rsp *http.Response) (*NonPersistentTopicsTrimTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsTrimTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsTruncateTopicResponse parses an HTTP response from a NonPersistentTopicsTruncateTopicWithResponse call
func ParseNonPersistentTopicsTruncateTopicResponse(rsp *http.Response) (*NonPersistentTopicsTruncateTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsTruncateTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsUnloadTopicResponse parses an HTTP response from a NonPersistentTopicsUnloadTopicWithResponse call
func ParseNonPersistentTopicsUnloadTopicResponse(rsp *http.Response) (*NonPersistentTopicsUnloadTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsUnloadTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse parses an HTTP response from a NonPersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse call
func ParseNonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsRemoveSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsGetSubscriptionLevelDispatchRateResponse parses an HTTP response from a NonPersistentTopicsGetSubscriptionLevelDispatchRateWithResponse call
func ParseNonPersistentTopicsGetSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsGetSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsGetSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseNonPersistentTopicsSetSubscriptionLevelDispatchRateResponse parses an HTTP response from a NonPersistentTopicsSetSubscriptionLevelDispatchRateWithResponse call
func ParseNonPersistentTopicsSetSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*NonPersistentTopicsSetSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &NonPersistentTopicsSetSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetListResponse parses an HTTP response from a PersistentTopicsGetListWithResponse call
func ParsePersistentTopicsGetListResponse(rsp *http.Response) (*PersistentTopicsGetListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsGetPartitionedTopicListResponse parses an HTTP response from a PersistentTopicsGetPartitionedTopicListWithResponse call
func ParsePersistentTopicsGetPartitionedTopicListResponse(rsp *http.Response) (*PersistentTopicsGetPartitionedTopicListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetPartitionedTopicListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsDeleteTopicResponse parses an HTTP response from a PersistentTopicsDeleteTopicWithResponse call
func ParsePersistentTopicsDeleteTopicResponse(rsp *http.Response) (*PersistentTopicsDeleteTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeleteTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsCreateNonPartitionedTopicResponse parses an HTTP response from a PersistentTopicsCreateNonPartitionedTopicWithResponse call
func ParsePersistentTopicsCreateNonPartitionedTopicResponse(rsp *http.Response) (*PersistentTopicsCreateNonPartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsCreateNonPartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsExpireMessagesForAllSubscriptionsResponse parses an HTTP response from a PersistentTopicsExpireMessagesForAllSubscriptionsWithResponse call
func ParsePersistentTopicsExpireMessagesForAllSubscriptionsResponse(rsp *http.Response) (*PersistentTopicsExpireMessagesForAllSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsExpireMessagesForAllSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveAutoSubscriptionCreationResponse parses an HTTP response from a PersistentTopicsRemoveAutoSubscriptionCreationWithResponse call
func ParsePersistentTopicsRemoveAutoSubscriptionCreationResponse(rsp *http.Response) (*PersistentTopicsRemoveAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetAutoSubscriptionCreationResponse parses an HTTP response from a PersistentTopicsGetAutoSubscriptionCreationWithResponse call
func ParsePersistentTopicsGetAutoSubscriptionCreationResponse(rsp *http.Response) (*PersistentTopicsGetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSetAutoSubscriptionCreationResponse parses an HTTP response from a PersistentTopicsSetAutoSubscriptionCreationWithResponse call
func ParsePersistentTopicsSetAutoSubscriptionCreationResponse(rsp *http.Response) (*PersistentTopicsSetAutoSubscriptionCreationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetAutoSubscriptionCreationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetBacklogResponse parses an HTTP response from a PersistentTopicsGetBacklogWithResponse call
func ParsePersistentTopicsGetBacklogResponse(rsp *http.Response) (*PersistentTopicsGetBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistentOfflineTopicStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsRemoveBacklogQuotaResponse parses an HTTP response from a PersistentTopicsRemoveBacklogQuotaWithResponse call
func ParsePersistentTopicsRemoveBacklogQuotaResponse(rsp *http.Response) (*PersistentTopicsRemoveBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSetBacklogQuotaResponse parses an HTTP response from a PersistentTopicsSetBacklogQuotaWithResponse call
func ParsePersistentTopicsSetBacklogQuotaResponse(rsp *http.Response) (*PersistentTopicsSetBacklogQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetBacklogQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetBacklogQuotaMapResponse parses an HTTP response from a PersistentTopicsGetBacklogQuotaMapWithResponse call
func ParsePersistentTopicsGetBacklogQuotaMapResponse(rsp *http.Response) (*PersistentTopicsGetBacklogQuotaMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetBacklogQuotaMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]BacklogQuota
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsGetBacklogSizeByMessageIdResponse parses an HTTP response from a PersistentTopicsGetBacklogSizeByMessageIdWithResponse call
func ParsePersistentTopicsGetBacklogSizeByMessageIdResponse(rsp *http.Response) (*PersistentTopicsGetBacklogSizeByMessageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetBacklogSizeByMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsCompactionStatusResponse parses an HTTP response from a PersistentTopicsCompactionStatusWithResponse call
func ParsePersistentTopicsCompactionStatusResponse(rsp *http.Response) (*PersistentTopicsCompactionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsCompactionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsCompactResponse parses an HTTP response from a PersistentTopicsCompactWithResponse call
func ParsePersistentTopicsCompactResponse(rsp *http.Response) (*PersistentTopicsCompactResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsCompactResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveCompactionThresholdResponse parses an HTTP response from a PersistentTopicsRemoveCompactionThresholdWithResponse call
func ParsePersistentTopicsRemoveCompactionThresholdResponse(rsp *http.Response) (*PersistentTopicsRemoveCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetCompactionThresholdResponse parses an HTTP response from a PersistentTopicsGetCompactionThresholdWithResponse call
func ParsePersistentTopicsGetCompactionThresholdResponse(rsp *http.Response) (*PersistentTopicsGetCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int64
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetCompactionThresholdResponse parses an HTTP response from a PersistentTopicsSetCompactionThresholdWithResponse call
func ParsePersistentTopicsSetCompactionThresholdResponse(rsp *http.Response) (*PersistentTopicsSetCompactionThresholdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetCompactionThresholdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsCreateMissedPartitionsResponse parses an HTTP response from a PersistentTopicsCreateMissedPartitionsWithResponse call
func ParsePersistentTopicsCreateMissedPartitionsResponse(rsp *http.Response) (*PersistentTopicsCreateMissedPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsCreateMissedPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveDeduplicationResponse parses an HTTP response from a PersistentTopicsRemoveDeduplicationWithResponse call
func ParsePersistentTopicsRemoveDeduplicationResponse(rsp *http.Response) (*PersistentTopicsRemoveDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetDeduplicationResponse parses an HTTP response from a PersistentTopicsGetDeduplicationWithResponse call
func ParsePersistentTopicsGetDeduplicationResponse(rsp *http.Response) (*PersistentTopicsGetDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetDeduplicationResponse parses an HTTP response from a PersistentTopicsSetDeduplicationWithResponse call
func ParsePersistentTopicsSetDeduplicationResponse(rsp *http.Response) (*PersistentTopicsSetDeduplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetDeduplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsDeleteDeduplicationSnapshotIntervalResponse parses an HTTP response from a PersistentTopicsDeleteDeduplicationSnapshotIntervalWithResponse call
func ParsePersistentTopicsDeleteDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*PersistentTopicsDeleteDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeleteDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetDeduplicationSnapshotIntervalResponse parses an HTTP response from a PersistentTopicsGetDeduplicationSnapshotIntervalWithResponse call
func ParsePersistentTopicsGetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*PersistentTopicsGetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetDeduplicationSnapshotIntervalResponse parses an HTTP response from a PersistentTopicsSetDeduplicationSnapshotIntervalWithResponse call
func ParsePersistentTopicsSetDeduplicationSnapshotIntervalResponse(rsp *http.Response) (*PersistentTopicsSetDeduplicationSnapshotIntervalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetDeduplicationSnapshotIntervalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsDeleteDelayedDeliveryPoliciesResponse parses an HTTP response from a PersistentTopicsDeleteDelayedDeliveryPoliciesWithResponse call
func ParsePersistentTopicsDeleteDelayedDeliveryPoliciesResponse(rsp *http.Response) (*PersistentTopicsDeleteDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeleteDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetDelayedDeliveryPoliciesResponse parses an HTTP response from a PersistentTopicsGetDelayedDeliveryPoliciesWithResponse call
func ParsePersistentTopicsGetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*PersistentTopicsGetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DelayedDeliveryPolicies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetDelayedDeliveryPoliciesResponse parses an HTTP response from a PersistentTopicsSetDelayedDeliveryPoliciesWithResponse call
func ParsePersistentTopicsSetDelayedDeliveryPoliciesResponse(rsp *http.Response) (*PersistentTopicsSetDelayedDeliveryPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetDelayedDeliveryPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveDispatchRateResponse parses an HTTP response from a PersistentTopicsRemoveDispatchRateWithResponse call
func ParsePersistentTopicsRemoveDispatchRateResponse(rsp *http.Response) (*PersistentTopicsRemoveDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetDispatchRateResponse parses an HTTP response from a PersistentTopicsGetDispatchRateWithResponse call
func ParsePersistentTopicsGetDispatchRateResponse(rsp *http.Response) (*PersistentTopicsGetDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSetDispatchRateResponse parses an HTTP response from a PersistentTopicsSetDispatchRateWithResponse call
func ParsePersistentTopicsSetDispatchRateResponse(rsp *http.Response) (*PersistentTopicsSetDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveEntryFiltersResponse parses an HTTP response from a PersistentTopicsRemoveEntryFiltersWithResponse call
func ParsePersistentTopicsRemoveEntryFiltersResponse(rsp *http.Response) (*PersistentTopicsRemoveEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetEntryFiltersResponse parses an HTTP response from a PersistentTopicsGetEntryFiltersWithResponse call
func ParsePersistentTopicsGetEntryFiltersResponse(rsp *http.Response) (*PersistentTopicsGetEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSetEntryFiltersResponse parses an HTTP response from a PersistentTopicsSetEntryFiltersWithResponse call
func ParsePersistentTopicsSetEntryFiltersResponse(rsp *http.Response) (*PersistentTopicsSetEntryFiltersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetEntryFiltersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsExamineMessageResponse parses an HTTP response from a PersistentTopicsExamineMessageWithResponse call
func ParsePersistentTopicsExamineMessageResponse(rsp *http.Response) (*PersistentTopicsExamineMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsExamineMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsDeleteInactiveTopicPoliciesResponse parses an HTTP response from a PersistentTopicsDeleteInactiveTopicPoliciesWithResponse call
func ParsePersistentTopicsDeleteInactiveTopicPoliciesResponse(rsp *http.Response) (*PersistentTopicsDeleteInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeleteInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetInactiveTopicPoliciesResponse parses an HTTP response from a PersistentTopicsGetInactiveTopicPoliciesWithResponse call
func ParsePersistentTopicsGetInactiveTopicPoliciesResponse(rsp *http.Response) (*PersistentTopicsGetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InactiveTopicPolicies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetInactiveTopicPoliciesResponse parses an HTTP response from a PersistentTopicsSetInactiveTopicPoliciesWithResponse call
func ParsePersistentTopicsSetInactiveTopicPoliciesResponse(rsp *http.Response) (*PersistentTopicsSetInactiveTopicPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetInactiveTopicPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetManagedLedgerInfoResponse parses an HTTP response from a PersistentTopicsGetManagedLedgerInfoWithResponse call
func ParsePersistentTopicsGetManagedLedgerInfoResponse(rsp *http.Response) (*PersistentTopicsGetManagedLedgerInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetManagedLedgerInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartitionedManagedLedgerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsGetInternalStatsResponse parses an HTTP response from a PersistentTopicsGetInternalStatsWithResponse call
func ParsePersistentTopicsGetInternalStatsResponse(rsp *http.Response) (*PersistentTopicsGetInternalStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetInternalStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistentTopicInternalStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsGetLastMessageIdResponse parses an HTTP response from a PersistentTopicsGetLastMessageIdWithResponse call
func ParsePersistentTopicsGetLastMessageIdResponse(rsp *http.Response) (*PersistentTopicsGetLastMessageIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetLastMessageIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMessageByIdResponse parses an HTTP response from a PersistentTopicsGetMessageByIdWithResponse call
func ParsePersistentTopicsGetMessageByIdResponse(rsp *http.Response) (*PersistentTopicsGetMessageByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMessageByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveMaxConsumersResponse parses an HTTP response from a PersistentTopicsRemoveMaxConsumersWithResponse call
func ParsePersistentTopicsRemoveMaxConsumersResponse(rsp *http.Response) (*PersistentTopicsRemoveMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMaxConsumersResponse parses an HTTP response from a PersistentTopicsGetMaxConsumersWithResponse call
func ParsePersistentTopicsGetMaxConsumersResponse(rsp *http.Response) (*PersistentTopicsGetMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetMaxConsumersResponse parses an HTTP response from a PersistentTopicsSetMaxConsumersWithResponse call
func ParsePersistentTopicsSetMaxConsumersResponse(rsp *http.Response) (*PersistentTopicsSetMaxConsumersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetMaxConsumersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveMaxConsumersPerSubscriptionResponse parses an HTTP response from a PersistentTopicsRemoveMaxConsumersPerSubscriptionWithResponse call
func ParsePersistentTopicsRemoveMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*PersistentTopicsRemoveMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMaxConsumersPerSubscriptionResponse parses an HTTP response from a PersistentTopicsGetMaxConsumersPerSubscriptionWithResponse call
func ParsePersistentTopicsGetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*PersistentTopicsGetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetMaxConsumersPerSubscriptionResponse parses an HTTP response from a PersistentTopicsSetMaxConsumersPerSubscriptionWithResponse call
func ParsePersistentTopicsSetMaxConsumersPerSubscriptionResponse(rsp *http.Response) (*PersistentTopicsSetMaxConsumersPerSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetMaxConsumersPerSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveMaxMessageSizeResponse parses an HTTP response from a PersistentTopicsRemoveMaxMessageSizeWithResponse call
func ParsePersistentTopicsRemoveMaxMessageSizeResponse(rsp *http.Response) (*PersistentTopicsRemoveMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMaxMessageSizeResponse parses an HTTP response from a PersistentTopicsGetMaxMessageSizeWithResponse call
func ParsePersistentTopicsGetMaxMessageSizeResponse(rsp *http.Response) (*PersistentTopicsGetMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetMaxMessageSizeResponse parses an HTTP response from a PersistentTopicsSetMaxMessageSizeWithResponse call
func ParsePersistentTopicsSetMaxMessageSizeResponse(rsp *http.Response) (*PersistentTopicsSetMaxMessageSizeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetMaxMessageSizeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveMaxProducersResponse parses an HTTP response from a PersistentTopicsRemoveMaxProducersWithResponse call
func ParsePersistentTopicsRemoveMaxProducersResponse(rsp *http.Response) (*PersistentTopicsRemoveMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMaxProducersResponse parses an HTTP response from a PersistentTopicsGetMaxProducersWithResponse call
func ParsePersistentTopicsGetMaxProducersResponse(rsp *http.Response) (*PersistentTopicsGetMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetMaxProducersResponse parses an HTTP response from a PersistentTopicsSetMaxProducersWithResponse call
func ParsePersistentTopicsSetMaxProducersResponse(rsp *http.Response) (*PersistentTopicsSetMaxProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetMaxProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveMaxSubscriptionsPerTopicResponse parses an HTTP response from a PersistentTopicsRemoveMaxSubscriptionsPerTopicWithResponse call
func ParsePersistentTopicsRemoveMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*PersistentTopicsRemoveMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMaxSubscriptionsPerTopicResponse parses an HTTP response from a PersistentTopicsGetMaxSubscriptionsPerTopicWithResponse call
func ParsePersistentTopicsGetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*PersistentTopicsGetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetMaxSubscriptionsPerTopicResponse parses an HTTP response from a PersistentTopicsSetMaxSubscriptionsPerTopicWithResponse call
func ParsePersistentTopicsSetMaxSubscriptionsPerTopicResponse(rsp *http.Response) (*PersistentTopicsSetMaxSubscriptionsPerTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetMaxSubscriptionsPerTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a PersistentTopicsDeleteMaxUnackedMessagesOnConsumerWithResponse call
func ParsePersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*PersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeleteMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a PersistentTopicsGetMaxUnackedMessagesOnConsumerWithResponse call
func ParsePersistentTopicsGetMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*PersistentTopicsGetMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetMaxUnackedMessagesOnConsumerResponse parses an HTTP response from a PersistentTopicsSetMaxUnackedMessagesOnConsumerWithResponse call
func ParsePersistentTopicsSetMaxUnackedMessagesOnConsumerResponse(rsp *http.Response) (*PersistentTopicsSetMaxUnackedMessagesOnConsumerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetMaxUnackedMessagesOnConsumerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionWithResponse call
func ParsePersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeleteMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a PersistentTopicsGetMaxUnackedMessagesOnSubscriptionWithResponse call
func ParsePersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*PersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse parses an HTTP response from a PersistentTopicsSetMaxUnackedMessagesOnSubscriptionWithResponse call
func ParsePersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse(rsp *http.Response) (*PersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetMaxUnackedMessagesOnSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveMessageTTLResponse parses an HTTP response from a PersistentTopicsRemoveMessageTTLWithResponse call
func ParsePersistentTopicsRemoveMessageTTLResponse(rsp *http.Response) (*PersistentTopicsRemoveMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMessageTTLResponse parses an HTTP response from a PersistentTopicsGetMessageTTLWithResponse call
func ParsePersistentTopicsGetMessageTTLResponse(rsp *http.Response) (*PersistentTopicsGetMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int32
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetMessageTTLResponse parses an HTTP response from a PersistentTopicsSetMessageTTLWithResponse call
func ParsePersistentTopicsSetMessageTTLResponse(rsp *http.Response) (*PersistentTopicsSetMessageTTLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetMessageTTLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetMessageIdByTimestampResponse parses an HTTP response from a PersistentTopicsGetMessageIdByTimestampWithResponse call
func ParsePersistentTopicsGetMessageIdByTimestampResponse(rsp *http.Response) (*PersistentTopicsGetMessageIdByTimestampResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetMessageIdByTimestampResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsOffloadStatusResponse parses an HTTP response from a PersistentTopicsOffloadStatusWithResponse call
func ParsePersistentTopicsOffloadStatusResponse(rsp *http.Response) (*PersistentTopicsOffloadStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsOffloadStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsTriggerOffloadResponse parses an HTTP response from a PersistentTopicsTriggerOffloadWithResponse call
func ParsePersistentTopicsTriggerOffloadResponse(rsp *http.Response) (*PersistentTopicsTriggerOffloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsTriggerOffloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveOffloadPoliciesResponse parses an HTTP response from a PersistentTopicsRemoveOffloadPoliciesWithResponse call
func ParsePersistentTopicsRemoveOffloadPoliciesResponse(rsp *http.Response) (*PersistentTopicsRemoveOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetOffloadPoliciesResponse parses an HTTP response from a PersistentTopicsGetOffloadPoliciesWithResponse call
func ParsePersistentTopicsGetOffloadPoliciesResponse(rsp *http.Response) (*PersistentTopicsGetOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSetOffloadPoliciesResponse parses an HTTP response from a PersistentTopicsSetOffloadPoliciesWithResponse call
func ParsePersistentTopicsSetOffloadPoliciesResponse(rsp *http.Response) (*PersistentTopicsSetOffloadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetOffloadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetPartitionedStatsInternalResponse parses an HTTP response from a PersistentTopicsGetPartitionedStatsInternalWithResponse call
func ParsePersistentTopicsGetPartitionedStatsInternalResponse(rsp *http.Response) (*PersistentTopicsGetPartitionedStatsInternalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetPartitionedStatsInternalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartitionedTopicInternalStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsGetPartitionedStatsResponse parses an HTTP response from a PersistentTopicsGetPartitionedStatsWithResponse call
func ParsePersistentTopicsGetPartitionedStatsResponse(rsp *http.Response) (*PersistentTopicsGetPartitionedStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetPartitionedStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartitionedTopicStatsImpl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsDeletePartitionedTopicResponse parses an HTTP response from a PersistentTopicsDeletePartitionedTopicWithResponse call
func ParsePersistentTopicsDeletePartitionedTopicResponse(rsp *http.Response) (*PersistentTopicsDeletePartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeletePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetPartitionedMetadataResponse parses an HTTP response from a PersistentTopicsGetPartitionedMetadataWithResponse call
func ParsePersistentTopicsGetPartitionedMetadataResponse(rsp *http.Response) (*PersistentTopicsGetPartitionedMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetPartitionedMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PartitionedTopicMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsUpdatePartitionedTopicResponse parses an HTTP response from a PersistentTopicsUpdatePartitionedTopicWithResponse call
func ParsePersistentTopicsUpdatePartitionedTopicResponse(rsp *http.Response) (*PersistentTopicsUpdatePartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsUpdatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsCreatePartitionedTopicResponse parses an HTTP response from a PersistentTopicsCreatePartitionedTopicWithResponse call
func ParsePersistentTopicsCreatePartitionedTopicResponse(rsp *http.Response) (*PersistentTopicsCreatePartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsCreatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetPermissionsOnTopicResponse parses an HTTP response from a PersistentTopicsGetPermissionsOnTopicWithResponse call
func ParsePersistentTopicsGetPermissionsOnTopicResponse(rsp *http.Response) (*PersistentTopicsGetPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRevokePermissionsOnTopicResponse parses an HTTP response from a PersistentTopicsRevokePermissionsOnTopicWithResponse call
func ParsePersistentTopicsRevokePermissionsOnTopicResponse(rsp *http.Response) (*PersistentTopicsRevokePermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRevokePermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGrantPermissionsOnTopicResponse parses an HTTP response from a PersistentTopicsGrantPermissionsOnTopicWithResponse call
func ParsePersistentTopicsGrantPermissionsOnTopicResponse(rsp *http.Response) (*PersistentTopicsGrantPermissionsOnTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGrantPermissionsOnTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemovePersistenceResponse parses an HTTP response from a PersistentTopicsRemovePersistenceWithResponse call
func ParsePersistentTopicsRemovePersistenceResponse(rsp *http.Response) (*PersistentTopicsRemovePersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemovePersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetPersistenceResponse parses an HTTP response from a PersistentTopicsGetPersistenceWithResponse call
func ParsePersistentTopicsGetPersistenceResponse(rsp *http.Response) (*PersistentTopicsGetPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistencePolicies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetPersistenceResponse parses an HTTP response from a PersistentTopicsSetPersistenceWithResponse call
func ParsePersistentTopicsSetPersistenceResponse(rsp *http.Response) (*PersistentTopicsSetPersistenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetPersistenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemovePropertiesResponse parses an HTTP response from a PersistentTopicsRemovePropertiesWithResponse call
func ParsePersistentTopicsRemovePropertiesResponse(rsp *http.Response) (*PersistentTopicsRemovePropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemovePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetPropertiesResponse parses an HTTP response from a PersistentTopicsGetPropertiesWithResponse call
func ParsePersistentTopicsGetPropertiesResponse(rsp *http.Response) (*PersistentTopicsGetPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsUpdatePropertiesResponse parses an HTTP response from a PersistentTopicsUpdatePropertiesWithResponse call
func ParsePersistentTopicsUpdatePropertiesResponse(rsp *http.Response) (*PersistentTopicsUpdatePropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsUpdatePropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemovePublishRateResponse parses an HTTP response from a PersistentTopicsRemovePublishRateWithResponse call
func ParsePersistentTopicsRemovePublishRateResponse(rsp *http.Response) (*PersistentTopicsRemovePublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemovePublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetPublishRateResponse parses an HTTP response from a PersistentTopicsGetPublishRateWithResponse call
func ParsePersistentTopicsGetPublishRateResponse(rsp *http.Response) (*PersistentTopicsGetPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PublishRate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetPublishRateResponse parses an HTTP response from a PersistentTopicsSetPublishRateWithResponse call
func ParsePersistentTopicsSetPublishRateResponse(rsp *http.Response) (*PersistentTopicsSetPublishRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetPublishRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveReplicationClustersResponse parses an HTTP response from a PersistentTopicsRemoveReplicationClustersWithResponse call
func ParsePersistentTopicsRemoveReplicationClustersResponse(rsp *http.Response) (*PersistentTopicsRemoveReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetReplicationClustersResponse parses an HTTP response from a PersistentTopicsGetReplicationClustersWithResponse call
func ParsePersistentTopicsGetReplicationClustersResponse(rsp *http.Response) (*PersistentTopicsGetReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetReplicationClustersResponse parses an HTTP response from a PersistentTopicsSetReplicationClustersWithResponse call
func ParsePersistentTopicsSetReplicationClustersResponse(rsp *http.Response) (*PersistentTopicsSetReplicationClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetReplicationClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveReplicatorDispatchRateResponse parses an HTTP response from a PersistentTopicsRemoveReplicatorDispatchRateWithResponse call
func ParsePersistentTopicsRemoveReplicatorDispatchRateResponse(rsp *http.Response) (*PersistentTopicsRemoveReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetReplicatorDispatchRateResponse parses an HTTP response from a PersistentTopicsGetReplicatorDispatchRateWithResponse call
func ParsePersistentTopicsGetReplicatorDispatchRateResponse(rsp *http.Response) (*PersistentTopicsGetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DispatchRate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetReplicatorDispatchRateResponse parses an HTTP response from a PersistentTopicsSetReplicatorDispatchRateWithResponse call
func ParsePersistentTopicsSetReplicatorDispatchRateResponse(rsp *http.Response) (*PersistentTopicsSetReplicatorDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetReplicatorDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveRetentionResponse parses an HTTP response from a PersistentTopicsRemoveRetentionWithResponse call
func ParsePersistentTopicsRemoveRetentionResponse(rsp *http.Response) (*PersistentTopicsRemoveRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetRetentionResponse parses an HTTP response from a PersistentTopicsGetRetentionWithResponse call
func ParsePersistentTopicsGetRetentionResponse(rsp *http.Response) (*PersistentTopicsGetRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RetentionPolicies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetRetentionResponse parses an HTTP response from a PersistentTopicsSetRetentionWithResponse call
func ParsePersistentTopicsSetRetentionResponse(rsp *http.Response) (*PersistentTopicsSetRetentionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetRetentionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveSchemaCompatibilityStrategyResponse parses an HTTP response from a PersistentTopicsRemoveSchemaCompatibilityStrategyWithResponse call
func ParsePersistentTopicsRemoveSchemaCompatibilityStrategyResponse(rsp *http.Response) (*PersistentTopicsRemoveSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetSchemaCompatibilityStrategyResponse parses an HTTP response from a PersistentTopicsGetSchemaCompatibilityStrategyWithResponse call
func ParsePersistentTopicsGetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*PersistentTopicsGetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetSchemaCompatibilityStrategyResponse parses an HTTP response from a PersistentTopicsSetSchemaCompatibilityStrategyWithResponse call
func ParsePersistentTopicsSetSchemaCompatibilityStrategyResponse(rsp *http.Response) (*PersistentTopicsSetSchemaCompatibilityStrategyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetSchemaCompatibilityStrategyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetSchemaValidationEnforcedResponse parses an HTTP response from a PersistentTopicsGetSchemaValidationEnforcedWithResponse call
func ParsePersistentTopicsGetSchemaValidationEnforcedResponse(rsp *http.Response) (*PersistentTopicsGetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSetSchemaValidationEnforcedResponse parses an HTTP response from a PersistentTopicsSetSchemaValidationEnforcedWithResponse call
func ParsePersistentTopicsSetSchemaValidationEnforcedResponse(rsp *http.Response) (*PersistentTopicsSetSchemaValidationEnforcedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetSchemaValidationEnforcedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsDeleteShadowTopicsResponse parses an HTTP response from a PersistentTopicsDeleteShadowTopicsWithResponse call
func ParsePersistentTopicsDeleteShadowTopicsResponse(rsp *http.Response) (*PersistentTopicsDeleteShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeleteShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetShadowTopicsResponse parses an HTTP response from a PersistentTopicsGetShadowTopicsWithResponse call
func ParsePersistentTopicsGetShadowTopicsResponse(rsp *http.Response) (*PersistentTopicsGetShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSetShadowTopicsResponse parses an HTTP response from a PersistentTopicsSetShadowTopicsWithResponse call
func ParsePersistentTopicsSetShadowTopicsResponse(rsp *http.Response) (*PersistentTopicsSetShadowTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetShadowTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetStatsResponse parses an HTTP response from a PersistentTopicsGetStatsWithResponse call
func ParsePersistentTopicsGetStatsResponse(rsp *http.Response) (*PersistentTopicsGetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersistentTopicStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsRemoveSubscribeRateResponse parses an HTTP response from a PersistentTopicsRemoveSubscribeRateWithResponse call
func ParsePersistentTopicsRemoveSubscribeRateResponse(rsp *http.Response) (*PersistentTopicsRemoveSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetSubscribeRateResponse parses an HTTP response from a PersistentTopicsGetSubscribeRateWithResponse call
func ParsePersistentTopicsGetSubscribeRateResponse(rsp *http.Response) (*PersistentTopicsGetSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SubscribeRate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetSubscribeRateResponse parses an HTTP response from a PersistentTopicsSetSubscribeRateWithResponse call
func ParsePersistentTopicsSetSubscribeRateResponse(rsp *http.Response) (*PersistentTopicsSetSubscribeRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetSubscribeRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsDeleteSubscriptionResponse parses an HTTP response from a PersistentTopicsDeleteSubscriptionWithResponse call
func ParsePersistentTopicsDeleteSubscriptionResponse(rsp *http.Response) (*PersistentTopicsDeleteSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsDeleteSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsAnalyzeSubscriptionBacklogResponse parses an HTTP response from a PersistentTopicsAnalyzeSubscriptionBacklogWithResponse call
func ParsePersistentTopicsAnalyzeSubscriptionBacklogResponse(rsp *http.Response) (*PersistentTopicsAnalyzeSubscriptionBacklogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsAnalyzeSubscriptionBacklogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsExpireTopicMessagesResponse parses an HTTP response from a PersistentTopicsExpireTopicMessagesWithResponse call
func ParsePersistentTopicsExpireTopicMessagesResponse(rsp *http.Response) (*PersistentTopicsExpireTopicMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsExpireTopicMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsExpireTopicMessagesExpireTimeResponse parses an HTTP response from a PersistentTopicsExpireTopicMessagesExpireTimeWithResponse call
func ParsePersistentTopicsExpireTopicMessagesExpireTimeResponse(rsp *http.Response) (*PersistentTopicsExpireTopicMessagesExpireTimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsExpireTopicMessagesExpireTimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsPeekNthMessageResponse parses an HTTP response from a PersistentTopicsPeekNthMessageWithResponse call
func ParsePersistentTopicsPeekNthMessageResponse(rsp *http.Response) (*PersistentTopicsPeekNthMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsPeekNthMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetSubscriptionPropertiesResponse parses an HTTP response from a PersistentTopicsGetSubscriptionPropertiesWithResponse call
func ParsePersistentTopicsGetSubscriptionPropertiesResponse(rsp *http.Response) (*PersistentTopicsGetSubscriptionPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsUpdateSubscriptionPropertiesResponse parses an HTTP response from a PersistentTopicsUpdateSubscriptionPropertiesWithResponse call
func ParsePersistentTopicsUpdateSubscriptionPropertiesResponse(rsp *http.Response) (*PersistentTopicsUpdateSubscriptionPropertiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsUpdateSubscriptionPropertiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetReplicatedSubscriptionStatusResponse parses an HTTP response from a PersistentTopicsGetReplicatedSubscriptionStatusWithResponse call
func ParsePersistentTopicsGetReplicatedSubscriptionStatusResponse(rsp *http.Response) (*PersistentTopicsGetReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]bool
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetReplicatedSubscriptionStatusResponse parses an HTTP response from a PersistentTopicsSetReplicatedSubscriptionStatusWithResponse call
func ParsePersistentTopicsSetReplicatedSubscriptionStatusResponse(rsp *http.Response) (*PersistentTopicsSetReplicatedSubscriptionStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetReplicatedSubscriptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsResetCursorOnPositionResponse parses an HTTP response from a PersistentTopicsResetCursorOnPositionWithResponse call
func ParsePersistentTopicsResetCursorOnPositionResponse(rsp *http.Response) (*PersistentTopicsResetCursorOnPositionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsResetCursorOnPositionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsResetCursorResponse parses an HTTP response from a PersistentTopicsResetCursorWithResponse call
func ParsePersistentTopicsResetCursorResponse(rsp *http.Response) (*PersistentTopicsResetCursorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsResetCursorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSkipMessagesResponse parses an HTTP response from a PersistentTopicsSkipMessagesWithResponse call
func ParsePersistentTopicsSkipMessagesResponse(rsp *http.Response) (*PersistentTopicsSkipMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSkipMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSkipAllMessagesResponse parses an HTTP response from a PersistentTopicsSkipAllMessagesWithResponse call
func ParsePersistentTopicsSkipAllMessagesResponse(rsp *http.Response) (*PersistentTopicsSkipAllMessagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSkipAllMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsCreateSubscriptionResponse parses an HTTP response from a PersistentTopicsCreateSubscriptionWithResponse call
func ParsePersistentTopicsCreateSubscriptionResponse(rsp *http.Response) (*PersistentTopicsCreateSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsCreateSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveSubscriptionDispatchRateResponse parses an HTTP response from a PersistentTopicsRemoveSubscriptionDispatchRateWithResponse call
func ParsePersistentTopicsRemoveSubscriptionDispatchRateResponse(rsp *http.Response) (*PersistentTopicsRemoveSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetSubscriptionDispatchRateResponse parses an HTTP response from a PersistentTopicsGetSubscriptionDispatchRateWithResponse call
func ParsePersistentTopicsGetSubscriptionDispatchRateResponse(rsp *http.Response) (*PersistentTopicsGetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DispatchRate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetSubscriptionDispatchRateResponse parses an HTTP response from a PersistentTopicsSetSubscriptionDispatchRateWithResponse call
func ParsePersistentTopicsSetSubscriptionDispatchRateResponse(rsp *http.Response) (*PersistentTopicsSetSubscriptionDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetSubscriptionDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveSubscriptionTypesEnabledResponse parses an HTTP response from a PersistentTopicsRemoveSubscriptionTypesEnabledWithResponse call
func ParsePersistentTopicsRemoveSubscriptionTypesEnabledResponse(rsp *http.Response) (*PersistentTopicsRemoveSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetSubscriptionTypesEnabledResponse parses an HTTP response from a PersistentTopicsGetSubscriptionTypesEnabledWithResponse call
func ParsePersistentTopicsGetSubscriptionTypesEnabledResponse(rsp *http.Response) (*PersistentTopicsGetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsSetSubscriptionTypesEnabledResponse parses an HTTP response from a PersistentTopicsSetSubscriptionTypesEnabledWithResponse call
func ParsePersistentTopicsSetSubscriptionTypesEnabledResponse(rsp *http.Response) (*PersistentTopicsSetSubscriptionTypesEnabledResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetSubscriptionTypesEnabledResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetSubscriptionsResponse parses an HTTP response from a PersistentTopicsGetSubscriptionsWithResponse call
func ParsePersistentTopicsGetSubscriptionsResponse(rsp *http.Response) (*PersistentTopicsGetSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePersistentTopicsTerminateResponse parses an HTTP response from a PersistentTopicsTerminateWithResponse call
func ParsePersistentTopicsTerminateResponse(rsp *http.Response) (*PersistentTopicsTerminateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsTerminateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsTerminatePartitionedTopicResponse parses an HTTP response from a PersistentTopicsTerminatePartitionedTopicWithResponse call
func ParsePersistentTopicsTerminatePartitionedTopicResponse(rsp *http.Response) (*PersistentTopicsTerminatePartitionedTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsTerminatePartitionedTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsTrimTopicResponse parses an HTTP response from a PersistentTopicsTrimTopicWithResponse call
func ParsePersistentTopicsTrimTopicResponse(rsp *http.Response) (*PersistentTopicsTrimTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsTrimTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsTruncateTopicResponse parses an HTTP response from a PersistentTopicsTruncateTopicWithResponse call
func ParsePersistentTopicsTruncateTopicResponse(rsp *http.Response) (*PersistentTopicsTruncateTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsTruncateTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsUnloadTopicResponse parses an HTTP response from a PersistentTopicsUnloadTopicWithResponse call
func ParsePersistentTopicsUnloadTopicResponse(rsp *http.Response) (*PersistentTopicsUnloadTopicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsUnloadTopicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsRemoveSubscriptionLevelDispatchRateResponse parses an HTTP response from a PersistentTopicsRemoveSubscriptionLevelDispatchRateWithResponse call
func ParsePersistentTopicsRemoveSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*PersistentTopicsRemoveSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsRemoveSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsGetSubscriptionLevelDispatchRateResponse parses an HTTP response from a PersistentTopicsGetSubscriptionLevelDispatchRateWithResponse call
func ParsePersistentTopicsGetSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*PersistentTopicsGetSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsGetSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePersistentTopicsSetSubscriptionLevelDispatchRateResponse parses an HTTP response from a PersistentTopicsSetSubscriptionLevelDispatchRateWithResponse call
func ParsePersistentTopicsSetSubscriptionLevelDispatchRateResponse(rsp *http.Response) (*PersistentTopicsSetSubscriptionLevelDispatchRateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PersistentTopicsSetSubscriptionLevelDispatchRateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResourceQuotasGetDefaultResourceQuotaResponse parses an HTTP response from a ResourceQuotasGetDefaultResourceQuotaWithResponse call
func ParseResourceQuotasGetDefaultResourceQuotaResponse(rsp *http.Response) (*ResourceQuotasGetDefaultResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceQuotasGetDefaultResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResourceQuotasSetDefaultResourceQuotaResponse parses an HTTP response from a ResourceQuotasSetDefaultResourceQuotaWithResponse call
func ParseResourceQuotasSetDefaultResourceQuotaResponse(rsp *http.Response) (*ResourceQuotasSetDefaultResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceQuotasSetDefaultResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResourceQuotasRemoveNamespaceBundleResourceQuotaResponse parses an HTTP response from a ResourceQuotasRemoveNamespaceBundleResourceQuotaWithResponse call
func ParseResourceQuotasRemoveNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*ResourceQuotasRemoveNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceQuotasRemoveNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResourceQuotasGetNamespaceBundleResourceQuotaResponse parses an HTTP response from a ResourceQuotasGetNamespaceBundleResourceQuotaWithResponse call
func ParseResourceQuotasGetNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*ResourceQuotasGetNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceQuotasGetNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResourceQuotasSetNamespaceBundleResourceQuotaResponse parses an HTTP response from a ResourceQuotasSetNamespaceBundleResourceQuotaWithResponse call
func ParseResourceQuotasSetNamespaceBundleResourceQuotaResponse(rsp *http.Response) (*ResourceQuotasSetNamespaceBundleResourceQuotaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceQuotasSetNamespaceBundleResourceQuotaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResourceGroupsGetResourceGroupsResponse parses an HTTP response from a ResourceGroupsGetResourceGroupsWithResponse call
func ParseResourceGroupsGetResourceGroupsResponse(rsp *http.Response) (*ResourceGroupsGetResourceGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceGroupsGetResourceGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResourceGroupsDeleteResourceGroupResponse parses an HTTP response from a ResourceGroupsDeleteResourceGroupWithResponse call
func ParseResourceGroupsDeleteResourceGroupResponse(rsp *http.Response) (*ResourceGroupsDeleteResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceGroupsDeleteResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseResourceGroupsGetResourceGroupResponse parses an HTTP response from a ResourceGroupsGetResourceGroupWithResponse call
func ParseResourceGroupsGetResourceGroupResponse(rsp *http.Response) (*ResourceGroupsGetResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceGroupsGetResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResourceGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResourceGroupsCreateOrUpdateResourceGroupResponse parses an HTTP response from a ResourceGroupsCreateOrUpdateResourceGroupWithResponse call
func ParseResourceGroupsCreateOrUpdateResourceGroupResponse(rsp *http.Response) (*ResourceGroupsCreateOrUpdateResourceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResourceGroupsCreateOrUpdateResourceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSchemasResourceTestCompatibilityResponse parses an HTTP response from a SchemasResourceTestCompatibilityWithResponse call
func ParseSchemasResourceTestCompatibilityResponse(rsp *http.Response) (*SchemasResourceTestCompatibilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasResourceTestCompatibilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IsCompatibilityResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemasResourceDeleteSchemaResponse parses an HTTP response from a SchemasResourceDeleteSchemaWithResponse call
func ParseSchemasResourceDeleteSchemaResponse(rsp *http.Response) (*SchemasResourceDeleteSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasResourceDeleteSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemasResourceGetSchemaResponse parses an HTTP response from a SchemasResourceGetSchemaWithResponse call
func ParseSchemasResourceGetSchemaResponse(rsp *http.Response) (*SchemasResourceGetSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasResourceGetSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemasResourcePostSchemaResponse parses an HTTP response from a SchemasResourcePostSchemaWithResponse call
func ParseSchemasResourcePostSchemaResponse(rsp *http.Response) (*SchemasResourcePostSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasResourcePostSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PostSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemasResourceGetSchemaByVersionResponse parses an HTTP response from a SchemasResourceGetSchemaByVersionWithResponse call
func ParseSchemasResourceGetSchemaByVersionResponse(rsp *http.Response) (*SchemasResourceGetSchemaByVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasResourceGetSchemaByVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemasResourceGetAllSchemasResponse parses an HTTP response from a SchemasResourceGetAllSchemasWithResponse call
func ParseSchemasResourceGetAllSchemasResponse(rsp *http.Response) (*SchemasResourceGetAllSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasResourceGetAllSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllVersionsSchemaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSchemasResourceGetVersionBySchemaResponse parses an HTTP response from a SchemasResourceGetVersionBySchemaWithResponse call
func ParseSchemasResourceGetVersionBySchemaResponse(rsp *http.Response) (*SchemasResourceGetVersionBySchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SchemasResourceGetVersionBySchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LongSchemaVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTenantsBaseGetTenantsResponse parses an HTTP response from a TenantsBaseGetTenantsWithResponse call
func ParseTenantsBaseGetTenantsResponse(rsp *http.Response) (*TenantsBaseGetTenantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantsBaseGetTenantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTenantsBaseDeleteTenantResponse parses an HTTP response from a TenantsBaseDeleteTenantWithResponse call
func ParseTenantsBaseDeleteTenantResponse(rsp *http.Response) (*TenantsBaseDeleteTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantsBaseDeleteTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTenantsBaseGetTenantAdminResponse parses an HTTP response from a TenantsBaseGetTenantAdminWithResponse call
func ParseTenantsBaseGetTenantAdminResponse(rsp *http.Response) (*TenantsBaseGetTenantAdminResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantsBaseGetTenantAdminResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TenantInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTenantsBaseUpdateTenantResponse parses an HTTP response from a TenantsBaseUpdateTenantWithResponse call
func ParseTenantsBaseUpdateTenantResponse(rsp *http.Response) (*TenantsBaseUpdateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantsBaseUpdateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTenantsBaseCreateTenantResponse parses an HTTP response from a TenantsBaseCreateTenantWithResponse call
func ParseTenantsBaseCreateTenantResponse(rsp *http.Response) (*TenantsBaseCreateTenantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TenantsBaseCreateTenantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWorkerStatsGetStatsResponse parses an HTTP response from a WorkerStatsGetStatsWithResponse call
func ParseWorkerStatsGetStatsResponse(rsp *http.Response) (*WorkerStatsGetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerStatsGetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerFunctionInstanceStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkerStatsGetMetricsResponse parses an HTTP response from a WorkerStatsGetMetricsWithResponse call
func ParseWorkerStatsGetMetricsResponse(rsp *http.Response) (*WorkerStatsGetMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerStatsGetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Metrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkerGetAssignmentsResponse parses an HTTP response from a WorkerGetAssignmentsWithResponse call
func ParseWorkerGetAssignmentsResponse(rsp *http.Response) (*WorkerGetAssignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetAssignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkerGetClusterResponse parses an HTTP response from a WorkerGetClusterWithResponse call
func ParseWorkerGetClusterResponse(rsp *http.Response) (*WorkerGetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []WorkerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkerGetClusterLeaderResponse parses an HTTP response from a WorkerGetClusterLeaderWithResponse call
func ParseWorkerGetClusterLeaderResponse(rsp *http.Response) (*WorkerGetClusterLeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetClusterLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkerInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkerIsLeaderReadyResponse parses an HTTP response from a WorkerIsLeaderReadyWithResponse call
func ParseWorkerIsLeaderReadyResponse(rsp *http.Response) (*WorkerIsLeaderReadyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerIsLeaderReadyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWorkerGetConnectorsListResponse parses an HTTP response from a WorkerGetConnectorsListWithResponse call
func ParseWorkerGetConnectorsListResponse(rsp *http.Response) (*WorkerGetConnectorsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetConnectorsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWorkerGetDrainStatusResponse parses an HTTP response from a WorkerGetDrainStatusWithResponse call
func ParseWorkerGetDrainStatusResponse(rsp *http.Response) (*WorkerGetDrainStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetDrainStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWorkerDrainResponse parses an HTTP response from a WorkerDrainWithResponse call
func ParseWorkerDrainResponse(rsp *http.Response) (*WorkerDrainResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerDrainResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWorkerGetDrainStatusFromLeaderResponse parses an HTTP response from a WorkerGetDrainStatusFromLeaderWithResponse call
func ParseWorkerGetDrainStatusFromLeaderResponse(rsp *http.Response) (*WorkerGetDrainStatusFromLeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerGetDrainStatusFromLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWorkerDrainAtLeaderResponse parses an HTTP response from a WorkerDrainAtLeaderWithResponse call
func ParseWorkerDrainAtLeaderResponse(rsp *http.Response) (*WorkerDrainAtLeaderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerDrainAtLeaderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseWorkerRebalanceResponse parses an HTTP response from a WorkerRebalanceWithResponse call
func ParseWorkerRebalanceResponse(rsp *http.Response) (*WorkerRebalanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &WorkerRebalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}
